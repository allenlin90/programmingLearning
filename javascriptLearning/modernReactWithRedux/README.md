Start learning on 2020/12/10
Finished 
---
1. [Let's Dive In!](#Let's-Dive-In!)
    1. [Our First App](#Our-First-App)
    1. [Critical Questions](#Critical-Questions)
    1. [Generating a React Project](#Generating-a-React-Project)
    1. [Why Create React App?](#Why-Create-React-App?)
    1. [Exploring a create-react-app project](#Exploring-a-create-react-app-project)
    1. [Starting and Stopping a React App](#Starting-and-Stopping-a-React-App)
    1. [Displaying Content with Functional Components](#Displaying-Content-with-Functional-Components)
1. [Building Content with JSX](#Building-Content-with-JSX)
    1. [What is JSX](#What-is-JSX)
    1. [Converting HTML to JSX](#Converting-HTML-to-JSX)
    1. [Inline Styling with JSX](#Inline-Styling-with-JSX)
    1. [Converting Styling to JSX Format](#Converting-Styling-to-JSX-Format)
    1. [Class vs ClassName](#Class-vs-ClassName)
    1. [Referencing JS Variables in JSX](#Referencing-JS-Variables-in-JSX)
    1. [Values JSX Can't Show](#Values-JSX-Can't-Show)
    1. [Finding Forbidden Property Name](#Finding-Forbidden-Property-Name)
1. [Communicating with Props](#Communicating-with-Props)
    1. [Three Tenets of Components](#Three-Tenets-of-Components)
    1. [Getting Some Free Styling](#Getting-Some-Free-Styling)
    1. [Specifying Images in JSX](#Specifying-Images-in-JSX)
    1. [Duplicating a Single Component](#Duplicating-a-Single-Component)
    1. [Extracting JSX to New Components](#Extracting-JSX-to-New-Components)
    1. [React's Props System](#React's-Props-System)
1. [Strucuturing Apps with Class-based Components](#Strucuturing-Apps-with-Class-based-Components) 
    1. [Class-based Components](#Class-based-Components)
    1. [Application Overview](#Application-Overview)
    1. [Application Overview - Season Experiencing](#Application-Overview---Season-Experiencing)
    1. [Handling Async Operations with Functional Components](#Handling-Async-Operations-with-Functional-Components)
    1. [Refactoring from Functional to Class Components](#Refactoring-from-Functional-to-Class-Components)
1. [State in React Components](#State-in-React-Components) 
    1. [The Rules of State](#The-Rules-of-State)
    1. [Initializing State Through Constructors](#Initializing-State-Through-Constructors)
    1. [Updating State Properties](#Updating-State-Properties)
    1. [Handling Error Gracefully](#Handling-Error-Gracefully)
1. [Understanding Lifecycle Methods](#Understanding-Lifecycle-Methods) 
    1. [Introducing Lifecycle Methods](#Introducing-Lifecycle-Methods)
    1. [Why Lifecycle Methods](#Why-Lifecycle-Methods)
    1. [Alternate State Initialization](#Alternate-State-Initialization)
    1. [Passing State as Props](#Passing-State-as-Props)
    1. [Showing Icons](#Showing-Icons)
    1. [Specifying Default Props](#Specifying-Default-Props)
    1. [Avoid Conditionals in Render](#Avoid-Conditionals-in-Render)
    1. [Breather and Review](#Breather-and-Review)
1. [Handling User Input with Forms and Events](#Handling-User-Input-with-Forms-and-Events) 
    1. [App Overview](#App-Overview)
    1. [Component Design](#Component-Design)
    1. [Adding Some Project Structure](#Adding-Some-Project-Structure)
    1. [Showing Forms to the User](#Showing-Forms-to-the-User)
    1. [Creating Event Handlers](#Creating-Event-Handlers)
    1. [Uncontrolled vs Controlled Elements](#Uncontrolled-vs-Controlled-Elements)
    1. [More on Controlled Elements](#More-on-Controlled-Elements)
    1. [Handling Form Submittal](#Handling-Form-Submittal)
    1. [Understanding 'this' in JavaScript](#Understanding-'this'-in-JavaScript)
    1. [Solving Context Issues](#Solving-Context-Issues)
    1. [Communicating Child to Parent](#Communicating-Child-to-Parent)
    1. [Invoking Callbacks in Children](#Invoking-Callbacks-in-Children)
1. [Making API Requests with React](#Making-API-Requests-with-React) 
    1. [Fetching Data](#Fetching-Data)
    1. [Axios vs Fetch](#Axios-vs-Fetch)
    1. [Viewing Request Results](#Viewing-Request-Results)
    1. [Handling Requests with Async Await](#Handling-Requests-with-Async-Await)
    1. [Setting State After Async Requests](#Setting-State-After-Async-Requests)
    1. [Creating Custom Clients](#Creating-Custom-Clients)
1. [Building Lists of Records](#Building-Lists-of-Records) 
    1. [Rendering Lists](#Rendering-Lists)
    1. [Review of Map Statements](#Review-of-Map-Statements)
    1. [Rendering Lists of Components](#Rendering-Lists-of-Components)
    1. [The Purpose of Keys in Lists](#The-Purpose-of-Keys-in-Lists)
    1. [Implementing Keys in Lists](#Implementing-Keys-in-Lists)
1. [Using Ref's for DOM Access](#Using-Ref's-for-DOM-Access)
    1. [Grid CSS](#Grid-CSS)
    1. [Issues with Grid CSS](#Issues-with-Grid-CSS)
    1. [Creating an Image Card Component](#Creating-an-Image-Card-Component)
    1. [Accessing the DOM with Refs](#Accessing-the-DOM-with-Refs)
    1. [Accessing Image Height](#Accessing-Image-Height)
    1. [Callbacks on Image Load](#Callbacks-on-Image-Load)
    1. [Dynamic Spans](#Dynamic-Spans)
    1. [App Review](#App-Review)
1. [Let's Test Your React Mastery!](#Let's-Test-Your-React-Mastery!)
    1. [Component Design](#Component-Design)
    1. [Scaffolding the App](#Scaffolding-the-App)
    1. [Reminder on Event Handlers](#Reminder-on-Event-Handlers)
    1. [Handling Form Submittal](#Handling-Form-Submittal)
    1. [Searching for Videos](#Searching-for-Videos)
    1. [Putting All Together](#Putting-All-Together)
    1. [Updating State with Fetched Data](#Updating-State-with-Fetched-Data)
    1. [Passing State as Props](#Passing-State-as-Props)
    1. [Rendering a List of Videos](#Rendering-a-List-of-Videos)
    1. [Rendering Video Thumbnails](#Rendering-Video-Thumbnails)
    1. [Styling a List](#Styling-a-List)
    1. [Communicating from Child to Parent](#Communicating-from-Child-to-Parent)
    1. [Deeply Nested Callbacks](#Deeply-Nested-Callbacks)
    1. [Conditional Rendering](#Conditional-Rendering)
    1. [Styling the VideoDetail](#Styling-the-VideoDetail)
    1. [Displaying a Video Player](#Displaying-a-Video-Player)
    1. [Fixing a Few Warnings](#Fixing-a-Few-Warnings)
    1. [Default Video Selection](#Default-Video-Selection)
1. [Understanding Hooks in React](#Understanding-Hooks-in-React)
    1. [React Hooks](#React-Hooks)
    1. [App Architecture ](#App-Architecture)
    1. [Communicating the Items Prop](#Communicating-the-Items-Prop)
    1. [Building and Styling the Accordion](#Building-and-Styling-the-Accordion)
    1. [Helper Functinos in Function Components](#Helper-Functinos-in-Function-Components)
    1. [Introducing useState](#Introducing-useState)
    1. [Understanding useState](#Understanding-useState)
    1. [Setter Functions](#Setter-Functions)
    1. [Expanding the Accordion](#Expanding-the-Accordion)
    1. [Creating Additional Widgets](#Creating-Additional-Widgets)
    1. [The Search Widget Architecture](#The-Search-Widget-Architecture)
    1. [Scaffolding the Widget](#Scaffolding-the-Widget)
    1. [Text Inputs with Hooks](#Text-Inputs-with-Hooks)
    1. [When do we Search?](#When-do-we-Search?)
    1. [The useEffect Hook](#The-useEffect-Hook)
    1. [Testing Execution](#Testing-Execution)
    1. [Async Code in useEffect](#Async-Code-in-useEffect)
    1. [Executing the Request from useEffect](#Executing-the-Request-from-useEffect)
    1. [Default Search Terms](#Default-Search-Terms)
    1. [List Building](#List-Building)
    1. [XSS Attacks in React](#XSS-Attacks-in-React)
    1. [XSS Server Code](#XSS-Server-Code)
    1. [Linking to a Wikipedia Page](#Linking-to-a-Wikipedia-Page)
    1. [Only Search with a Term](#Only-Search-with-a-Term)
    1. [Throttling API Requests](#Throttling-API-Requests)
    1. [Reminder on setTimeout](#Reminder-on-setTimeout)
    1. [useEffect's Cleanup Function](#useEffect's-Cleanup-Function)
    1. [Implementing a Delayed Request](#Implementing-a-Delayed-Request)
    1. [Searching on Initial Render](#Searching-on-Initial-Render)
    1. [Edge Case When Clearing Out Input Form](#Edge-Case-When-Clearing-Out-Input-Form)
    1. [Optional Video - Fixing a Warning](#Optional-Video---Fixing-a-Warning)
    1. [Dropdown Architecture](#Dropdown-Architecture)
    1. [Scaffolding the Dropdown](#Scaffolding-the-Dropdown)
    1. [A Lot of JSX](#A-Lot-of-JSX)
    1. [Selection State](#Selection-State)
    1. [Filtering the Option List](#Filtering-the-Option-List)
    1. [Hiding and Showing the Option List](#Hiding-and-Showing-the-Option-List)
    1. [Err... Why is this Hard?](#Err...-Why-is-this-Hard?)
    1. [Reminder on Event Bubbling](#Reminder-on-Event-Bubbling)
    1. [Applying What We've Learned](#Applying-What-We've-Learned)
    1. [Binding an Event Handler](#Binding-an-Event-Handler)
    1. [Why Stay Open](#Why-Stay-Open)
    1. [Which Element Was Clicked?](#Which-Element-Was-Clicked?)
    1. [Making use of useRef](#Making-use-of-useRef)
    1. [Body Event Listener Cleanup](#Body-Event-Listener-Cleanup)
    1. [The Translate Widget](#The-Translate-Widget)
    1. [Scaffolding the Translate Component](#Scaffolding-the-Translate-Component)
    1. [Adding the Language Input](#Adding-the-Language-Input)
    1. [Understanding the Convert Component](#Understanding-the-Convert-Component)
    1. [Google Translate API Key](#Google-Translate-API-Key)
    1. [Building the Convert Component](#Building-the-Convert-Component)
    1. [Using the Google Translate API](#Using-the-Google-Translate-API)
    1. [Displaying Translated Text](#Displaying-Translated-Text)
    1. [Debouncing Translation Updates](#Debouncing-Translation-Updates)
    1. [Reviewing useState and useEffect](#Reviewing-useState-and-useEffect)
1. [Navigation From Scratch](#Navigation-From-Scratch)
    1. [Navigation in React](#Navigation-in-React)
    1. [Basic Component Routing](#Basic-Component-Routing)
    1. [Building a Reusable Route Component](#Building-a-Reusable-Route-Component)
    1. [Implementing a Header for Navigation](#Implementing-a-Header-for-Navigation)
    1. [Handling Navigation](#Handling-Navigation)
    1. [Building a Link](#Building-a-Link)
    1. [Changing the URL](#Changing-the-URL)
    1. [Detecting Navigation](#Detecting-Navigation)
    1. [Updating the Route](#Updating-the-Route)
    1. [Handling Command Clicks](#Handling-Command-Clicks)
1. [Hooks in Practice](#Hooks-in-Practice)
    1. [Project Overview](#Project-Overview)
    1. [Refactoring the SearchBar](#Refactoring-the-SearchBar)
    1. [Refactoring the App](#Refactoring-the-App)
    1. [Removing a Callback](#Removing-a-Callback)
    1. [Overview on Custom Hooks](#Overview-on-Custom-Hooks)
    1. [Process for Building Custom Hooks](#Process-for-Building-Custom-Hooks)
    1. [Extracting Video Logic](#Extracting-Video-Logic)
    1. [Using the Custom Hook](#Using-the-Custom-Hook)
1. [Deploying a React App](#Deploying-a-React-App)
    1. [Deployment Overview](#Deployment-Overview)
    1. [Deployment with Vercel](#Deployment-with-Vercel)
    1. [Deployment with Netlify](#Deployment-with-Netlify)
1. [On We Go...To Redux!](#On-We-Go...To-Redux!)
    1. [Introduction to Redux](#Introduction-to-Redux)
    1. [Redux by Analogy](#Redux-by-Analogy)
    1. [A Bit More Analogy](#A-Bit-More-Analogy)
    1. [Finishing the Analogy](#Finishing-the-Analogy)
    1. [Mapping the Analogy to Redux](#Mapping-the-Analogy-to-Redux)
    1. [Modeling with Redux](#Modeling-with-Redux)
    1. [Creating Reducers](#Creating-Reducers)
    1. [Rules of Reducers](#Rules-of-Reducers)
    1. [Testing Our Example](#Testing-Our-Example)
    1. [Important Redux Notes](#Important-Redux-Notes)
1. [Integrating React with Redux](#Integrating-React-with-Redux) 
    1. [React Cooperating with Redux](#React-Cooperating-with-Redux)
    1. [React, Redux, and React-Redux](#React,-Redux,-and-React-Redux)
    1. [Design of the Redux App](#Design-of-the-Redux-App)
    1. [How React-Redux Works](#How-React-Redux-Works)
    1. [Redux Project Structure](#Redux-Project-Structure)
    1. [Named vs Default Exports](#Named-vs-Default-Exports)
    1. [Building Reducers](#Building-Reducers)
    1. [Wiring Up the Provider](#Wiring-Up-the-Provider)
    1. [The Connect Function](#The-Connect-Function)
    1. [Configuring Connect with MapStateToProps](#Configuring-Connect-with-MapStateToProps)
    1. [Building a List with Redux Data ](#Building-a-List-with-Redux-Data)
    1. [Calling Action Creators from Components](#Calling-Action-Creators-from-Components)
    1. [Redux is Not Magic](#Redux-is-Not-Magic)
    1. [Functional Components with Connect](#Functional-Components-with-Connect)
    1. [Conditional Rendering](#Conditional-Rendering)
1. [Async Actions with Redux Thunk](#Async-Actions-with-Redux-Thunk)
    1. [App Overview and Goals](#App-Overview-and-Goals)
    1. [Initial App Setup](#Initial-App-Setup)
    1. [Tricking Redux with Dummy Reducers](#Tricking-Redux-with-Dummy-Reducers)
    1. [A Touch More Setup](#A-Touch-More-Setup)
    1. [How to Fetch Data in a Redux App](#How-to-Fetch-Data-in-a-Redux-App)
    1. [Wiring Up an Action Creator](#Wiring-Up-an-Action-Creator)
    1. [Making a Request From an Action Creator](#Making-a-Request-From-an-Action-Creator)
    1. [Understanding Async Action Creators](#Understanding-Async-Action-Creators)
    1. [More on Async Action Creators](#More-on-Async-Action-Creators)
    1. [Middlewares in Redux](#Middlewares-in-Redux)
    1. [Behind the Scenes of Redux Thunk](#Behind-the-Scenes-of-Redux-Thunk)
    1. [Shortened Syntax with Redux Thunk](#Shortened-Syntax-with-Redux-Thunk)
1. [Redux Store Design](#Redux-Store-Design)
    1. [Rules of Reducers](#Rules-of-Reducers)
    1. [Return Values from Reducers](#Return-Values-from-Reducers)
    1. [Argument Values](#Argument-Values)
    1. [Pure Reducers](#Pure-Reducers)
    1. [Mutations in JavaScript](#Mutations-in-JavaScript)
    1. [Equality of Arrays and Objects](#Equality-of-Arrays-and-Objects)
    1. [A Misleading Rule](#A-Misleading-Rule)
    1. [Safe State Updates in Reducers](#Safe-State-Updates-in-Reducers)
    1. [Switch Statements in Reducers](#Switch-Statements-in-Reducers)
    1. [Dispatching Correct Values](#Dispatching-Correct-Values)
    1. [List Building](#List-Building)
    1. [Displaying Users](#Displaying-Users)
    1. [Fetching Singular Records](#Fetching-Singular-Records)
    1. [Displaying the User Header](#Displaying-the-User-Header)
    1. [Finding Relevant Users](#Finding-Relevant-Users)
    1. [Extracting Logic to MapStateToProps](#Extracting-Logic-to-MapStateToProps)
    1. [That's the Issue](#That's-the-Issue)
    1. [Memoizing Functions](#Memoizing-Functions)
    1. [Memoization Issues](#Memoization-Issues)
    1. [One Time Memoization](#One-Time-Memoization)
    1. [Alternate Overfecthing Solution](#Alternate-Overfecthing-Solution)
    1. [Action Creators in Action Creators](#Action-Creators-in-Action-Creators)
    1. [Finding Unique User Ids](#Finding-Unique-User-Ids)
    1. [Quick Refactor with Chain](#Quick-Refactor-with-Chain)
    1. [App Wrapup](#App-Wrapup)
1. [Navigation with React Router](#Navigation-with-React-Router)
    1. [App Outline](#App-Outline)
    1. [Mockups in Details](#Mockups-in-Details)
    1. [App Challenges](#App-Challenges)
    1. [Inital Setup](#Inital-Setup)
    1. [Introducing React Router](#Introducing-React-Router)
    1. [How React Router Works](#How-React-Router-Works)
    1. [How Paths Get Matched](#How-Paths-Get-Matched)
    1. [How to "Not" Navigate with React Router](#How-to-"Not"-Navigate-with-React-Router)
    1. [Navigating with React Router](#Navigating-with-React-Router)
    1. [Different Router Types](#Different-Router-Types)
    1. [Component Scaffolding](#Component-Scaffolding)
    1. [Wiring Up Routes](#Wiring-Up-Routes)
    1. [Always Visible Components](#Always-Visible-Components)
    1. [Connecting the Header](#Connecting-the-Header)
    1. [Links Inside Routers](#Links-Inside-Routers)
1. [Handling Authenitcation with React](#Handling-Authenitcation-with-React)
    1. [OAuth-Based Authentication](#OAuth-Based-Authentication)
    1. [OAuth for Servers vs Browser Apps](#OAuth-for-Servers-vs-Browser-Apps)
    1. [Creating OAuth Credentials](#Creating-OAuth-Credentials)
    1. [Wiring Up the Google API Library](#Wiring-Up-the-Google-API-Library)
    1. [Sending a User Into the OAuth Flow](#Sending-a-User-Into-the-OAuth-Flow)
    1. [Rendering Authentication Status](#Rendering-Authentication-Status)
    1. [Updating Auth State](#Updating-Auth-State)
    1. [Displaying Sign in and Sign Out](#Displaying-Sign-in-and-Sign-Out)
    1. [On-Demand Sign in and Sign Out](#On-Demand-Sign-in-and-Sign-Out)
    1. [Redux Architecture Design](#Redux-Architecture-Design)
    1. [Redux Setup](#Redux-Setup)
    1. [Connecting Auth with Action Creators](#Connecting-Auth-with-Action-Creators)
    1. [Building the Auth Reducer](#Building-the-Auth-Reducer)
    1. [Handling Auth Status Through Redux](#Handling-Auth-Status-Through-Redux)
    1. [Fixed Action Types](#Fixed-Action-Types)
    1. [Recording the User's ID](#Recording-the-User's-ID)
1. [Reducx Dev Tools](#Reducx-Dev-Tools)
    1. [Using Redux Dev Tools to Inspect the Store](#Using-Redux-Dev-Tools-to-Inspect-the-Store)
    1. [Debug Sessions with Redux Dev Tools](#Debug-Sessions-with-Redux-Dev-Tools)
1. [Handling Forms with Redux Form](#Handling-Forms-with-Redux-Form)
    1. [Forms with Redux Form](#Forms-with-Redux-Form)
    1. [Useful Redux Form Examples](#Useful-Redux-Form-Examples)
    1. [Conencting Reux Form](#Conencting-Reux-Form)
    1. [Creating Forms](#Creating-Forms)
    1. [Automatically Handling Events](#Automatically-Handling-Events)
    1. [Customizing Form Fields](#Customizing-Form-Fields)
    1. [Handling Form Submission](#Handling-Form-Submission)
    1. [Validation of Form Inputs](#Validation-of-Form-Inputs)
    1. [Displaying Validation Messages](#Displaying-Validation-Messages)
    1. [Showing Errors on Touch](#Showing-Errors-on-Touch)
    1. [Highlighting Errored Fields](#Highlighting-Errored-Fields)
1. [REST-based React Apps](#REST-based-React-Apps)
    1. [Creating Streams ](#Creating-Streams)
    1. [REST-ful Conventions](#REST-ful-Conventions)
    1. [Setting Up an API Server](#Setting-Up-an-API-Server)
    1. [Creating Streams Through Action Creators](#Creating-Streams-Through-Action-Creators)
    1. [Creating a Stream with REST Conventions](#Creating-a-Stream-with-REST-Conventions)
    1. [Dispatching Actions After Stream Creation](#Dispatching-Actions-After-Stream-Creation)
    1. [Bulk Action Creators](#Bulk-Action-Creators)
    1. [Object-Based Reducers](#Object-Based-Reducers)
    1. [Key Interpolation Syntax](#Key-Interpolation-Syntax)
    1. [Handling Fetching, Creating, and Updating](#Handling-Fetching,-Creating,-and-Updating)
    1. [Deleting Properties with Omit](#Deleting-Properties-with-Omit)
    1. [Merging Lists of Records](#Merging-Lists-of-Records)
    1. [Fetching a List of All Streams](#Fetching-a-List-of-All-Streams)
    1. [Rendering All Streams](#Rendering-All-Streams)
    1. [Associating Streams with Users](#Associating-Streams-with-Users)
    1. [Conditionally Showing Edit and Delete](#Conditionally-Showing-Edit-and-Delete)
    1. [Linking to Stream Creation](#Linking-to-Stream-Creation)
    1. [When to Navigate Users](#When-to-Navigate-Users)
    1. [History Reference](#History-Reference)
    1. [Creating a Browser History Object](#Creating-a-Browser-History-Object)
    1. [Implementing Programmatic Navigation](#Implementing-Programmatic-Navigation)
    1. [Manually Changing API Records](#Manually-Changing-API-Records)
    1. [URL-Based Selection](#URL-Based-Selection)
    1. [Wildcard Navigation](#Wildcard-Navigation)
    1. [More on Route Params](#More-on-Route-Params)
    1. [Selecting Records from State](#Selecting-Records-from-State)
    1. [Component Isolation with React Router](#Component-Isolation-with-React-Router)
    1. [Fetching a Stream for Edit Stream](#Fetching-a-Stream-for-Edit-Stream)
    1. [Real Code Reuse](#Real-Code-Reuse)
    1. [Refactoring Stream Creation](#Refactoring-Stream-Creation)
    1. [Setting Initial Values](#Setting-Initial-Values)
    1. [Avoiding Changes to Properties](#Avoiding-Changes-to-Properties)
    1. [Edit Form Submission](#Edit-Form-Submission)
    1. [PUT vs PATCH Requests](#PUT-vs-PATCH-Requests)
1. [Using React Portals](#Using-React-Portals) 
1. [Implementing Streaming Video](#Implementing-Streaming-Video) 
1. [The Context System with React](#The-Context-System-with-React) 
1. [Replacing Redux with Context](#Replacing-Redux-with-Context) 
1. [Working with Older Versions of React](#Working-with-Older-Versions-of-React) 
1. [Ajax Requets with React ](#Ajax-Requets-with-React) 
1. [Modeling Application State](#Modeling-Application-State) 
1. [Managing App State with Redux](#Managing-App-State-with-Redux) 
1. [Intermediate Redux: Middleware](#Intermediate-Redux:-Middleware) 
1. [React Router + Redux Form v6](#React-Router-+-Redux-Form-v6) 
1. [Bonus Topics](#Bonus-Topics) 
1. [React Router + Redux Form v4](#React-Router-+-Redux-Form-v4) 
1. [Extras](#Extras) 
---
# Let's Dive In!
## Our First App
1. We imported several objects from the other JavaScript file. We can check the [demo](https://codesandbox.io/s/react-jg4cq)
    ```js
    import "./styles.css";
    import React, { useState } from "react";
    import Field from "./components/field";
    import Languages from "./components/languages";
    import Translate from "./components/translate";

    export default function App() {
        const [language, setLanguage] = useState("zh-CN");
        const [text, setText] = useState("");

        return (
            <div>
            <Field label="Enter English" onChange={setText} value={text} />
            <Languages language={language} onLanguageChange={setLanguage} />
            <hr />
            <Translate text={text} language={language} />
            </div>
        );
    }
    ```
    <img src="./images/firstReactAppDemo.gif">

## Critical Questions
1. What was the 'App' function? 
    1. The `App` function in the previous is a `React Component`. The `App Component` produces JSX and handles user events.
    1. `JSX` is a set of instructions to tell React what content we want to show on the screen.
    1. We can use JSX elements to tell React to create a normal HTML element or show another component that has been created. 
    1. `JSX` will go through each of the elements in the code to check if it is a DOM element. If there's a DOM element, it shows on the screen. If the entity is not a DOM element, it will call the component function and inspect all the JSX.
1. How did some content get displayed on the screen?
    1. The first step is that the browser make a request to the host for the `index.html`.
    1. In the `index.html`, there's more script that will request another `bundle.js` which is bundled from `index.js`, `app.js`, and `react.js`. 
    1. Therefore, we get `index.html` and `bundle.js` from 2 requests. 
    <img src="./images/reactAppFiles.png">    
    1. In this case, the browser will firstly get `index.html` from the `public` folder which will make another requst for the script `index.js`.
    ```js
    // index.js 
    import React from "react";
    import ReactDOM from "react-dom";
    import App from "./App";

    ReactDOM.render(
        <App />, 
        document.getElementById("root")
        );
    ```
    1. Checking from the code, we can find the first statement in `ReactDOM.render()` is `<App />` which is to check the `App` function in `App.js`, get back `JSX` and turn it into HTML.
    1. Then `ReactDOM.render()` will take the HTML created by `JSX` and put it into the element selected by `document.getElementById("root")`.
1. What's the difference between React and ReactDOM?
    1. When working with React, we are working with 2 separate libraries. `React` and `ReactDOM`. 
    1. `React` knows how to work with components and is called a `reconciler`.
    1. `ReactDOM` knows how to work with take instructions on what we want to show and turn it into HTML and is called a `renderer`. It works as to take the HTML elements rendered by JSX to show on the screen.
1. What was all the '`useState`' stuff?
    1. `useState` is a function for users to work with React's `state` system. 
    1. State system is used to manage data and track data that changes over time.
    1. State system can be used to update the HTML on the screen.    

## Generating a React Project
1. After installing `NodeJS`, we can use `npm install -g create-react-app` to install the npm package to install `create-react-app` which is used to generate react projects. 
1. We then can use `create-react-app project_name` to create a react project at current directory.
1. `npx create-react-app project_name` is an alternative way to generate and start a react project.
1. This command will install all the required packages to work on a react project.
1. Note that since some update in year 2020, the method to install react with `create-react-app` locally has made some new generated project issues. Therefore, it's recommended to use `npx create-react-app project_name` to generate new react app.

## Why Create React App?
1. The main topic introduced here is `Babel` which can take any version of JavaScript such as ES2015, ES2016, and so on to turn them into ES5 which is the version that mostly all the browser support.

## Exploring a create-react-app project
1. By default, several files and folders are generated when creating a react project. 
1. `src` is the folder where we put all the source code we write.
1. `public` is the folder that stores static files like images.
1. `node_modules` is the folder that contains all of our project dependencies.
1. `package.json` records the project dependencies.
1. `package-lock.json` records the exact version of packages that we install.
1. `README.md` has the instructions on how to use this project. 

## Starting and Stopping a React App
1. After creating the new project, we can `cd` into the directory and use `npm start` to start the developing server and start development. The testing server will create the app at `localhost` at port `3000`.

## JavaScript Module Systems
1. In React, the code is separated in different JavaScript files and each of the won't affect to each other. 
1. By developing the React App, we use JavaScript module system which syntax is `imoprt React from 'react'`
    1. `import` is the key word to indicate that we want to get code from some other file or dependency.
    1. `React` is the variable we want to assign this import to. We can use the name arbitrarily. However, we should try to follow the convention to name the variable.
    1. `from` is a keyword that used in the syntax.
    1. `'react'` is the name of the dependency or path to the file we are importing.
1. When `import` from a file, this statement is to ask JavaScript to find the desirable module from `node_module` directories. In this case, we want to use the code in `react` and `react-dom`. 
1. There are 2 ways to import code from different JavaScript files. One is using `import` which is "ES2015 Modules system, while `require` is from "CommonJS Modules" which is a different module system. 
    ```js
    import React from 'react';
    import ReactDOM from 'react-dom';
    ```

## Displaying Content with Functional Components
1. A component is a "Function" or "Class" that produces HTML to show the user using "JSX" and handles feedback from the user using "Event Handlers".
1. After creating the JSX component, we use `ReactDOM` with `.render()` method to give the component and render it on the `index.html`. Note that in the HTML template, we have a HTML element `<div id="root"></div>` that will be used to render the React App. 
    ```js
    // import the React and ReactDOM libraries
    import React from 'react';
    import ReactDOM from 'react-dom';

    // Create a react component
    const App = () => {
        return <div>Hi there!</div>;
    }

    // Take the react component and show it on the screen
    ReactDOM.render(
        <App />,
        document.querySelector('#root')
    );
    ```



# Building Content with JSX
## What is JSX
1. In React, we use `Babel` to tranform ES2015 or more modern JavaScript code into ES5 to ensure all the browser can run the JavaScript. 
1. `Babel` can not only translate modern JavaScript code but also JSX code to work as JavaScript DOM.

## Convert HTML to JSX
1. JSX is special dialect of JS (which is not HTML).
1. Browser don't understand JSX code. We write JSX then run tools to turn it into normal JS.
1. JSX is very similar in form and function to HTML with a couple differences.
1. In convention, we can put parenthesis to wrap the HTML in after the `return` keyword in `App` function. 
1. However, in the following case, the code doesn't work and can't be rendered on React App.
    ```js
    // import the React and ReactDOM libraries
    import React from 'react';
    import ReactDOM from 'react-dom';

    // Create a react component
    const App = () => {
        return (
            <div>
                <label class="label" for="name">Enter name:</label>
                <input id="name" type="text"/>
                    <button style="background-color: blue; color: white;">Submit</button>
            </div>
        );
    };

    // Take the react component and show it on the screen
    ReactDOM.render(
                <App />,
        document.querySelector('#root')
    );
    ```

## Inline Styling with JSX
1. In JSX, we can't use regular inline styling syntax to decorate HTML elements.
1. In the naming convention in JSX, any properties that has dash `-` as delimeter between strings shall be converted into camel case. For example we turn `background-color` into `backgroundColor`.
    ```html
    <!-- html -->
    <div style="background-color:red;"></div>
    ```
    ```js
    <div style={{backgroundColor:'red'}}></div>
    ```

## Converting Styling to JSX Format
## Class vs ClassName
## Referencing JS variable in JSX
1. The value of the property should be single-quoted and be put as JavaScript object. While single-line properties such as `class` and `for`, we can use double quotes to wrap them.
1. The custom styling syntax to an element are different in JSX and HTML.
1. JSX uses different syntax to add a class to an element.
1. JSX can reference JS variables.
1. In JSX, we use `className` for `class` property in HTML. The main reason is that `class` is a reserved keyword in JavaScript to create classes for OOP.
1. We can easily insert a JavaScript variable in JSX by wrapping the JavaScript variable with curly braces `{}`. Note that this JavaScript variable reference has its limitation for certain data type or returned data value from the function.
    ```js
    // import the React and ReactDOM libraries
    import React from 'react';
    import ReactDOM from 'react-dom';

    function getButtonText() {
        return 'Click Me!';
    }
    // Create a react component
    const App = () => {
        const labelName = 'Click Me!';
        return (
            <div>
                <label className="label" for="name"> // use className rather than class in JSX
                    {labelName} // use curly braces to wrap JavaScript variable 
                </label>
                <input id="name" type="text" />
                <button style={{ backgroundColor: 'blue', color: 'white'}}> // use JavaScript object and change css property to camelCase
                    {getButtonText()} // use curly braces to wrap JavaScript function
                </button>
            </div>
        );
    };

    // Take the react component and show it on the screen
    ReactDOM.render(
        <App />,
        document.querySelector('#root')
    );
    ```

## Values JSX Can't Show
## Finding Forbidden Property Names
1. The JavaScript variable reference can take `Number` and `String` or an `Array` that has `Number` or `String` as its elements.
1. The elements in the array will be concatenated 
1. However, regular `Objects` are not available to be used as React child. However, if the value of a property in an object is string or number type of value, we can refer it in JSX directly. 
1. `for` is also a reserved JavaScript keyword which is used in `for loop`. Therefore, in the following case, we can specify the `for` attribute for `label` element in HTML as `htmlFor` to prevent warnning message from React. 
    ```js
    const App = () => {
        const buttonText = {text: 'Click Me'};
        const style = {backgroundColor: 'blue', color: 'white'};
        const labelText = 'Enter name:';

        return (
            <div>
                <label className="label" for="name">
                    {labelText}
                </label>
                <input id="name" type="text"/>
                <button style={style}>
                    {buttonText.text}
                </button>
            </div>
        );
    };
    ```



# Communicating with Props
## Three Tenets of Components
1. Component Nesting - A component can be shown in side of another
1. Component Reusability - We want to make components that can be easily reused through out application.
1. Component Configuration - We should be able to configure a component when it is created. 

## Application Overview
1. We are going to create a React component which has user profile, user name, date and time, and user comment.
1. We will use `semantic` UI CDN, which is a CSS library similar to Bootstrap. We can use the cdn at [<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.css">](<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.css">).
1. In this case, we create a new react project `components` with `npx create-react-app components`.

## Getting Some Free Styling
1. After creating the new react project, we remove all the files in `src` directory to get a clean start. 
1. We then create `index.js` in `src` directory.
1. In this case, we use the [comment](https://semantic-ui.com/views/comment.html) styling from semantic UI.

## Naive Component Approach
1. In the JSX, we use the follow HTML elements with semantic UI css to style it. 
    ```js
    <div className="comment">
        <a href="/" className="avatar">
            <img alt="avatar" />
        </a>
        <div className="content">
            <a href="/" className="author">
                Sam
            </a>
            <div class="metadata">
                <span className="date">Today at 6:00PM</span>
            </div>
            <div className="text">Nice blog post!</div>
        </div>
    </div>
    ```

## Specifying Images in JSX
1. In this case, we use a npm package `faker` which can provide mock up contents, data, and images. We can use `npm i faker --save` in the project directory.
    ```js
    import faker from 'faker';
    const App = () => {
        return (
            <img alt="avatar" src={faker.image.image()} />
        );
    }
    ```

## Duplicating a Single Component
## Extracting JSX to New Components
1. From the previous case, if we'd like to duplicate the same components from the page, we can only copy the HTML elements to be rendered in JSX, which can be very confusing when the project goes larger. This is why we'd like to use reusable components.
1. To create a reusable, configurable component, we can 
    1. Identify the JSX taht appears to be duplicated.
    ```js
    <div className="comment">
        <a href="/" className="avatar">
            <img alt="avatar" src={faker.image.image()} />
        </a>
        <div className="content">
            <a href="/" className="author">
                Sam
            </a>
            <div class="metadata">
                <span className="date">Today at 6:00PM</span>
            </div>
            <div className="text">Nice blog post!</div>
        </div>
    </div>
    ```
    1. What is the purpose of that block of JSX? Think of a descriptive name for what it does.    
    1. Create a new file to house this new component - it should have the same name as the component. In convention, we can capitalize the first letter of each term of the name. 
    1. Create a new component in the new file, paste the JSX into it.
    1. Make the new component configurable by using React's "props" system.
    ```js
    // CommentDetail.js
    import React from 'react';

    const CommentDetail = () => {
        return (
            <div className="comment">
                <a href="/" className="avatar">
                    <img alt="avatar" src={faker.image.image()} />
                </a>
                <div className="content">
                    <a href="/" className="author">
                        Sam
                    </a>
                    <div class="metadata">
                        <span className="date">Today at 6:00PM</span>
                    </div>
                    <div className="text">Nice blog post!</div>
                </div>
            </div>
        );
    };
    ```

## Component Nesting
1. To use the component, we need to `export` to component from the JavaScript file
    ```js
    // CommentDetail.js
    export default CommentDetail;
    ```
1. In the main `index.js` file, we can import the component with relative path.
1. To use the component we can use it as HTML element in JSX directly. Note that we don't use curly braces to render them as regular JavaScript functions. 
1. In this case, the components and contents of it are still static from hard code.
1. After the structure and layout is settled, we can start working on "props" system.
    ```js
    // index.js
    import React from 'react';
    import ReactDOM from 'react-dom';
    import CommentDetail from './CommentDetail';

    const App = () => {
        return (
            <CommentDetail />
            <CommentDetail />
            <CommentDetail />
        );
    };
    ```

## React's Props System
1. `Props` is the system for passing data from a "parent" component to a "child" compponent.
1. The goal is to customize or configure a child component.
1. In this case, each "comment" component has variables as `name`, `time`, `content` of comment.
1. "Props" stands for properties.

## Passing and Receiving Props
1. We can pass the data or value for the variable through the parent component to child component.
1. The parent component are those in `index.js`. In this case, we give each `CommentDetail` component with `author` attribute.
    ```js
    // index.js
    import React from 'react';
    import ReactDOM from 'react-dom';
    import CommentDetail from './CommentDetail';

    const App = () => {
        return (
            <div className="ui container comments">
                <CommentDetail author="Sam" />
                <CommentDetail author="Alex" />
                <CommentDetail author="Jane" />
            </div>
        );
    };

    ReactDOM.render(<App />, document.querySelector('#root'));
    ```
1. If we check in the component JS file, we can give component function a argument, such as `props` and check what data is in the object.
    ```js
    // CommentDetail
    const CommentDetail = (props) => {
        console.log(props);
        return (
            <div className="comment">
                <a href="/" className="avatar">
                    <img alt="avatar" src={faker.image.image()} />
                </a>
                <div className="content">
                    <a href="/" className="author">
                        {props.author} // take data given from the parent component 
                    </a>
                    <div className="metadata">
                        <span className="date">Today at 6:00PM</span>
                    </div>
                    <div className="text">Nice blog post!</div>
                </div>
            </div>
        );
    };
    ```

## Passing Multiple Props
1. In the last section, we pass autor name of each user who left a comment on the page. 
1. We'd like to pass other variables to the component. We can reformat the component into multiple lines.
    ```js
    // CommentDetail
    const CommentDetail = (props) => {
        console.log(props);
        return (
            <div className="comment">
                <a href="/" className="avatar">
                    <img alt="avatar" src={props.avatar} />
                </a>
                <div className="content">
                    <a href="/" className="author">
                        {props.author}
                    </a>
                    <div className="metadata">
                        <span className="date">{props.timeAgo}</span>
                    </div>
                    <div className="text">{props.comment}</div>
                </div>
            </div>
        );
    };

    // index.js
    const App = () => {
        return (
            <div className="ui container comments">
                <CommentDetail 
                    author="Sam" 
                    timeAgo="Today at 4:45PM" 
                    avatar={faker.image.image()} 
                    comment={faker.lorem.slug()} 
                />
                <CommentDetail
                    author="Alex"
                    timeAgo="Today at 2:00AM"
                    avatar={faker.image.image()}
                    comment={faker.lorem.slug()}
                />
                <CommentDetail
                    author="Jane"
                    timeAgo="Yesterday at 5:00PM"
                    avatar={faker.image.image()}
                    comment={faker.lorem.slug()}
                />
            </div>
        );
    };
    ```

## Component Reuse
## Implementing an Approval Card
1. We'd like to add more features on the comment component. In this case, we'd like to add an "Approve" and "Reject".
1. We create a new file in the same directory. In this case, we create `ApprovalCard.js`. In this case, we refer to the [cards](https://semantic-ui.com/views/card.html) in Semantic UI.
    ```js
    // ApprovalCard 
    import React from 'react';

    const ApprovalCard = () => {
        return (
            <div className="ui card">
                <div className="content">Are you sure?</div>
                <div className="extra content">
                    <div className="ui two buttons">
                        <div className="ui basic green button">Approve</div>
                        <div className="ui basic red button">Reject</div>
                    </div>
                </div>
            </div>
        );
    };

    export default ApprovalCard;
    ```
1. We then can put the new component in `index.js` directly to use. However, we haven't know how to make the `CommentDetail` component as the child element in the `ApprovalCard`. In the current layout the 2 components are parallel to each other in the same tier. 
    ```js
    // index.js
    const App = () => {
        return (
            <div className="ui container comments">
                <ApprovalCard />
                <CommentDetail
                    author="Sam"
                    timeAgo="Today at 4:45PM"
                    avatar={faker.image.image()}
                    comment={faker.lorem.slug()}
                />
                <CommentDetail
                    author="Alex"
                    timeAgo="Today at 2:00AM"
                    avatar={faker.image.image()}
                    comment={faker.lorem.slug()}
                />
                <CommentDetail
                    author="Jane"
                    timeAgo="Yesterday at 5:00PM"
                    avatar={faker.image.image()}
                    comment={faker.lorem.slug()}
                />
            </div>
        );
    };
    ```

## Showing Custom Child
1. To create relationship between the components, we can use opening and closing tags as regular HTML element to wrap the child compnent.
    ```js
    // index.js
    <ApprovalCard>
        <CommentDetail
            author="Sam"
            timeAgo="Today at 4:45PM"
            avatar={faker.image.image()}
            comment={faker.lorem.slug()}
        />
    </ApprovalCard>
    ```
1. If we go to `ApprovalCard.js` and add an argument to the render function, we can find that the `CommentDetail` has now become a child property in the object.
1. Therefore, we can use JSX syntax to call the value from the property to have `CommentDetail` nested in the `ApprovalCard`. The property of the object is `children`. Note that if we don't call the `children` property in the parent component, the children won't show up.
    ```js
    const ApprovalCard = (props) => {
        console.log(props) // check the child object in the parent component
        return (
            <div className="ui card">
                <div className="content">{props.children}</div> // use the child object in the parent component
                <div className="extra content">
                    <div className="ui two buttons">
                        <div className="ui basic green button">Approve</div>
                        <div className="ui basic red button">Reject</div>
                    </div>
                </div>
            </div>
        );
    };
    ```
1. Besides putting other comopnent as child or to be nested, we can use the `ApprovalCard` component with regualr HTML elements. Note that in the child component, we must put and refer to the properties that send from parent component.
    ```js
    // index.js
    <ApprovalCard>
        <div>
            <h4>Warning!</h4>
            Are you sure you want to do this?
        </div>
    </ApprovalCard>

    // ApprovalCard
    ApprovalCard = (props) => {
        return (
            {props.children}
        );
    };
    ```

# Strucuturing Apps with Class-based Components
## Class-based Components
1. A component can be either a `Function` or `Class` that produces HTML to show the user (which is using JSX) and handles feedback from the user (which is using event handler).
1. React used to work as the followings
    1. Functional Components can product JSX to show content to the user
    1. Class Components can produce JSX to show content to the user
        1. Can use the "Lifecycle Method" system to run code at specific points in time.
        1. Can use the "State" system to update content on the screen.
    1. The main difference between `Function` and `Class` componenet is that the function one is more straight forward while the class one can access "lifecycle method system" and "state system".
    1. In the past, `Class` components have more features than `Function` components.
1. React is now working with `"Hook"` system, which makes `Function` components similar to `Class` components.
1. In this case, companies with "established projects" are using class-based components, while companies with "newer projects" may be using class-based or function-based components.
1. In this sense, we should learn both class-based and function-based components.

## Application Overview - Season Experiencing
1. This app requires
    1. Needs to get the users physical location
    1. Needs to determine the current month
    1. Need to change text and styling based on location and month

## Scaffoldingthe the App
1. For this project, we use semantic UI at [<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.css">](<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.css">).
1. The steps of building the app in 2 parts, `App` and `SeasonDisplay`.
    1. Has the code to determine `location` and `month`.
    1. Shows different text/icons based on props.
    ```js
    // index.js
    import React from 'react';
    import ReactDOM from 'react-dom';

    const App = () => {
        return <div>Hi there!</div>;
    };

    ReactDOM.render(
        <App />,
        document.querySelector('#root')
    );


    // SeasonDisplay
    import React from 'react';

    const SeasonDisplay = () => {
        return <div>Season Display</div>;
    };

    export default SeasonDisplay;
    ```

## Getting a Users Physical Location
1. We can use browser navigator API to fetch user's location under user permission.
1. `windows.navigator.geoloaction.getCurrentPosition` takes 2 function arguments which is to return the `coords` object with users latitude and longitude with other metadata and the other callback function for returning error message.
1. Therefore, we can check user's location or get the message to know that if the user deny for location access.
    ```js
    // index.js
    window.navigator.geolocation.getCurrentPosition(
        (position) => console.log(position),
        (err) => console.log(err)
    );
    ``` 

## Handling Async Operations with Functional Components
1. After getting the location of the user from the API, it is challenging to use function component to render the data from async operations on the screen.
1. When the app is working
    1. JS file loaded by browser
    1. App component get created
    1. We call geolocation service
    1. App returns JSX, gets rendered to page as HTML
    1. We get result of geolocation
1. In short, the page is rendered before we get the location data from the user. 

## Refactoring from Functional to Class Components
1. Rules of Class Components
    1. Must be JavaScript class
    1. Must extend (subclss) `React.Component`
    1. Must define a `render` method that returns some amount of JSX
    ```js
    import React from 'react';
    import ReactDOM from 'react-dom';

    class App extends React.Component {
        render() {
            window.navigator.geolocation.getCurrentPosition(
                (position) => console.log(position),
                (err) => console.log(err)
            );

            return <div>Latitude: </div>;
        }
    }

    ReactDOM.render(
        <App />,
        document.querySelector('#root')
    );
    ```



# State in React Components 
## The Rules of State
1. Rules of State
    1. Only useable with class component.
    1. You will confuse `props` with state.
    1. '`State`' is a JS object that contains data relevant to a component.
    1. Updating '`state`' on a component causes the component to (almost) instantly rerender.
    1. State must be initialized when a component is created. 
    1. State can only be updated using the function `setState`!
1. We should always remeber to update state of a component only through `setState` function.

## Initializing State Through Constructors
1. As learnt from the previous section, we know that the state of a react component must be initialized when it is created. Therefore, in JavaScript class, we can use `constructor` function which will be first initiated when an instance is created through the object. 
    ```js
    class App extends React.Component {
        constructor (props) {
            super(props);

            this.state = { lat: null };
        }

        render() {
            windows.navigator.geolocation.getCurrentPosition(
                position => console.log(position),
                err => console.log(err),
            );

            return <div>Latitude: </div>
        }
    }
    ```
1. In addition, a side note that we must declare a render method in `App` class, which is extended from `React.Component`. React will return an error if the method is not defined. 
1. Besides, `constructor (props) {super(props);}` is like ceremonial process which must be done for react. 
1. By initializing the state, we can firstly assign a default value. In this case, we'd like to have the "**latitude**" of the user. As we haven't got the data, we can give the inital value as `null`. 

## Updating State Properties
1. We then can put the `this.state.lat` to the JSX to allow it to be rendered on the screen. 
1. Note that at this point, there's nothing will be rendered because the `state.lat` is set to be `null` by default. This is the only time we will use direct assignment to assign a value to the state.
1. We should always remember that we should use `.setState` method to update the state only.
    ```js
    class App extends React.Component {
        constructor (props) {
            super(props);

            this.state = { lat: null };

            windows.navigator.geolocation.getCurrentPosition(
                position => {
                    // we update state only through .setState method
                    this.setState({ lat = position.coords.latitude });
                },
                err => console.log(err),
            );
        }

        render() {
            return <div>Latitude: { this.state.lat }</div> // provide the value according to state
        }
    }
    ```

## App Lifecycle Walkthrough
1. We can only use `this.state` property on `this` object. The state system doesn't work if we use other property other than `state`. 
1. Note that every time when `state` is updated, react will almost instantly rerender the component. 
1. When the react app is opened by browser
    1. JS file loaded by browser.
    1. Instance of App component is created.
    1. App component `constructor` function gets called.
    1. State object is created and assigned to the `this.state` property.
    1. We call geolocation service.
    1. React calls the components render method.
    1. App returns JSX, gets rendered to page as HTML.
    1. We get result of geolocation from the async request.
    1. We update our state object that contains data with a call to `this.setState`.
    1. React sees that we updated the state of a component.
    1. React calls our `render` method a second time. 
    1. Render method returns some (updated) JSX.
    1. React takes that JSX and updates contents on the screen.
1. An important take away is that the components are actually rendred twice in this case. 
1. In this case, the `state` is firstly assigned with `null`, so that there's nothing shown after "**Latitude**".
1. After we receive data from the geolocation API, the `state` is updated, so react created the view with the updated view with the same components again.

## Handling Error Gracefully
1. Though we may have multiple properties in the `state` object, we don't need to update all the properties when receiving the data.
1. Besides, when we change returned JSX component from single line to multiple line, we would easily forget to take the semi-column at the last off, which can be hard to identify for the compiling error. 
    ```js
    class App extends React.Component {
        constructor(props) {
            super(props);

            // assign a 2nd property on state object
            this.state = { lat: null, errorMessage: '' };

            window.navigator.geolocation.getCurrentPosition(
                (position) => {
                    this.setState({ lat: position.coords.latitude });
                    console.log(position);
                },
                (err) => {
                    this.setState({ errorMessage: err.message });
                    console.log(err);
                }
            );
        }

        // React says we have to define render
        render() {
            return (
                <div>
                    Latitude: {this.state.lat}
                    <br />
                    Error: {this.state.errorMessage}
                </div> // don't forget to take semi-column off at the last line when changing from single line to multiple line
            );
        }
    }
    ```

## Conditionally Rendering Content
1. In this app, we'd like to show different content on the screen in different conditions.
    1. If we have got the `latitude`, we can show `latitude`.
    1. If we have error message, we should show the error message.
    1. If we haven't had any change or update, we can show "loading...".
1. Though there's another way to render contents on the screen by conditions, we can simply use `if` statements to decide what to be shown according to the properties in the `state` object.
    ```js
    class App extends React.Component {
        constructor(props) {
            super(props);

            this.state = { lat: null, errorMessage: '' };

            window.navigator.geolocation.getCurrentPosition(
                (position) => {
                    this.setState({ lat: position.coords.latitude });
                    console.log(position);
                },
                (err) => {
                    this.setState({ errorMessage: err.message });
                    console.log(err);
                }
            );
        }

        // React says we have to define render
        render() {
            if (this.state.errorMessage && !this.state.lat) {
                return <div>Error: {this.state.errorMessage}</div>;
            }

            if (!this.state.errorMessage && this.state.lat) {
                return <div>Latitude: {this.state.lat}</div>;
            }

            return <div>Loading!</div>;
        }
    }
    ```



# Understanding Lifecycle Methods
## Introducing Lifecycle Methods
1. For the `App` class instance, we can give more methods other than `constructor` and `render`. We can have `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount`. 
1. Each of those methods will be called in the different stage of the lifecycle of a component. 
1. Besides, `render` will be called multiple times during the lifecycle to render the JSX w/n updated data and values.
1. Component Lifecycle
    1. `constructor`
    1. `render` (which makes content visible on the screen)
    1. `componentDidMount` (Sit and wait for updates)
    1. `componentDidUpdate` (Sit and wait until this component is not longer shown)
    1. `componentWillUnmount` 
    ```js
    class App extends React.Component {
        constructor(props) {
            // properties and states
        }

        componentDidMount() {
            console.log('My component was rendered to the screen');
        }

        componentDidUpdate() {
            console.log('My component was just updated - it rerendered!');
        }

        render() {
            // render view to the screen
        }
    }
    ```

## Why Lifecycle Methods?
1. `constructor`is a good place to do one-time setup.
1. `render` can avoid doing anything besides returning JSX.
1. `componentDidMount` is a good place to do data loading.
1. `componentDidUpdate` is good place to do more data loading when state/props change.
1. `componentWillUnmount` is good place to do cleanup (especially for non-React stuff).
1. Though we can make API calls for asnyc request in `constructor` directly, it's not recommended to do so.
1. By keeping the data request separated in constructor, we can make the code cleaner.
1. In addition, there are other lifecycle methods avaiable but not in frequent use, such as `shouldComponentUpdate`, `getDerivedStateFromProps`, and `getSnapshotBeforeUpdate`.

## Refactoring Data Loading to Lifecycle Methods
1. We put the geolocation API which request for user location in `componentDidMount` method
    ```js
    // index.js in App class
    componentDidMount() {
        window.navigator.geolocation.getCurrentPosition(
            position => this.setState({ lat: position.coords.latitude }),
            err => this.setState({ errorMessage: err.message })
        );
    }
    ```

## Alternate State Initialization
1. We can refactor the constructor function in the class. In this case, we can simply use `state = { lat: null, errorMessage: ''}` without using `constructor (props) { super(props) }`.
1. The reason that it works because `Babel` compile the JavaScript into another form which is compatible with ES5 and older browsers.
    ```js
    class App extends React.Component {
        // build state without constructor function
        state = { lat: null, errorMessage: '' };

        componentDidMount() {
            // data that is mounted
        }

        componentDidUpdate() {
            console.log('My component was just updated - it rerendered!');
        }

        // React says we have to define render
        render() {
            // render JSX on screen
        }
    }
    ```
    <img src="./images/buildWithoutConstructorInReact.png">

## Passing State as Props
1. If there's no error message and we have received the latitude from geolocation API, we can pass it to the component to be rendered on the screen.
    ```js
    render() {
        if (!this.state.errorMessage && this.state.lat) {
            return <SeasonDisplay lat={this.state.lat} />;
        }
    }
    ```
1. We can update in `SeasonDisplay` component to receive the data from state. 
    ```js
    // SeasonDisplay.js
    import React from 'react';

    const SeasonDisplay = (props) => {
        console.log(props.lat);
        return <div>Season Display</div>;
    };

    export default SeasonDisplay;
    ```

## Determing Season
1. As we have got the latitude to know which part in the world (or area) is the user at, we can return the aligned weather or season according to the location.
1. In this case, if the month is from March to October, the northern part will be in summer, while the southern part will be in winter and vice versa. 
    ```js
    const getSeason = (lat, month) => {
        if (month > 2 && month < 9) {
            return lat > 0 ? 'summer' : 'winter';
        } else {
            return lat > 0 ? 'winter' : 'summer';
        }
    }

    const SeasonDisplay = (props) => {
        const season = getSeason(props.lat, new Date().getMonth());
        console.log(season);
        return <div>Season Display: {season}</div>;
    };
    ```

## Ternary Expresssion in JSX
1. We then can show different contents based on the returned value from `getSeason` function.
1. As the case is relatively simple, we can use ternary statement to return the desirable statement.
    ```js
    const SeasonDisplay = (props) => {
        const season = getSeason(props.lat, new Date().getMonth());
        const text = season === 'winter' ? 'Burr, it is chilly' : 'Lets hit the beach';

        return (
            <div>
                <h1>{text}</h1>
            </div>
        );
    };
    ```

## Showing Icons
1. We can use the [icons](https://semantic-ui.com/elements/icon.html#/icon) from semantic UI. In this case, we can use `sun` and `snowflake`. The syntax for semantic UI is `<i class="icon_name icon"></i>`.
1. We then can import the icon according to the data from `season`.
    ```js
    const SeasonDisplay = (props) => {
        const season = getSeason(props.lat, new Date().getMonth());
        const text = season === 'winter' ? 'Burr, it is chilly' : 'Lets hit the beach';
        const icon = season === 'winter' ? 'snowflake' : 'sun';

        return (
            <div>
                <i className={`${icon} icon`} />
                <h1>{text}</h1>
                <i className={`${icon} icon`} />
            </div>
        );
    };
    ```

## Extracting Options to Config Objects
1. For the required data as configurations, we can create another object in the file to serve the purpose for cleaner code. 
1. We can also use ES6 distructure to create variables from object properties. 
    ```js
    // SeasonDisplay.js
    const seasonConfig = {
        summer: {
            text: `Let's hit the beach`,
            iconName: 'sun'
        },
        winter: {
            text: `Burr, it is chilly`,
            iconName: 'snowflake'
        }
    };

    const getSeason = (lat, month) => {
        if (month > 2 && month < 9) {
            return lat > 0 ? 'summer' : 'winter';
        } else {
            return lat > 0 ? 'winter' : 'summer';
        }
    }

    const SeasonDisplay = (props) => {
        const season = getSeason(props.lat, new Date().getMonth());
        // ES6 destructuring assignment
        const { text, iconName } = seasonConfig[season];

        return (
            <div>
                <i className={`${iconName} icon`} />
                <h1>{text}</h1>
                <i className={`${iconName} icon`} />
            </div>
        );
    };
    ```

## Adding some styling
1. For styling with CSS, we can create `SeasonDisplay.css` in the same directory (src) with `SeasonDisplay.js`.
1. Note that we give each icon a class as `icon-left` and `icon-right`.
    ```js
    <div>
        <i className={`icon-left massive ${iconName} icon`} />
        <h1>{text}</h1>
        <i className={`icon-right massive ${iconName} icon`} />
    </div>
    ```
1. After creating the css file, we can import it into the JavaScript by using webpack. In react framework, we can simply import the css file.
    ```js
    // SeasonDisplay
    import './SeasonDisplay.css';
    ```
1. It is suggested to have the component name as the class name of the wrapper (container) of the HTML element, so we can ensure the following HTML elements can be easily grouped and selected with CSS as well.
    ```js
    const SeasonDisplay = (props) => {
        const season = getSeason(props.lat, new Date().getMonth());
        const { text, iconName } = seasonConfig[season];

        return (
            <div className={`season-display ${season}`}> // use component name
                <i className={`icon-left massive ${iconName} icon`} />
                <h1>{text}</h1>
                <i className={`icon-right massive ${iconName} icon`} />
            </div>
        );
    };
    ```
1. We use the following css to style our page.
    ```css
    /* SeasonDisplay.css */
    .icon-left {
        position: absolute;
        top: 10px;
        left: 10px;
    }

    .icon-right {
        position: absolute;
        bottom: 10px;
        right: 10px;
    }

    .season-display {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
    }

    .season-display.winter i {
        color: blue;
    }

    .season-display.summer i {
        color: red;
    }

    .winter {
        background-color: aliceblue;
    }

    .summer {
        background-color: orange;
    }
    ```

## Showing a Loading Snipper
1. During the very first view when the page is rendered, as we haven't got the data of the location from the user because the browser is asking for user's permission, the page is blank in this case.
1. We can add a loader to improve user experience and understand the state of the program that it is waiting to receive and load the contents after getting the data or permission from the user. 
1. In this case, we can refer to the [loader](https://semantic-ui.com/elements/loader.html) element from semantic UI.
1. As we should avoid using raw JSX in `App` directly and tend to create reusable components, we can create another file for `Spinner`.
    ```js
    // Spinner.js
    import React from 'react';

    const Spinner = () => {
        return (
            <div className="ui active dimmer">
                <div className="ui big text loader">Loading...</div>
            </div>
        );
    };

    export default Spinner;
    ```
1. We then can import and use the component in `App`.
    ```js
    import Spinner from './Spinner';
    render() {
        return <Spinner />;
    }
    ```

## Specifying Default Props
1. Though we have installed a loader (spinner animation) to indicate that the page is loading, it will much clearer to users that what are the current requirements to them. 
1. Therefore, we can use `props` to send `prop.message` variable from `App`.
1. In the component file, we can use `||` logical operator to return a default message when there's nothing passed to the variable because we could forget to put variable in by chances. However, we can use another syntax for the case.
    ```js
    // Spinner.js
    Spinner.defaultProps = {
        message: 'Loading...'
    }
    ```

## Avoid Conditionals in Render
1. If we'd like to create a template-like styling feature to apply to all the JSX, we don't need to add raw JSX directly with classes to the components.
1. We can use "helper function" that can apply all the elements with styling to the components. In this case, we create another method `renderContent` in `App` instance.
1. We then can use single element to wrap the returned JSX and call the method by `this.renderContent()`.
    ```js
    renderContent() {
        if (this.state.errorMessage && !this.state.lat) {
            return <div>Error: {this.state.errorMessage}</div>;
        }

        if (!this.state.errorMessage && this.state.lat) {
            return <SeasonDisplay lat={this.state.lat} />;
        }

        // return <Spinner />;
        return <Spinner message="Please accept location request" />;
    }

    // React says we have to define render
    render() {
        return (
            <div className="border red">
                {this.renderContent()} // call the rednerContent function for JSX
            </div>
        );
    };
    ```

## Breather and Review
1. Benefits of using `class` components
    1. Easier code organization.
    1. Can use `state` (another React system) which makes it easier to handle user input.
    1. Understands lifecycle events which makes it easier to do things when the app first starts.
1. In convention, we should put components at the bottom of the code and put configure object and helper function above.
1. Rules of `Class Components`
    1. Must be a JavaScript class.
    1. Must extend (subclass) from `React.Component`.
    1. Must define a `render` method that returns some amount of JSX.
1. Rules of `State`
    1. Only useable with class components.
    1. You will confuse `props` with `state`.
    1. `State` is a JS object that contains data relevant to a component.
    1. Updating `state` on a component causes the component to (almost) instantly rerender.
    1. `State` must be initializd when a component is created.
    1. `State` can be updated using the function `setState`.
1. We should never assign the value to properties on `state` object.
1. Component Lifecycle
    1. `constructor`
    1. `render`
    1. `componentDidMount`
    1. `componentDidUpdate`
    1. `componentWillUnmount`



# Handling User Input with Forms and Events 
## App Overview
1. The main tasks for the app to acheive 
    1. How do we get feedback from the user?
    1. How do we fetch data from some outside API or server?
    1. How do we show lists of records?
1. We will have several versions of app
    1. Show a list of results that the user searches. Users can scroll down to check all the results.
    1. Show a grid of results which images are in different sizes.

## Component Design
1. App Challenges
    1. Need to get earch term from the user.
    1. Need to use that search term to make a request to an outside API and fetch data.
    1. Need to take the fetched images and show them on the screen in a list.
1. In the 1st version app, we have 2 main components, `SearchBar` and `ImageList`. 

## Adding Some Project Structure
1. In this case, we'd like to strucutre and keep the files organized.
1. As we will use several components, we can create another folder `components` in the `src` directory.
1. In this case, we can keep `App` in a separate file.
    ```js
    // index.js 
    import React from 'react';
    import ReactDOM from 'react-dom';
    import App from './components/App'

    ReactDOM.render(
        <App />,
        document.querySelector('#root')
    );

    // App.js
    import React from 'react';

    const App = (props) => {
        return <div>App</div>;
    }

    export default App;
    ```

## Showing Forms to the User
1. We can create a `SearchBar` component and import it into `App.js`.
    ```js
    // components/SearchBar.js
    import React from 'react';

    class SearchBar extends React.Component {
        render() {
            return (
                <div>
                    <form>
                        <input />
                    </form>
                </div>
            );
        }
    }

    export default SearchBar;
    ```

## Adding a Touch Style
1. We can use CDN and `<link>` tag to use semantic UI.
1. After importing semantic UI, we can modify the sturecture of JSX.
1. We then add some inline styling for the component for the magin on the top to give some space for the component.
    ```js
    // SearchBar.js
    class SearchBar extends React.Component {
        render() {
            return (
                <div className="ui segment">
                    <form className="ui form">
                        <div className="field">
                            <label>Image Search</label>
                            <input type="text" />
                        </div>
                    </form>
                </div>
            );
        }
    }

    // App.js
    const App = (props) => {
        return (
            <div className="ui container" style={{ marginTop: '10px' }}>
                <SearchBar />
            </div>
        );
    };
    ```
    <img src="./images/picsSearchBar.png">

## Creating Event Handlers
1. We can use some event handling properties on the HTML element directly.
1. In this case, we want to catch what the user has input to the `SearchBar` component.
1. There are several frequent used event hanlders that we can use in the case.
    1. `onClick` works when user clicks on something.
    1. `onChange` works when user changes text in an input.
    1. `onSubmit` works when user submits a form.
1. In convention, we can name the event handling method starting with `on` or `handle` and starts with lowercase.
1. Note that we should only pass the callback function for `onChange` or `onClick` rather than using parethesis because we don't want the function be fired every time when the page is loaded.
    ```js
    class SearchBar extends React.Component {
        onInputChange(event) {
            console.log(event.target.value);
        }

        render() {
            return (
                <div className="ui segment">
                    <form className="ui form">
                        <div className="field">
                            <label>Image Search</label>
                            // use onChange with callback function
                            <input type="text" onChange={this.onInputChange} />
                        </div>
                    </form>
                </div>
            );
        }
    }
    ```

## Alternate Event Handler Syntax
1. Besides passing a method for the object to work on event handling, we can pass an anonymous function directly.
    ```js
    class SearchBar extends React.Component {
        onInputChange(event) {
            console.log(event.target.value);
        }

        render() {
            return (
                <div className="ui segment">
                    <form className="ui form">
                        <div className="field">
                            <label>Image Search</label>
                            // pass anonymous function rather than referring to object method
                            <input type="text" onChange={e => console.log(e.target.value)} />
                        </div>
                    </form>
                </div>
            );
        }
    }
    ```

## Uncontrolled vs Controlled Elements
1. The component is not controlled so far, and we can create a `state` object to catch the value when the user is working with the `App`.
1. In this case, we can use `value` property of `input` element to store the value that the user gives.
    ```js
    class SearchBar extends React.Component {
        state = { term: '' }

        render() {
            return (
                <div className="ui segment">
                    <form className="ui form">
                        <div className="field">
                            <label>Image Search</label>
                            <input
                                type="text"
                                value={this.state.term}
                                onChange={e => this.setState({ term: e.target.value })}
                            />
                        </div>
                    </form>
                </div>
            );
        }
    }
    ```

## More on Controlled Elements
1. Before we refactor the element to be controlled, we can use JavaScript and use DOM to check the value of the `input` element.
1. In this case, the react app itself doesn't actually know the value that is given by the user. 
1. This improve the preformance and efficiency for react app to manipulate the data, as the value is stored in the `state` and can be used instantly without fetching from the DOM (which is relatively slow) and use it somewhere else.
1. After refactoring the component, the process is changing from "fetching the data and use it" to "create with it since the beginning". 
1. When the component is rendered the data is stored in the `value` property at the beginning.
1. Besides, we can apply filter when receiving data input from users. For example, we can turn all the input string into uppercase or lowercase. 
    ```js
    class SearchBar extends React.Component {
        state = { term: '' }

        render() {
            return (
                <div className="ui segment">
                    <form className="ui form">
                        <div className="field">
                            <label>Image Search</label>
                            <input
                                type="text"
                                value={this.state.term}
                                // turn all the input into uppercase
                                onChange={e => this.setState({ term: e.target.value.toUpperCase() })}
                            />
                        </div>
                    </form>
                </div>
            );
        }
    }
    ```

## Handling Form Submittal
1. When user gives input in the input block and press <kbd>Enter</kbd>, the browser will send a request to the backend and refresh the page by default.
1. In vanilla JavaScript, We can use JavaScript DOM to select the `<form>` element and prevent it to proceed default behavior. 
1. In react, we can use `onSubmit` event handler in `<form>` tag and put the callback function in the object method to be called.
    ```js
    class SearchBar extends React.Component {
        state = { term: '' }

        onFormSubmit(event) {
            event.preventDefault();

            console.log(this.state.term);
        }

        render() {
            return (
                <div className="ui segment">
                    // use onSubmit property and callback function to prevent default behavior
                    <form className="ui form" onSubmit={this.onFormSubmit}>
                        <div className="field">
                            <label>Image Search</label>
                            <input
                                type="text"
                                value={this.state.term}
                                onChange={e => this.setState({ term: e.target.value })}
                            />
                        </div>
                    </form>
                </div>
            );
        }
    }
    ```
1. We can also put `console.log` in the `onFormSubmit` method to print what has the user gave to the app. However, at the current solution, it casues problems and turns the app collapse if we simply print the `state` in the method.
    ```js
    onFormSubmit() {
        // only printing the state make the app crashes
        console.log(this.state.term);
    }
    ```

## Understanding 'this' in JavaScript
1. The main reason that causes problems in the last section is the "**lexical scope**" where to call the method of the object. 
1. As the `render` method is called in the regular condition, the method can access `this` correct from the object. 
1. However, when we use callback in the method, the lexical scope changes, and `this` is pointing to the current lexical scope which doesn't have `this.state` property. This is the main reason why we get a reference error that the system prompts us that we are trying to fetch the value of a property from `undefined`.
1. Therefore, one of the solution is to use `.bind` method and refer to `this` when assigning callback function in the `onSubmit` property.
    ```js
    // this solution is from experience and current knowledge rather than from the course
    <form className="ui form" onSubmit={this.onFormSubmit.bind(this)}>
    ```

## Solving Context Issues
1. One of the solutions is to use `.bind` to method to refere to `this` when building the constructor
    ```js
    class Car {
        constructor() {
            // use bind to assign this to ensure 'this' is referred to correct object
            this.drive = this.drive.bind(this);
        }

        setDriveSound(sound) {
            this.sound = sound;
        }

        drive() {
            return this.sound;
        }
    }

    const car = new Car;
    car.setDriveSround('vroom');

    const drive = car.drive;
    ```
1. The other solution is to use arrow function in which `this` will refer to the parent scope of the arrow function. In this case, we have 2 ways to use arrow function.
    1. We can use arrow function to build the method when declaring the class.    
    ```js
    class SearchBar extends React.Component {
        // use arrow function to prevent incorrect scope reference
        onFormSubmit = (event) => {
            event.preventDefault();
            console.log(this.state.term);
        }

        render() {
            return(
                <form onSubmit={this.onFormSubmit}>
                    // ...
                </form>
            );
        }
    }
    ```
    1. The other way is to use arrow function in `render` method to as passing an anonymous arrow function for `onSubmit` property.
    ```js
    class SearchBar extends React.Component {
        onFormSubmit(event) {
            event.preventDefault();
            console.log(this.state.term);
        }

        render(){
            return (
                // pass an anonymous arrow function
                <form onSubmit={(event) => this.onFormSubmit(event)} className="ui form">
                    // ...
                </form>
            );
        };
    }
    ```

## Communicating Child to Parent
1. In this project, the main purpose for `SearchBar` component is to collect user input and pass the data to `App` component to work on further functions such as making a API request.
1. In the previous sections, we learnt usnig `props` system which only allows us to pass value from parent to child. 
1. The solution in this case is to turn `App` into a "**class**" component which has method that can be called by `SearchBar` component, so the value can be passed and retreived from `SearchBar` to `App`.
    ```js
    // App.js
    class App extends React.Component {
        onSearchSubmit(term) {
            console.log(term);
        }

        render() {
            return (
                <div className="ui container" style={{ marginTop: '10px' }}>
                    // pass the method of the class with 'this'
                    <SearchBar onSubmit={this.onSearchSubmit} />
                </div>
            );
        }
    };
    ``

## Invoking Callbacks in Children
1. In class based components, we need to refer to `this` to use `.prop` from parent component.
    ```js
    class SearchBar extends React.Component {
        state = { term: '' };

        onFormSubmit = (event) => {
            event.preventDefault();
            // use this.props to get the methods from parent component
            this.props.onSubmit(this.state.term);
        };

        render(props) {
            return (
                <div className="ui segment">
                    <form className="ui form" onSubmit={this.onFormSubmit}>
                        <div className="field">
                            <label>Image Search</label>
                            <input
                                type="text"
                                value={this.state.term}
                                onChange={e => this.setState({ term: e.target.value })}
                            />
                        </div>
                    </form>
                </div>
            );
        }
    }
    ```



# Making API Requests with React 
## Fetching Data
1. In this project, we can use unsplash api which provides HD images. Our task is to send request from our App to unsplash endpoint which will return a JSON file with data. We firstly go to register at [Unsplash Developer](https://unsplash.com/developers).
1. We can also check its [documentation](https://unsplash.com/documentation) to learn how to use unsplash endpoint.

## Axios vs Fetch
1. In React, we can use 3rd part package such as `axios` or `fetch` function that is built into modern browsers.
1. The tradeoff of using `fetch` is that it is a reltative low-level function that there's much more code we have to write. 
1. We can use `npm i axios --save` to install `axios` for the project. We then can use `import` syntax to use the package.
    ```js
    // App.js
    import axios from 'axios';
    ```

## Viewing Request Results
1. According to [Unsplash documentation](https://unsplash.com/documentation#search-photos), we can search for photos through `/search/photos` through `GET` request.
1. Note that the [root location](https://unsplash.com/documentation#location) for unsplash API is `https://api.unsplash.com/`.
1. To do [authentication](#https://unsplash.com/documentation#public-authentication), we can put the access key in the header of the request.
1. Note that we should follow the syntax and requirements from unsplash for the request specifically. For example, according to documentation `Authorization: Client-ID YOUR_ACCESS_KEY` is with uppercase `A` and `Client-ID` as part of the value for the property. We then put this in `headers` object in the request.
1. Besides, we can put the `term` which is the user input to `params` to send with the `GET` request.
1. Note that we haven't handle the JSON returned by reponse. However, we can check the data in develop console in the browser in "network" tab. We can find that a big object is returned and find `urls` in the `results` array for the images.
    ```js
    import React from 'react';
    import axios from 'axios';

    class App extends React.Component {
        onSearchSubmit(term) {
            axios.get('https://api.unsplash.com/search/photos', {
                params: {
                    query: term
                },
                headers: {
                    Authorization: 'Client-ID Aej6-RfDMJ9kg1hnpdUdDwgT9-A-HcEpol9FMj9ugn4'
                }
            });
        }

        render() {
            return (
                <div className="ui container" style={{ marginTop: '10px' }}>
                    <SearchBar onSubmit={this.onSearchSubmit} />
                </div>
            );
        }
    }

    export default App;
    ```

## Handling Requests with Async Await
1. The process of React app when running on request
    1. Component renders itself one time with no list of images
    1. `onSearchSubmit` method is called
    1. Request is made to `unspalsh`
    1. Wait for response from the API
    1. Request complete
    1. Set image data on `state` of `App` component
    1. `App` component rerenders and shows images
1. There are 2 ways to handle async events, `Promise` or `Async Await`.
    1. To use `Promise`, we can take off the semi-column after the `axios` request and put `.then()` method to handle the response data.
    ```js
    onSearchSubmit(term) {
        axios.get('https://api.unsplash.com/search/photos', {
            params: {
                query: term
            },
            headers: {
                Authorization: 'Client-ID Aej6-RfDMJ9kg1hnpdUdDwgT9-A-HcEpol9FMj9ugn4'
            }
        })
        .then(response => {
            console.log(response.data.results);
        })
    }
    ```
    1. For `Async Await`, we should mark `onSearchSubmit` as `async` function.
    ```js
    async onSearchSubmit(term) { // decalre for async function
        const response = await axios.get('https://api.unsplash.com/search/photos', { // use await to put the function to event loop
            params: {
                query: term
            },
            headers: {
                Authorization: 'Client-ID Aej6-RfDMJ9kg1hnpdUdDwgT9-A-HcEpol9FMj9ugn4'
            }
        });

        // manipulate the response data in async function
        console.log(response.data.results);
    }
    ```

## Setting State After Async Requests
1. We then declare a `state` property in `App` class and give `images` as a property with default value as an empty array. In convention, if the data structure is confirmed, we can give either an empty array or object according to the requirements.
1. We will face the same issue for referring `this` to the correct object. According to previous sections, we can choose 1 of the 3 strategies to solve the issue.
1. In this case, we choose to declare the method with async arrow function.
1. In addition, we can modulize the `axios` API into another separated code to keep the code clean.
    1. Use `constructor` with `.bind`.
    ```js
    class App extends React.Component {
        constructor (props) {
            super(props);
            this.onSearchSubmit = this.onSearchSubmit.bind(this);
        }

        state = { images: [] };

        async onSearchSubmit(term) {
            const response = await axois.get('https://api.unsplash.com/search/photos', {
                params: {
                    query: term
                },
                headers: {
                    Authorization: 'Client-ID Your_Accesss_Key'
                }
            });

            this.setState({ images: response.data.results });
        }
    }
    ```
    1. Declare the method with arrow function in the class
    ```js
    onSearchSubmit = async (term) => {
        const response = await axois.get('https://api.unsplash.com/search/photos', {
            params: {
                query: term
            },
            headers: {
                Authorization: 'Client-ID Your_Accesss_Key'
            }
        });

        this.setState({ images: response.data.results });
    }
    ```
    1. Pass an anonymous arrow function for the callback function
    ```js
    class App extends React.Component {
        render() {
            return(
                <SearchBar onSubmit={this.onSearchSubmit} />
            );
        }
    }
    ```

## Creating Custom Clients
1. We create `api` folder in `src` folder, which we use to keep the `axios` request to unsplash endpoint.
1. In this case, we can separate the default parameters and keep them in a separate files to keep the main code cleaner.
1. According to `axios` library, we can create an `axios` object with pre-defined parameters and endpoint.
    ```js
    // src/api/unsplash.js
    import axios from 'axios';

    export default axios.create({
        baseURL: 'https://api.unsplash.com',
        headers: {
            Authorization: 'Client-ID Your_Unsplash_Access_Key'
        }
    });
    ```
1. We the can import the file and use it in the `App`.
    ```js
    // src/components/App.js
    import unsplash from '../api/unsplash.js';

    async onSearchSubmit(term) {
        // make GET request through unsplash object that is an axios object with pre-defined params
        const response = await unsplash.get('/search/photos', {
            params: { query: term }
        });

        this.setState({ images: response.data.results });
    }
    ```



# Building Lists of Records
## Rendering Lists
1. We create a new component `ImageList` in component directory to render the list of images returned from unsplash API. Note that we can retreieve data passed from parent object 
    ```js
    // src/components/ImageList.js
    import React from 'react';

    const ImageList = (props) => {
        return (
            console.log(props.images);
            <div>ImageList</div>;
        );
    };

    export defualt ImageList;
    ```
1. We import the `ImageList` to `App` comopnent and pass the array of image URLs from parent to child component. Note that we should pass the fetched data from `App` to `ImageList`, so it can be retreived from `props` argument. 
    ```js
    import ImageList from './ImageList.js';

    class App extends React.Component {
        state = {images: []};

        render() {
            return (
                <ImageList images={this.state.images} />
            );
        }
    }
    ```

## Review of Map Statements
1. `.map` is an array method for arrays in JavaScript that we can use the method to create a new array based on the elements of a given array.
1. Without the array method, we have to declare a new empty array and use `for loop` to push 
    ```js
    const numbers = [0, 1, 2, 3, 4];

    let newNumbers = [];

    for (let i = 0; i < numbers.length; i++) {
        newNumbers.push(numbers[i] * 10);
    }

    numbers.map( num => num * 10);

    numbers.map(num => <div>{num}</div>);
    ```

## Rendering Lists of Components
1. With `.map` array method, we can create a new array from the `props` which has an array of URLs and turn them into `<img>` tags that can show the images. 
1. Note that we will get a warning about the `key` prop for each child element. Note that the app still works though there's warning for this.
    ```js
    // ImageList.js
    import React from 'react';

    const ImageList = (props) => {
        const images = props.images.map((image) => {
            return <img src={image.urls.regular} />
        });

        return <div>{images}</div>;
    }

    export default ImageList;
    ```

## The Purpose of Keys in Lists
1. From the last section, we get warning noticed that "**Each child in an array or iterator should have a unique 'key' prop**".
1. The main purpose of using `key` is to prevent React repeating the tasks that have been done. For example, we have a list of 3 tasks that have been rendered on the screen. If we have another new task added to the list, we only want the React App to be efficient that it only renders the latest one which hasn't been rendered to the screen rather tahn rerender all the items again. 
1. Therefore, we use the `key` for each item that is iterated through an array.

## Implementing Keys in Lists
1. To give `key` to each item through iteration, we can give another property `key` to each `<img>` tag when creating the new array through `.map`.
1. After we give `key` property to each element, React also prompted another warning to request `alt` property for each image. `alt` is used and shown when the image can't be imported correctly, so it can describe what's going on with the image. This property is good for SEO and impaired users when browsing the web.
1. Besides, we can use destructuring assignment to create new arguments from the object directly.
    ```js
    import React from 'react';

    const ImageList = (props) => {
        console.log(props.images)
        const images = props.images.map(({ alt_description, id, urls }) => { // use destructuring assignment
            return <img key={id} src={urls.regular} alt={alt_description} />
        });

        return <div>{images}</div>;
    }

    export default ImageList;
    ```



# Using Ref's for DOM Access
## Grid CSS
1. In `pics` project, the images responded by Unsplash API is too large to provide a decent UI. 
1. For images, we can use CSS `Grid` system to create a layout. We create `ImageList.css` in comopnents directory.
    ```css
    .image-list {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
        grid-gap: 10px;
    }

    .image-list img {
        width: 250px;
    }
    ```
1. We need to assign class to the `<div>` tag which wraps all the images. Besides, we need to import the CSS file to use the style.
    ```js
    import './ImageList.css';
    import React from 'react';

    const ImageList = (props) => {
        console.log(props.images)
        const images = props.images.map(({ alt_description, id, urls }) => {
            return <img key={id} src={urls.regular} alt={alt_description} />
        });

        return <div className="image-list">{images}</div>;
    }

    export default ImageList;
    ```
    <img src="./images/pics_first_grid.png">

## Issues with Grid CSS
1. Though we give a grid layout for all the images in the list, each image has different size with various width and height. Besides, the white space between each cell in the grid can be either too large or small. If the white space is not enough, the image will overflow its own cell and overlap then cover images in the nearby cells. 
1. In this case, we can give a single CSS property `grid-row-end: span 2` which can span the space for the image. 
1. However, we can't hard coded for the case because each image would require different number of span in the grid. For example, some images can be held by a single regular cell, while some may need up to 4 spans.
1. Therefore, we can't simply solve the issue with only CSS. 
    ```css
    .image-list {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
        grid-gap: 10px;
        grid-auto-rows: 150px;
    }

    .image-list img {
        width: 250px;
        grid-row-end: span 2;
    }
    ```

## Creating an Image Card Component
1. We will create a new React component which will render each individual image. Besides, it will adjust the component according to the height of the single image. 
1. We then create a new JS file in `component` folder name `ImageCard.js`. We can use destructuring assignment to avoid retreiving data from object properties.
    ```js
    // src/components/ImageCard.js
    import React from 'react';

    class ImageCard extends React.Component {
        render() {
            const { alt_description, urls } = this.props.image;
            return (
                <div>
                    <img
                        alt={alt_description}
                        src={urls.regular}
                    />
                </div>
            );
        };
    }

    export default ImageCard;
    ```
1. Besides, we need to refactor `ImageList.js` 
    ```js
    import './ImageList.css';
    import React from 'react';
    import ImageCard from './ImageCard';

    const ImageList = (props) => {
        console.log(props.images)
        const images = props.images.map((image) => {
            return <ImageCard key={image.id} image={image} />
        });

        return <div className="image-list">{images}</div>;
    }

    export default ImageList;
    ``` 

## Accessing the DOM with Refs
1. The flow of how the components work
    1. Let the `ImageCard` render itself and its image
    1. Reach into the DOM and figure out the height of the image
    1. Set the image height on state to get the component to rerender
    1. When rerendering, assign a `grid-row-end` to make sure the image takes up the appropriate space. 
1. Note that in vanilla JavaScript, we can use DOM such as `document.querySelector('img')` to select the first image element on the page. Then we can use `.clientHeight` to check the height of the image.
1. In this case, we use "**React Reference System**" (`React Refs`) which can
    1. Gives access to a single DOM element
    1. We create `refs` in the constructor, assign them to instance variables, then pass to a particular JSX element as `props`.

## Accessing Image Height
1. To use `refs` in this case, we create `constructor` in `ImageCard` component.
1. Besides, we need to refer to its parent properties by using `super`.
1. Then we can declare the property for the object with `React.createRef()` to create a DOM node which selects the element.
1. We put `ref` with the value from the property in the `img` tag. Note that this is a JSX tag rather than HTML. This tag will become a DOM selector that collects the node info.
1. We then can use `componentDidMount` which will be triggered when the request has got the respond data. We can check the data that we select with `this.imageRef`. This will show the element that we select by the DOM.
1. However, we can't actually access the data from the DOM at this step. If the data is given and updated from an API, at the moment when the DOM is checked, the data is actually not returned from the API yet. 
1. Therefore, in the following case, we will see all `0`s printed in the console when we try to check `this.imageRef.current.clientHeight`. Note that we still can check the value from the object in the console directly because the web browser engine is fancy enough to get and show the data in the developer console. 
1. Nevertheless, we have to understand that in this step, the data hasn't actually been returned and this is the reason why we will get `0` printed from the property of the DOM node. 
    ```js
    import React from 'react';

    class ImageCard extends React.Component {
        constructor(props) {
            super(props);

            this.imageRef = React.createRef();
        }

        componentDidMount() {
            console.log(this.imageRef.current.clientHeight);
        }

        render() {
            const { alt_description, urls } = this.props.image;
            return (
                <div>
                    <img
                        ref={this.imageRef}
                        alt={alt_description}
                        src={urls.regular}
                    />
                </div>
            );
        };
    }

    export default ImageCard;
    ```

## Callbacks on Image Load
1. We then add an event listener on the node directly with an event `load`, which only fires when the image is loaded completely and call the callback function.
1. Note that this callback function is a method from the same object. To avoid incorrect `this` scope reference, we should use arrow function to declare the method in the class. 
    ```js
    import React from 'react';

    class ImageCard extends React.Component {
        constructor(props) {
            super(props);

            this.imageRef = React.createRef();
        }

        // add event listener and only runs the callback function after the image is loaded
        componentDidMount() {
            this.imageRef.current.addEventListener('load', this.setSpans);
        }

        // use arrow function to prevent incorrect this reference
        setSpans = () => {
            console.log(this.imageRef.current.clientHeight);
        }

        render() {
            const { alt_description, urls } = this.props.image;
            return (
                <div>
                    <img
                        ref={this.imageRef}
                        alt={alt_description}
                        src={urls.regular}
                    />
                </div>
            );
        };
    }

    export default ImageCard;
    ```

## Dynamic Spans
1. In the callback function `setSpan`, we can decide how much `span` we are going to assign to the element according to its height. 
1. We use `state` property to keep the updated and calculated number for `span` in `state.spans` and give the default value at `0`.
1. We calculate the number of `spans` that should be given to the image according to the height of each row in the `grid`. In this case, we have default height for each row as `grid-auto-rows: 10px`. Note that the initila height at `150px` is way too much that it gives too much white space between the images.
    ```js
    // src/components/ImageCard.js
    import React from 'react';

    class ImageCard extends React.Component {
        constructor(props) {
            super(props);

            this.state = { spans: 0 };

            this.imageRef = React.createRef();
        }

        componentDidMount() {
            this.imageRef.current.addEventListener('load', this.setSpans);
        }

        setSpans = () => {
            const height = this.imageRef.current.clientHeight;
            const spans = Math.ceil(height / 10);
            this.setState({ spans });
        }

        render() {
            const { alt_description, urls } = this.props.image;
            return (
                <div style={{ gridRowEnd: `span ${this.state.spans}` }}>
                    <img
                        ref={this.imageRef}
                        alt={alt_description}
                        src={urls.regular}
                    />
                </div>
            );
        };
    }

    export default ImageCard;
    ```
1. Note that we also need to adjust CSS to render the gap between the cells in the grid with `grid-gap`. Besides, we can give 2 values to the property, as the 1st one is for horizontal, and the 2nd one is for vertical. In this case, we only need gap between cells in the vertical way.
    ```css
    .image-list {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
        grid-gap: 0 10px;
        grid-auto-rows: 10px;
    }

    .image-list img {
        width: 250px;
        grid-row-end: span 2;
    }
    ```
    <img src="./images/picsGridFinal.png">


## App Review
1. As we learn from this project, in most of the cases to avoid incorrect `this` reference, we can use arrow function to declare functions.
1. We can use `props` system to communicate and send data from parent to child component. 
1. On the other hand, if we'd like to pass data from a child to its parent component, we can send a callback function for the child component to call and send the data back. 
1. `.map` is a useful array method to create a list in React app. 
1. To interact with DOM or individual element, we can use `refs` system to create a `ref` in the consturctor with `React.createRef()` then pass it as `ref` property into the tag of the element. We then can manipulate it as regular JavaScript DOM node.



# Let's Test Your React Mastery! 
## App Overview
## Component Design
1. In this case, we'd like to create a react app which allows users to search from YouTube open API to get a list of videos and have the video player at the middle of the page. 
1. In this case, we may have several components
    1. `SearchBar` is for users to input terms to search from YouTube open API.
    1. `VideoDetail` which is the video player with video details.
    1. `VideoList` contains VideoItems as a list.
    1. `VideoItem` is the child component in the `VideoList`.

## Scaffolding the App
1. In this case, we initiate the project by removing all the pre-created files in the `src` directory.
1. We create `App.js` and `SearchBar.js` in `components` folder in `src` and import them accordingly.
    ```js
    // SearchBar.js
    import React from 'react';

    class SearchBar extends React.Component {
        render() {
            return <div>SearchBar</div>;
        }
    }

    export default SearchBar;

    // App.js
    import React from 'react';
    import SearchBar from './SearchBar';

    class App extends React.Component {
        render() {
            return(
                <SearchBar />
            );
        }
    }

    export default App;

    // index.js
    import React from 'react';
    import ReactDOM from 'react-dom';
    import App from './component/App';

    ReactDOM.render(
        <App />,
        document.querySelector('#root')
    );
    ```

## Reminder on Event Handlers
1. We can import Semantic CSS with `<link>` tag in the index.html in the `public` folder.
1. Note that we'd like to change and trace on the value on the `input` element which user gives. Besides, we should be aware of the `this` scope that is referring, so we use arrow function to declare the method for the class.
    ```js
    import React from 'react';

    class SearchBar extends React.Component {
        state = { term: "" };

        onInputChange = (event) => {
            this.setState({term: event.target.value});
        }

        render() {
            return (
                <div className="search-bar ui segment">
                    <form className="ui form">
                        <label>Video Search</label>
                        <input
                            type="text"
                            value={this.state.term}
                            onChange={this.onInputChange}
                        />
                    </form>
                </div>
            );
        }
    }

    export default SearchBar;
    ```

## Handling Form Submittal
1. To handle and retrieve the value from the element, we can declare a method
    ```js
    class SearchBar extends React.Component {
        state = {term: ''};

        onInputChange = (event) => {
            this.setState({term: event.target.value});
        }

        onFormSubmit = (event) => {
            event.preventDefault();

            // TODO: Make sure we call 
            // callback from parent component
        }

        render() {
            return (
                <form onSubmit={this.onFormSubmit}>
                <input
                    type="text"
                    value={this.state.term}
                    onChange={this.onInputChange}
                />
                </form>
            )
        }
    }
    ```
1. Note that we can also use an anonymous arrow function with `onChange` property to update the value of the `state`.
    ```js
    <input
        type="text"
        value={this.state.term}
        onChange={ e => this.setState({term: e.target.value})}
    />
    ```

## Accessing the YouTube API
1. In this case, we can use YouTube Data API (which is v3 at the time of learning). We can create a new project and enable the API in Google Developer Console.
1. We then create a new folder `apis` in `src` directory and create `youtube.js` to keep the credentials (the API key from Google). Besides, we can configure the usage of the key such as limiting domain to access the API and what API services can be called by using the key. 

## Search for Videos
1. According to YouTube API documentation, we can check the details for `list` in [`Search`](https://developers.google.com/youtube/v3/docs/search/list) section. 
1. From here, we can check that what are the public data should we retreive from the API. The main parameters we will use are the followings 
    ```js 
    GET https://www.googleapis.com/youtube/v3/search

    let params = {
        part: String, // set as 'snippet'
        maxResults: Number, // default is 5 and can range from 0 to 50
        q: String,
        type: String // channel, playlist, or video
    }
    ```
1. We then update the `youtube.js`. Note that we only put part of the params here without `q`, as this parameter can be set in the other components. Besides, we only give the `baseURL` up to `v3` with a slash to close it because later we can use `axios.get('/search')` to make a GET request.
1. In addition, to prevent warning for not having `key` property for child component in React, we can add `type: 'video'` in the `params` when setting up the `axios` object. This will ensure the API calls only request for video rather than platlist or channel. 
    ```js
    import axios from 'axios';

    const KEY = 'AIzaSyBtvThRXE9n-l_Y1jIXhx_EtLitcWbb3kI';

    export default axios.create({
        baseURL: 'https://www.googleapis.com/youtube/v3',
        params: {
            part: 'snippet',
            maxResults: 5,
            key: KEY,
            type: 'video'
        }
    });
    ```

## Putting All Together
1. After configuring the `axios` object, we can use it in the `App` in a callback function and fire it every time when a user search for something. We add another method in `SearchBar` to pass data when a user search.
    ```js
    // SearchBar
    onFormSubmit = event => {
        event.preventDefault();
        this.props.onFormSubmit(this.state.term);
    }
    ```
1. We then configure the method in `App.js` to handle the request made by `axios`.
    ```js
    onTermSubmit = (term) => {
        youtube.get('/search', {
            params: {
                q: term
            }
        });
    }
    ```
1. We then can check if `axios` make a request to YouTube API. For example, in the developer console, we can check "Network" tab with `XHR` request. We can see if there's a request made to `search`. 

## Updating State with Fetched Data
1. Since we are expecting to use the data from a GET request, we should use async function to handle the respond data from the API call. In this case, we are going to use the `items` array from the response data. 
1. Besides, we need to use `state` system to keep the data response from the API. 
1. Note that we should always be careful with the inital data for the state properties. For example, we have a placeholder to show how many videos are in the list by using `.length` to check the number of elements in an array. Therefore, if we use `null` as the initial value for `state`, it will return an error as we can't check the `length` property of a `null` object.
    ```js
    import React from 'react';
    import SearchBar from './SearchBar';
    import youtube from '../apis/youtube';

    class App extends React.Component {
        state = { videos: new Array }; // this must be an empty array

        onTermSubmit = async (term) => {
            const response = await youtube.get('/search', {
                params: {
                    q: term
                }
            });

            this.setState({ videos: response.data.items });
        }

        render() {
            return (
                <div className="ui container">
                    <SearchBar onFormSubmit={this.onTermSubmit} />
                    I have {this.state.videos.length} videos; // if we use null as initial value in state, this may cause error
                </div>
            );
        };
    }

    export default App;
    ```

## Passing State as Props
1. In this project, we have 3 main components, `SearchBar`, `VideoDetail`, `VideoList` with `VideoItem` as child components.
    ```js
    // VideoList.js
    import React from 'react';

    const VideoList = (props) => {
        return (
            <div>{props.videos.length}</div>
        );
    }

    export default VideoList;
    ```
1. Besides, we need to update the `App` for the new data.
    ```js
    // App.js
    class App extends React.Component {
        state = { videos: new Array };

        onTermSubmit = async (term) => {
            const response = await youtube.get('/search', {
                params: {
                    q: term
                }
            });

            this.setState({ videos: response.data.items });
        }

        render() {
            return (
                <div className="ui container">
                    <SearchBar onFormSubmit={this.onTermSubmit} />
                    <VideoList videos={this.state.videos} />
                </div>
            );
        };
    }
    ```

## Rendering a List of Videos
1. We can use destructuring assignment for to get the array from `props` in `VideoList.js`.
1. As we will repeatly render each video with its data, we can create a new component as `VideoItem`.
    ```js
    // VideoItem.js
    import React from 'react';

    const VideoItem = (props) => {
        return <div>VideoItem</div>
    }

    export default VideoItem;
    ```
1. We use `.map()` method to create an array that has multiple `VideoItem` in it.
    ```js
    import React from 'react';
    import VideoItem from './VideoItem';

    const VideoList = ({ videos }) => {
        const renderedList = videos.map((video) => { // create an array of 'VideoItem'
            return <VideoItem />;
        });

        return (
            <div>{renderedList}</div>
        );
    }

    export default VideoList;
    ```

## Rendering Video Thumbnails
1. In the last section, we can have a list of `VideoItem`s in the `VideoList`. We'd like to pass in fetched data from YouTube API to create the components with useful information.
1. In this case, we just simply update the structure in `VideoItem` with an `<img>` tag and get the thumbnail from the fetched data. 
    ```js
    // VideoItem.js
    import React from 'react';

    const VideoItem = ({ video }) => {
        return (
            <div>
                <img src={video.snippet.thumbnails.medium.url} />
                {video.snippet.title}
            </div>
        );
    }

    export default VideoItem;
    ```

## Styling a List
1. In this section, we will use [`list]`(https://semantic-ui.com/elements/list.html) styling from Semantic UI. Accroding to the document, the HTML structure should be as the following with classes.
1. Besides, we will use the list with image from semantic ui. However, as we don't want the image becomes a circle for avatar, we can use `ui image` for the element.
    ```html
    <div class="ui relaxed divided list"> <!-- this should be the layer of VideoList -->
        <div class="item"> <!-- this is the layer for VideoItem -->
            <img class="ui avatar image" src="image.jpg">
            <div class="content">
                <a class="header">Header</a>
                <div class="description">
                    Here's the description
                </div>
            </div>
        </div>
    </div>
    ```
1. In this case, we'd have more custom styling on the elements, so we can create another CSS in `component directly. 
1. Note that we can give a specific `class` named as the component, so we will ensure the CSS selector selects the correct component and elements in it. 
    ```html
    <div className="video-item item">
        <img className="ui image" src={video.snippet.thumbnails.medium.url} />
        <div className="content">
            <a className="header" href="https://youtube.com/watch?v=${video.id.videoId}">{video.snippet.title}</a>
            <div className="description">{video.snippet.description}</div>
        </div>
    </div>
    ```
1. Note that as we are using CSS library, some of the selector and styling would be applied to the elements. For example, the `max-width` wouldn't work if the selector is only `.video-item img`. We can only select and apply styling with more specific selector such as `.video-item.item img`.
    ```css
    /* VideoItem.css */
    .video-item {
        display: flex !important;
        align-items: center !important;
        cursor: pointer;
    }

    .video-item.item img {
        max-width: 180px;
    }
    ```

## Communicating from Child to Parent
1. In this react app, we have 2 main property in `state` system which are the "**video list**" returned from the API called, and the "**selected video**" which the user picks from the rendered list. 
    <img src="./images/videoAppStructure.png">
1. Therefore, after the list is rendered, the user can choose one of the videos in the list. When the user click the list, the `state` is updated with the chosen one.
1. As the state property should be updated and reflect the user interaction on the components in the child ones, we can pass a callback function from `App` through `VideoList` to `VideoItem`. Therefore, each of the `VideoItem` component in the very bottom layer of the app will have 2 `props`, `video` and `onVideoSelect`.
1. When the user clicks one of the videos in the list, `onVideoSelect` callback is triggered and takes the value back to the `state` in `App`. This will cause `selectedVideo` on the very top in `App` also be fired and update the `state`.

## Deeply Nested Callbacks
1. We create a callback function in `App.js` to update the state when there's data caught by event handler and returend from child component. 
    ```js
    // App.js
    class App extends React.Component {
        state = { videos: new Array, selectedVideo: null };

        onTermSubmit = async (term) => {
            const response = await youtube.get('/search', {
                params: {
                    q: term
                }
            });

            this.setState({ videos: response.data.items });
        }

        // catch data from event handler in child component
        onVideoSelect = (video) => {
            console.log('From the App!', video);
        }

        render() {
            return (
                <div className="ui container">
                    <SearchBar onFormSubmit={this.onTermSubmit} />
                    // pass callback function to the child component
                    <VideoList onVideoSelect={this.onVideoSelect} videos={this.state.videos} />
                </div>
            );
        };
    }
    ```
1. As the middleware, we receive the callback function `onVideoSelect` from `App`. We then pass this callback function into the child component `VideoItem` for the event handler.
    ```js
    // VideoList.js
    const VideoList = ({ videos, onVideoSelect }) => {
        const renderedList = videos.map((video) => {
            // pass onVideoSelect callback function into VideoItem
            return <VideoItem onVideoSelect={onVideoSelect} video={video} />;
        });

        return (
            <div className="ui relaxed divided list">{renderedList}</div>
        );
    }
    ```
1. In `VideoItem`, we receive the callback function in `props`, while we use constructuring assignment to assign the callback function to a variable `onVideoSelect`. 
1. However, we want to call the callback function with an argument. We need to use arrow function syntax to call the callback function with an argument.
1. Therefore, when the user clicks the `VideoItem` component, it will trigger the callback function and send the data back to `App` layer and update the `state` object.
    ```js
    // VideoItem.js
    const VideoItem = ({ video, onVideoSelect }) => {
        return (
            <div onClick={() => onVideoSelect(video)} className="video-item item">
                <img className="ui image" src={video.snippet.thumbnails.medium.url} />
                <div className="content">
                    <div className="header">{video.snippet.title}</div>
                </div>
            </div>
        );
    }
    ```

## Conditional Rendering
1. We can create another component to show the details of the video, so we have `VideoDetail.js` created in `component directory.
    ```js
    // VideoDetail.js
    import React from 'react';

    const VideoDetail = ({ video }) => {
        if (!video) {
            return <div>Loading...</div>
        }
        return (
            <div>{video.snippet.title}</div>
        );
    }

    export default VideoDetail;
    ```
1. We have to ensure that our `App` has updated its method to update its `state` when a video from the list is selected. Besides, we should render the `VideoDetial` component on the screen.
    ```js
    // App.js
    import VideoDetail from './VideoDetail';
    class App extends React.Component {
        state = { videos: new Array, selectedVideo: null };
        
        onVideoSelect = (video) => {
            this.setState({ selectedVideo: video });
        }

        render() {
            return (
                <div className="ui container">
                    <SearchBar onFormSubmit={this.onTermSubmit} />
                    <VideoDetail video={this.state.selectedVideo} />
                    <VideoList onVideoSelect={this.onVideoSelect} videos={this.state.videos} />
                </div>
            );
        };
    }
    ```

## Styling the VideoDetail
1. In this case, we use some classes from Semantic UI to style `VideoDetail`
    ```html
    <div>
        <div className="ui segment">
            <h4 className="ui header">
                {video.snippet.title}
            </h4>
            <p>{video.snippet.description}</p>
        </div>
    </div>
    ```
    <img src="./images/videoDetail.png">

## Displaying a Video Player
1. In thic case, we can use `iframe` to show the YouTube player in the list. 
1. To embed the video from YouTube, we can refer to the "share" button in each video to check how does `iframe` work with it. For very basic we can give the embeding URL from YouTube in the `iframe` tag.
    ```html
    <iframe src="https://www.youtube.com/embed/{videoId}" />    
    ```
1. There are some issues that we haven't fixed at this moment that 
    1. The video list should be on the side of the embeded video rather than downbelow in a regualr screen size. 
    1. The `state` is not updated when the user searches another video that the selected video shown in `VideoDetail` can be very different from those in the `VideoList` after giving another search.
    1. Some warnings are given by React that `key` property is not given to each component in the list. 
    1. `alt` property is not given to `img` element.
    1. `title` property to `iframe` tag.
    ```js
    // VideoDetails
    import React from 'react';

    const VideoDetail = ({ video }) => {
        if (!video) {
            return <div>Loading...</div>
        }

        const videoSrc = `https://www.youtube.com/embed/${video.id.videoId}`;

        return (
            <div>
                <div className="ui embed">
                    <iframe src={videoSrc} />
                </div>
                <div className="ui segment">
                    <h4 className="ui header">
                        {video.snippet.title}
                    </h4>
                    <p>{video.snippet.description}</p>
                </div>
            </div>
        );
    }

    export default VideoDetail;
    ```

## Fixing a Few Warnings
1. We add `title` property in `iframe` in `VideoDetail`. In this case, we can just specify what is inside the `iframe`, and it is `video player`.
1. Add `alt` property in `VideoItem` for each image tag. We can use `video.snippet.title` to indicate what is the image.
1. In `VideoList` each of the `VideoItem` in the list, which is rendered by an array of components, should have a `key` property. Therefore, we can use `video.id.videoId` from each video object to have unique for each of them.
    ```js
    // VideoDetail.js
    <iframe title="video player" src={videoSrc} />
    // VideoItem.js
    <img alt={video.snippet.title} className="ui image" src={video.snippet.thumbnails.medium.url} />
    // VideoList.js
    const renderedList = videos.map((video) => {
        return <VideoItem key={video.id.videoId} onVideoSelect={onVideoSelect} video={video} />;
    });
    ```
1. After fixing the warnings and issues prompted from developer console, we can adjust the layout to have `VideoDetail` and `VideoList` stay side by side on the same position on the page. In this case, we can use "[grid system](https://semantic-ui.com/collections/grid.html)" from Semantic UI.
    ```html
    <!-- app.js -->
    <div className="ui container">
        <SearchBar onFormSubmit={this.onTermSubmit} />
        <div className="ui grid">
            <div className="ui row">
                <div className="eleven wide column">
                    <VideoDetail video={this.state.selectedVideo} />
                </div>
                <div className="five wide column">
                    <VideoList
                        onVideoSelect={this.onVideoSelect}
                        videos={this.state.videos} />
                </div>
            </div>
        </div>
    </div>
    ```
    <img src="./images/semanticUIGrid.png">

## Default Video Selection
1. In the last optimization, we'd like to give a default search term when users firstly start to use the React App, so it can show the appropriate prompt to let users know what to do. 
1. Besides, an issue that after the user selects one of the video from the video list, the `state` is updated but doesn't go along when the user searches something else which can give an awkward user experience.
1. To have the default video rendered in the `VideoDetail`, we can update the `state` when we get response from a new search from YouTube API. We can update the video with the very first element in the returned array, so the video player will show the video by default when the user search for a topic.
1. After that we can use `componentDidMount` as a method in `App` class. We can call `this.onTermSubmit('default searching term')` in this case. Therefore, when users open the App, they will see the `Loading` in a moment, then after the App get response from AJAX call, the content will be udpated to the default search term that we give in `componentDidMount`. 
    ```js
    // App.js
    componentDidMount() {
        this.onTermSubmit('Thailand Travel');
    }

    onTermSubmit = async (term) => {
        const response = await youtube.get('/search', {
            params: {
                q: term
            }
        });

        this.setState({
            videos: response.data.items,
            selectedVideo: response.data.items[0]
        });
    }
    ```



# Understanding Hooks in React 
## React Hooks
1. Hook System
    1. `useState` is a function that lets you use `state` in a functional component.
    1. `useEffect` is a function that lets you use something like "**lifecycle methods**" in a functional component.
    1. `useRef` is a function that lets you create a `ref` in a function component.
1. Hooks are a way to write resuable code, instead of more classic techniques like Inheritance.
1. There is a list of 10 "**Primitive**" Hooks (which are defined by the lecturer and not officially called primitive hooks in React).
    1. `useState`
    1. `useEffect`
    1. `useContext`
    1. `useRender`
    1. `useCallback`
    1. `useMemo`
    1. `useRef`
    1. `useImperativeHandle`
    1. `useLayoutEffect`
    1. `useDebugValue`
1. We can use the pre-defined hooks and use `useTranslate` to create "**custom**" hooks for repeatable and reuseable code.

## App Architecture
1. The architecture of this App includes the followings components
    1. Accordion component
    1. Wikipedia API search component
    1. Dropdown item selection component
    1. Google Translate API component
1. In this case, we can send `items` props from `App` to `Accordion` to render the item on the screen. This `items` can be an array of `item` that includes `title` and `content` for the topic.
1. For `State`, as we have only a question and answer opened at the same time. When the user click a question, only an answer section will be expanded. 
1. Therefore, we can have a single `state` as `activeIndex` to show which `item` is activated (which the user selects or clicks). However, this `state` can be used in `Accordion` directly because no other component really cares the state of the expansion of component. We then set up 2 files in `src`, `App.js` and `index.js`.
    ```js
    // index.js
    import React from 'react';
    import ReactDOM from 'react-dom';
    import App from './App';
    ReactDOM.render(<App />, document.querySelector('#root'));

    // App.js
    import React from 'react';
    export default () => {
        return <h1>Widgets App</h1>;
    }
    ```

## Communicating the Items Prop
1. We create a mockup array in `App.js` and send it to `Accordion` component to render it on screen.
    ```js
    // App.js
    import React from 'react';
    import Accordion from './components/Accordion';

    const items = [
        {
            title: 'What is React?',
            content: 'React is a front end JavaScript framework'
        },
        {
            title: 'why use React?',
            content: 'React is a favorite JS library among engineers'
        },
        {
            title: 'How do you use React?',
            content: 'You use React by creating components'
        }
    ]

    export default () => {
        return (
            <div>
                <Accordion items={items} />
            </div>
        );
    }
    ```

## Building and Styling the Accordion
1. In this case, we use Semantic UI for styling. However, as the CSS library is very strict on the HTML element structure, if we use a `<div>` tag to wrap the contents inside, it will has 2 broder overlapping on the top.
1. We can use `React.Fragment` as the JSX componont to prevent it returning another `<div>` tag. This is because all the child component to be rendered in a component shall be wrapped by a `<div>` tag. This is also useful when we have component in a HTML table. 
1. According to new official [React documentation](https://zh-hant.reactjs.org/docs/fragments.html), we can even use an empty `<>` brackets to represent `React.Fragment`.
    ```js
    import React from 'react';
    const Accordion = ({ items }) => {
        const renderedItems = items.map(item => {
            return (
                <React.Fragment key={item.title}> // use React.Fragment to prevent border overlapping on the top
                    <div className="title active">
                        <i className="dropdown icon"></i>
                        {item.title}
                    </div>
                    <div className="content active">
                        <p>{item.content}</p>
                    </div>
                </React.Fragment>
            );
        });

        return (
            <div className="ui styled accordion">
                {renderedItems}
            </div>)
            ;
    }

    export default Accordion;
    ```

## Helper Functinos in Function Components
1. In function-based component, we can't add a method and call it as class-based component directly. However, in JavaScript, we can declare a function in nearly any scope. This function is a "helper function".
1. We then pass the function in an anonymous arrow function for `onClick` event handler.
1. Therefore, when the user clicks any of the item in the list, it will print the prompt and index of the item in the developer console.
    ```js
    // Accordion.js 
    const Accordion = ({ items }) => {
        const onTitleClick = (index) => {
            console.log('Title clicked', index);
        }

        const renderedItems = items.map((item, index) => {
            return (
                <React.Fragment key={item.title}>
                    <div
                        className="title active"
                        onClick={() => onTitleClick(index)} // use arrow function for the correct function scope and prevent the function is called when the app startup
                    >
                        <i className="dropdown icon"></i>
                        {item.title}
                    </div>
                    <div className="content active">
                        <p>{item.content}</p>
                    </div>
                </React.Fragment>
            );
        });

        return (
            <div className="ui styled accordion">
                {renderedItems}
            </div>)
            ;
    }
    ```

## Introducing useState
## Understanding useState
1. In class-based component, the flow can go as the followings
    1. Declare a `state` in the class and assign it an initial value.
    1. Declare a method that uses `setState` to update the property in `state`.
    1. Refer value of the `state` from `this.state`. 
1. To use React Hook, we firstly use destructuring assignment to get `useState` from React library. Remember that `useState` in React Hook system is to enable use to use `state` system in functional component.
1. We then declare 2 variables `activeIndex` and `setActiveIndex` by initiate `useState` as `null` with desctructuring assignment. Note that `useState` returns an array. Besides, as the desctructuring assignment are creating new variables, we can actually change the name for `activeIndex`, `setActiveIndex`, and the initial value for the `state` according to the scenario.
1. In the helper function `onTitleClick`, we call `setActiveIndex` with the lastest value send with `onClick` event handler. Note that `setActiveIndex` is a setter function. When it is called, React will render the component. 
    ```js
    import React, { useState } from 'react';

    const Accordion = ({ items }) => {
        const [activeIndex, setActiveIndex] = useState(null);

        const onTitleClick = (index) => {
            setActiveIndex(index);
        }

        const renderedItems = items.map((item, index) => {
            return (
                <React.Fragment key={item.title}>
                    <div
                        className="title active"
                        onClick={() => onTitleClick(index)}
                    >
                        <i className="dropdown icon"></i>
                        {item.title}
                    </div>
                    <div className="content active">
                        <p>{item.content}</p>
                    </div>
                </React.Fragment>
            );
        });

        return (
            <div className="ui styled accordion">
                {renderedItems}
                <h1>{activeIndex}</h1>
            </div>)
            ;
    }

    export default Accordion;
    ```
    <img src="./images/compareFlowClassAndFunctionalComponent.png">
1. In this case, the downside of functional component is obvious that functional component can't set or change multiple `state` properties at the same time as class-based components do.
    <img src="./images/flowClassAndFunctionalComponentMultipleState.png">

## Setter Functions
1. The setter function, which is the 2nd function variable declare from the destructuring array assignment, will update the property in the `state` as `setState` method for class-based component. 
1. In this case, `activeIndex` will be updated after `setActiveIndex` is called with an argument.

## Expanding the Accordion
1. As `activeIndex` state will be updated all the time when the user clicks on any of the item in the list, we want the CSS styling be updated aligned with the value change. 
1. With Semantic UI, the component will be shrinked or expanded with the class name `active` in this HTML structure.
1. Therefore, when `renderedItems` is rendered, the App should check if `index` matches `activeIndex` and assign the `active` class to the element. 
    ```js
    // Accordion.js
    const renderedItems = items.map((item, index) => {
        const active = index === activeIndex ? 'active' : ''; // check if index is equal to activeIndex. If yes, assign active class to the element 

        return (
            <React.Fragment key={item.title}>
                <div
                    className={`title ${active}`}
                    onClick={() => onTitleClick(index)}
                >
                    <i className="dropdown icon"></i>
                    {item.title}
                </div>
                <div className={`content ${active}`}>
                    <p>{item.content}</p>
                </div>
            </React.Fragment>
        );
    });
    ```

## Creating Additional Widgets
1. `Accordion` is only one of the widgets we create for this App. In this project, we have 4 main components. Each of them uses different functions in React Hook System.
    1. Accordion uses `useState`
    1. Search with a list of results uses `useState` and `useEffect`
    1. A dropdown input uses `useState`, `useEffect`, and `useRef`
    1. Translation function with a text input, dropdown input, and an output that uses `useState`, `useEffect`, and `useRef`.

## The Search Widget Architecture
1. The main feature of the "**search widget**" is to allow users to give input for a topic from Wikipedia API. Then the App will render a list of results.
1. Wikipedia API is relatively easy to use as it doesn't require authentication. We can just give a request with the topic that we want to search in `srsearch` property. Wikipedia will send us back a JSON.
    ```
    en.wikipedia.org/w/api.php?action=query&list=search&format=json&srsearch={SEARCHTERM}
    ```

## Scaffolding the Widget
1. We create another component `Search.js` in the directory. 
1. In this case, as we haven't built the navigation bar on the top, users can't switch between the widgets in the App, so we just comment `<Accordion>` component in `App.js`.
    ```js
    // /component/Search.js
    import React from 'react';
    const Search = () => {
        return <h1>Search</h1>;
    }
    export default Search;
    ```

## Text Inputs with Hooks
1. Note that we **DO NOT** have any submit button for users to click for the search term. Therefore, we will make API call every time when there's a changing event in the input element. Though this is very inefficient for API calls, we will optimize and solve this problem later.
1. In this case, we just ensure that we have the inital setup for the App and doesn't have any error returned. 
1. There are 2 ways we can make to make API calls to the endpoint.
    ```js
    import React, { useState } from 'react';

    const Search = () => {
        const [term, setTerm] = useState('');

        return (
            <div>
                <div className="ui form">
                    <div className="field">
                        <label>Enter Search Term</label>
                        <input
                            className="input"
                            value={term}
                            onChange={(e) => setTerm(e.target.value)}
                        />
                    </div>
                </div>
            </div>
        );
    }

    export default Search;
    ```

## When do we Search?
1. There are 2 options to make API calls.
    1. Option 1
        1. User types in input
        1. `onChange` event handler called
        1. We take value from input and make request to API
        1. **Wait for response from the endponit**
        1. Get response from the endpoint
        1. Update '`results`' piece of `state`
        1. Component rerenders, we show list of results
    2. Option 2
        1. User types in input
        1. `onChange` event handler called
        1. Update '`term`' piece of `state`
        1. Component rerenders
        1. We add code to detect that '`term`' has changed
        1. Make request to API
        1. **Wait for response from the endpoint**
        1. Get response
        1. Update '`results`' piece of state
        1. Component rerenders, we show list of results
1. In Option 1, 
    1. Search instantly when `onChange` event triggers
    1. Tightly couples '`onChange`' event with search
1. In option 2, 
    1. Search when `'term'` piece of state changes
    1. Can easily trigger a search when other parameters change
    1. Easier to extract code out into a more reusable function
1. By using option 1, the search when fire every time when the user put some thing in the input, even though it is just a single character. This is not really efficient and can give too many requests to the endpoint that can affect user experience.
1. Therefore, we can use option 2 and check if everything is ready and make the API call. 

## The useEffect Hook
1. `useEffect` hook allows function components to use _something like_ lifecycle methods
1. We configure the hook to run some code automatically in one of three scenarios
    1. When the component is rendered **for the first time only**
    1. When the component is rendered **for the first time and whenever it rerenders**
    1. When the component is rendred **for the first time and whenever it rerenders and some piece of data has changed**
1. Note that though `useEffect` hook is similar to lifecycle methods such as `componentDidMount`, it doesn't work exactly the same that this pre-set methods, such as `componentWillMount` have no meaning to functional components. 
1. We then can use destructuring assignemnt to import it as `useState`. Then we can pass an anonymous arrow function that is code we want to run in the scenarios.
1. The 2nd argument for `useEffect` for the 3 scenarios are 
    1. `[]` that is an "empty array" that runs only at initial render.
    1. "nothing" (which means there's no 2nd argument) to run at inital render and run after eery rerender.
    1. "an array of elements" to run at initial render and run after every rerender if data has changed since last render.
    <img src="./images/useEffect2ndArg.png">
    ```js
    const Search = () => {
        const [term, setTerm] = useState('');

        useEffect(() => {
            console.log('useEffect');
        }, []);

        return (
            <div>
                <div className="ui form">
                    <div className="field">
                        <label>Enter Search Term</label>
                        <input
                            className="input"
                            value={term}
                            onChange={(e) => setTerm(e.target.value)}
                        />
                    </div>
                </div>
            </div>
        );
    }
    ```

## Testing Execution
1. In this case, as `term` is the `state` set for the component, it will change every time when the user gives something to the input. 
1. Therefore, giving no 2nd argument and give the array with `[term]` actually work the same in this case.
1. On the other hand, if we pass an empty array as the 2nd argument, the code will only be trigerred once. 
1. In most of the cases, we will use scenarios with an empty array or array of elements. We rarely don't pass any argument. 

## Async Code in useEffect
1. We can use `axios` to make API request in this case. The purpose of this `Search` widget it to fire a GET request to Wikipedia endpoint every time the user gives value to input. 
1. For functional component in React, we can't mark a function `async` if it is to be passed to `useEffect` as a callback function. However, we have several solutions for the case. In this case, we will use the fist option that is have a function variable.
    1. Have another function variable and declare it as `async`.
        ```js
        useEffect(() => {
            const search = async() => {
                await axios.get('url');
            }
            search();
        }, [term])
        ```
    1. Use JavaScript `IIFE` to execute an anonymous function immediately after it's declared. 
        ```js
        useEffect(() => {
            (async () => {
                await axios.get()
            })();
        }, [term]);
        ```
    1. Use regular `Promise` syntax to work on the response.
        ```js
        useEffect(() => {
            axios.get('url')
                .then((response) => {
                    console.log(response.data);
                });
        }, [term]);
        ```

## Executing the Request from useEffect
1. We use `axios` to make GET request to Wikipedia endpoint. Note that in the 2nd parameter as the object that passed to `axios` to make the call, we only need to have `params` to send the parameters as those in URLs if we access it from browser search bar. This is tricky that as modern website as `CORS` security that if the configure isn't correct, the request will be blocked and somehow it's now easy to figure out the issue. 
    ```js
    // components/Search.js
    useEffect(() => {
        const search = async () => {
            await axios.get('https://en.wikipedia.org/w/api.php', {
                params: {
                    action: 'query',
                    list: 'search',
                    origin: '*',
                    format: 'json',
                    srsearch: term,
                },
            });
        }
        search();
    }, [term]);
    ```

## Default Search Terms
1. With an array that has element in it, the setter function from React Hook system will render when the component is rendred **for the first time and whenever it rerenders and some piece of data has changed**.
1. Therefore, we may have 2 options for the inital value for `term` state. 
    1. Give a string value as default, so users can see a search result of a given term by default.
    1. Use `if` statement to check if `term` is given by the user and not empty, so the `axios` request won't be triggered in the initial stage when there's no thing given for `term`.
1. In this case, we can set a default string for users to check when they firstly access the App.

## List Building
1. After we get the response from the API call, we can create an array with `.map` method and render it on teh screen.
1. Note that when creating array of components in a list, we need to add `key` property.
1. However, Wikipedia API gives another feature to provide HTML tags in its contents, which can't be used directly and doesn't look good. 
    ```js
    // Search.js
    const Search = () => {
        const [term, setTerm] = useState('programming');
        const [results, setResults] = useState([]);

        console.log(results);

        useEffect(() => {
            const search = async () => {
                const { data } = await axios.get('https://en.wikipedia.org/w/api.php', {
                    params: {
                        action: 'query',
                        list: 'search',
                        origin: '*',
                        format: 'json',
                        srsearch: term,
                    },
                });

                setResults(data.query.search);
            }
            search();
        }, [term]);

        const renderedResults = results.map((result) => {
            return (
                <div key={result.pageid} className="item">
                    <div className="content">
                        <div className="header">
                            {result.title}
                        </div>
                        {result.snippet}
                    </div>
                </div>
            );
        })

        return (
            <div>
                <div className="ui form">
                    <div className="field">
                        <label>Enter Search Term</label>
                        <input
                            className="input"
                            value={term}
                            onChange={(e) => setTerm(e.target.value)}
                        />
                    </div>
                </div>
                <div className="ui celled list">{renderedResults}</div>
            </div>
        );
    }
    ```

## XSS Attacks in React
1. As the endpoint returning us contents with HTML tags, we can consider render the content as HTML directly.
1. In React, we actually have a way to render the HTML content received from another endpoint directly though this **IS NOT** recommended because this will be a security hole for the App. This is called `XSS` attack which stands for "**Cross Site Scripting**". This will allow others to run JavaScript in the App.
1. The syntax is to use `<span>` tag with a property `dangerouslySetInnerHTML` and give it an object with `__html` property.
    ```js
    // Search.js
    const renderedResults = results.map((result) => {
        return (
            <div key={result.pageid} className="item">
                <div className="content">
                    <div className="header">
                        {result.title}
                    </div>
                    // use dangerouslySetInnerHTML to render HTML contents directly
                    <span dangerouslySetInnerHTML={{ __html: result.snippet }}></span>
                </div>
            </div>
        );
    })
    ```
1. Therefore, we can only use this if the source of code is trustworthy. However, this is still not recommended to use.

## XSS Server Code
1. This is the code to set up a simple server to simulate XSS attack to the website. 
1. If you run the mini server and connect to the endpoint, we can press "t" in the search bar and see the result that the endpoint can inject code to control over the website or App which can steal sensitive user info.

## Linking to a Wikipedia Page
1. As we import and render teh snippet from Wikipedia endpoint, we'd like to create a button on the right to allow users to click and direct to Wikipedia for the full contents.
    ```js
    // Search.js
    const renderedResults = results.map((result) => {
        return (
            <div key={result.pageid} className="item">
                <div className="right floated content">
                    // add a new button
                    <a
                        className="ui button"
                        href={`https://en.wikipedia.org?curid=${result.pageid}`}
                    >
                        Go
                    </a>
                </div>
                <div className="content">
                    <div className="header">
                        {result.title}
                    </div>
                    <span dangerouslySetInnerHTML={{ __html: result.snippet }}></span>
                </div>
            </div>
        );
    });
    ```
1. However, at this point, the App still has some issue that when the user delete all the value in the input search bar, this React app will return an error because nothing can be searched or rendered. 
1. Remember that we fire the search request to Wikipedia all the time when user is typing something in the input search bar. 
1. Therefore, we'd like to improve the App that it only fire a request when the user has finished typing to improve efficiency, reduce workload, and prevent possible issues.

## Only Search with a Term
1. We can apply a relatively easy solution to prevent `search()` function fires when there's no text in the search bar.
1. However, this still hasn't prevent the app fire search request every time when the user types something in the search bar.
    ```js
    useEffect(() => {
        const search = async () => {
            const { data } = await axios.get('https://en.wikipedia.org/w/api.php', {
                params: {
                    action: 'query',
                    list: 'search',
                    origin: '*',
                    format: 'json',
                    srsearch: term,
                },
            });

            setResults(data.query.search);
        }

        // fire search function only when term is not empty
        if (term) {
            search();
        }
    }, [term]);
    ```

## Throttling API Requests
1. In this case, we can set a function to check and wait for every `500ms` to fire the search request if the user does typing and stop. Note that this time gap for waiting can be set arbitrarily.
    <img src="./images/setTimerFlowThrottle.png">

## Reminder on setTimeout
1. We can use `setTimeout` API in JavaScript to delay the search request. 
1. Every time the user types something, `setTimeout` API will create an async task in queue. Besides, we will cancel the time delay if this `setTimeout` is called again.
1. When execute `setTimeout`, it will return a number that we can use it with `clearTimeout` to cancel the execution.
1. Note that there are 2 ways we can solve this issue,
    1. We can use `state` to track on the condition of execution.
    1. We can use `useEffect` hook to cancel it.

## useEffect's Cleanup Function
1. Remember that `useEffect` works as lifecycle methods for components. In the current setting, we pass the 2nd argument as an array with element(s). Therefore, this `useEffect` will be trigerred when the App initiates and every time the element(s) in the given array is changed.
1. In addition, this `useEffect` function is only allowed to "**execute functions inside**" (as to fire search request and update `state`) or return another function.
1. Keep in mind that `useEffect` is only allowed to return a "**function**" rather than any other type of value. This returned function will be handled by React and be called sometime in the future in certain condition.
1. This returned function will be trigerred when the `state` is updated again. Then the `useEffect` will be executed once again. The flow is as 
    1. App initate and run `useEffect` first time for initial render. The returned function from `useEffect` is held and does nothing.
    1. When the user gives any input or change in the search bar, which update the `state` and rerender the component, returned function will be fired.
    1. After the returned function executed, `useEffect` will run and return the function to standby once again (as the feature of server that standing by and listening to request all the time).
    <img src="./images/useEffectReturnFunction.png">

## Implementing a Delayed Request
1. We then can add and return an arrow function to cancel the `setTimeout` by `clearTimeout`. Note that as the functions are in the same scope, we can catch the `setTimeoutId` directly. 
1. Therefore, this will cause an delay to fire the search request every time when users type in the search bar. 
1. This can reduce number of times that the App sending request to the endpoint, as it only works when the user finishes typing or if the user types slowly. Besides, we can even increase the delay time from `500ms` to `1000ms` as 1 second.
    ```js
    // Search.js
    useEffect(() => {
        const search = async () => {
            const { data } = await axios.get('https://en.wikipedia.org/w/api.php', {
                params: {
                    action: 'query',
                    list: 'search',
                    origin: '*',
                    format: 'json',
                    srsearch: term,
                },
            });

            setResults(data.query.search);
        }

        const timeoutId = setTimeout(() => {
            if (term) {
                search();
            }
        }, 500);

        return () => {
            clearTimeout(timeoutId);
        }
    }, [term]);
    ```
1. Though this has solved the problem and prevent sending requests to the endpoint very often, we have another issue that this will give another delay when the App initiates. The App will be delayed for the initial search at the beginning as well.

## Searching on Initial Render
1. We can use an `if` statement to check if the App is on the initla run. For example, if `term` has value and `results.length` is 0, it means we haven't got any response from the request call. Therefore, we can consider this as the inital stage of the App and do not run `setTimeout`. 
    ```js
    // Search.js
    useEffect(() => {
        const search = async () => {
            const { data } = await axios.get('https://en.wikipedia.org/w/api.php', {
                params: {
                    action: 'query',
                    list: 'search',
                    origin: '*',
                    format: 'json',
                    srsearch: term,
                },
            });

            setResults(data.query.search);
        }

        if (term && !results.length) {
            search();
        } else {
            const timeoutId = setTimeout(() => {
                if (term) {
                    search();
                }
            }, 500);

            return () => {
                clearTimeout(timeoutId);
            }
        }
    }, [term]);
    ```

## Edge Case When Clearing Out Input Form
## Optional Video - Fixing a Warning
1. From the previous section, we get a warning from React that "**React Hook `useEffect` has a missing dependency: 'results.length'**".
1. This is because when we decalre `useEffect` function, we didn't pass `results` as an element in the 2nd argument which is the array.
1. Without referring the `state` properties properly, the App may have some hard to debug issues or problems which are not easy to find. Therefore, the `ESlint` in React warns the programmer to correctly refer to the dependecies when using `useEffect`. 
    ```js
    // Search.js
    useEffect (() => {
    }, [term]);
    ```
1. We could consider to add `results.length` in this case to resolve the warning in developer console. However, this leads us to another bug that having 2 elements in the array will make the app fires request twice.
1. In this app, we have an `if` statement to check and fire the initial search when `term` has value and `results.length` is `0`. However, after we get the response from the request call, `results` is updated, so the `useEffect` is trigerred and run the code with `setTimeout` once which makes another request to the endpoint. 
    <img src="./images/componentRenderingFlowWithUseEffect.png">
1. Therefore, if we'd like to solve the issue by preventing sending the 2nd request and provide the dependency in the array, we need to restructure the search code.
1. In this case, we will set up 2 `useEffect` functions and create another `state` as `debouncedTerm`. Each of the `useEffect` function focus and run on different `state`. One watches over `term`, and the other watches over `devouncedTerm`. However, we are now going to modify the workflow of the app. 
    1. For the `useEffect` that watches over `debouncedTerm`, it will proceed on the data fetching request to the endpoint and will be initiated when the app starts.
    1. When the user types something, `term` in the `state` will be updated by the other `useEffect`. Besides, this `useEffect` function will set a timer to upadte `debouncedTerm`.
    1. If the user hasn't finished typing and before the timer stops, this `useEffect` will be trigerred and cancel the previous timer, updates `term` in `state`, and set a new timer to `debouncedTerm` again.
    1. When the user stops for `500ms`, or the timer runs out, `debouncedTerm` in state will be updated and be set to the same value as that in `term`. 
    1. When `state` updates, the component will be rerendered. 
1. As we have initial value for `term` state from the beginning, `term` is assigned to `debouncedTerm`, so `useEffect` for `debouncedTerm` can fire immediately and send a request to fetch data when the app initiates. After that, the app works as the flow shown below that `debouncedTerm` will only be updated if the user change the vaule in input search bar and stop typing for more than `1000ms`, which is the given time gap in this case.
    <img src="./images/useDebounceTerm169.png">
    <img src="./images/useDebounceTerm169_2.png">
    ```js
    // Search.js
    const Search = () => {
        const [term, setTerm] = useState('programming');
        const [debouncedTerm, setDebouncedTerm] = useState(term);
        const [results, setResults] = useState([]);

        useEffect(() => { // useEffect for term state
            const timerId = setTimeout(() => { // delay the function if the user is still styping
                setDebouncedTerm(term);
            }, 1000);

            return () => { // return a function and cancel setTimeout if the user keeps typing
                clearTimeout(timerId);
            }
        }, [term]); // initiate when the component is firstly rendered and whenever 'term' is udpated

        useEffect(() => { // useEffect for debouncedTerm state
            const search = async () => { // request to wikipedia endpoint with axios 
                const { data } = await axios.get('https://en.wikipedia.org/w/api.php', {
                    params: {
                        action: 'query',
                        list: 'search',
                        origin: '*',
                        format: 'json',
                        srsearch: term,
                    },
                });

                setResults(data.query.search); // update results state
            }

            search();
        }, [debouncedTerm]); // initiate when the component is firstly rendered and whenever 'debouncedTerm' is udpated

        const renderedResults = results.map((result) => {
            return (
                <div key={result.pageid} className="item">
                    <div className="right floated content">
                        <a
                            className="ui button"
                            href={`https://en.wikipedia.org?curid=${result.pageid}`}
                        >
                            Go
                        </a>
                    </div>
                    <div className="content">
                        <div className="header">
                            {result.title}
                        </div>
                        <span dangerouslySetInnerHTML={{ __html: result.snippet }}></span>
                    </div>
                </div>
            );
        });

        return (
            <div>
                <div className="ui form">
                    <div className="field">
                        <label>Enter Search Term</label>
                        <input
                            className="input"
                            value={term}
                            onChange={(e) => setTerm(e.target.value)}
                        />
                    </div>
                </div>
                <div className="ui celled list">{renderedResults}</div>
            </div>
        );
    }
    ```

## Dropdown Architecture

## Scaffolding the Dropdown

## A Lot of JSX

## Selection State

## Filtering the Option List

## Hiding and Showing the Option List

## Err... Why is this Hard?

## Reminder on Event Bubbling

## Applying What We've Learned

## Binding an Event Handler

## Why Stay Open

## Which Element Was Clicked?

## Making use of useRef

## Body Event Listener Cleanup

## The Translate Widget

## Scaffolding the Translate Component

## Adding the Language Input

## Understanding the Convert Component

## Google Translate API Key

## Building the Convert Component

## Using the Google Translate API

## Displaying Translated Text

## Debouncing Translation Updates

## Reviewing useState and useEffect



# Navigation From Scratch
## Navigation in React

## Basic Component Routing

## Building a Reusable Route Component

## Implementing a Header for Navigation

## Handling Navigation

## Building a Link

## Changing the URL

## Detecting Navigation

## Updating the Route

## Handling Command Clicks



# Hooks in Practice
## Project Overview

## Refactoring the SearchBar

## Refactoring the App

## Removing a Callback

## Overview on Custom Hooks

## Process for Building Custom Hooks

## Extracting Video Logic

## Using the Custom Hook



# Deploying a React App
## Deployment Overview

## Deployment with Vercel

## Deployment with Netlify



# On We Go...To Redux!
## Introduction to Redux

## Redux by Analogy

## A Bit More Analogy

## Finishing the Analogy

## Mapping the Analogy to Redux

## Modeling with Redux

## Creating Reducers

## Rules of Reducers

## Testing Our Example

## Important Redux Notes



# Integrating React with Redux
## React Cooperating with Redux

## React, Redux, and React-Redux

## Design of the Redux App

## How React-Redux Works

## Redux Project Structure

## Named vs Default Exports

## Building Reducers

## Wiring Up the Provider

## The Connect Function

## Configuring Connect with MapStateToProps

## Building a List with Redux Data 

## Calling Action Creators from Components

## Redux is Not Magic

## Functional Components with Connect 

## Conditional Rendering



# Async Actions with Redux Thunk
## App Overview and Goals

## Initial App Setup

## Tricking Redux with Dummy Reducers

## A Touch More Setup

## How to Fetch Data in a Redux App

## Wiring Up an Action Creator

## Making a Request From an Action Creator

## Understanding Async Action Creators

## More on Async Action Creators

## Middlewares in Redux

## Behind the Scenes of Redux Thunk

## Shortened Syntax with Redux Thunk



# Redux Store Design
## Rules of Reducers

## Return Values from Reducers

## Argument Values

## Pure Reducers

## Mutations in JavaScript

## Equality of Arrays and Objects

## A Misleading Rule

## Safe State Updates in Reducers

## Switch Statements in Reducers

## Dispatching Correct Values

## List Building

## Displaying Users

## Fetching Singular Records

## Displaying the User Header

## Finding Relevant Users

## Extracting Logic to MapStateToProps

## That's the Issue

## Memoizing Functions

## Memoization Issues

## One Time Memoization

## Alternate Overfecthing Solution

## Action Creators in Action Creators

## Finding Unique User Ids

## Quick Refactor with Chain

## App Wrapup



# Navigation with React Router
## App Outline

## Mockups in Details

## App Challenges

## Inital Setup

## Introducing React Router

## How React Router Works

## How Paths Get Matched

## How to "Not" Navigate with React Router

## Navigating with React Router

## Different Router Types

## Component Scaffolding

## Wiring Up Routes

## Always Visible Components

## Connecting the Header

## Links Inside Routers



# Handling Authenitcation with React
## OAuth-Based Authentication

## OAuth for Servers vs Browser Apps

## Creating OAuth Credentials

## Wiring Up the Google API Library

## Sending a User Into the OAuth Flow

## Rendering Authentication Status

## Updating Auth State

## Displaying Sign in and Sign Out

## On-Demand Sign in and Sign Out

## Redux Architecture Design

## Redux Setup

## Connecting Auth with Action Creators

## Building the Auth Reducer

## Handling Auth Status Through Redux

## Fixed Action Types

## Recording the User's ID



# Reducx Dev Tools
## Using Redux Dev Tools to Inspect the Store

## Debug Sessions with Redux Dev Tools


# Handling Forms with Redux Form
## Forms with Redux Form

## Useful Redux Form Examples

## Conencting Reux Form

## Creating Forms

## Automatically Handling Events

## Customizing Form Fields

## Handling Form Submission

## Validation of Form Inputs

## Displaying Validation Messages

## Showing Errors on Touch

## Highlighting Errored Fields



# REST-based React Apps 
## Creating Streams 

## REST-ful Conventions

## Setting Up an API Server

## Creating Streams Through Action Creators

## Creating a Stream with REST Conventions

## Dispatching Actions After Stream Creation

## Bulk Action Creators

## Object-Based Reducers

## Key Interpolation Syntax

## Handling Fetching, Creating, and Updating

## Deleting Properties with Omit

## Merging Lists of Records

## Fetching a List of All Streams

## Rendering All Streams

## Associating Streams with Users

## Conditionally Showing Edit and Delete

## Linking to Stream Creation

## When to Navigate Users

## History Reference

## Creating a Browser History Object

## Implementing Programmatic Navigation

## Manually Changing API Records

## URL-Based Selection

## Wildcard Navigation

## More on Route Params

## Selecting Records from State

## Component Isolation with React Router

## Fetching a Stream for Edit Stream

## Real Code Reuse

## Refactoring Stream Creation

## Setting Initial Values

## Avoiding Changes to Properties

## Edit Form Submission

## PUT vs PATCH Requests



# Using React Portals 

# Implementing Streaming Video

# The Context System with React 

# Replacing Redux with Context

# Working with Older Versions of React

# Ajax Requets with React 

# Modeling Application State

# Managing App State with Redux

# Intermediate Redux: Middleware

# React Router + Redux Form v6

# Bonus Topics

# React Router + Redux Form v4

# Extras

