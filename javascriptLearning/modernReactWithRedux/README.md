Start learning on 2020/12/10
Finished 

Course Link [https://www.udemy.com/course/react-redux/](https://www.udemy.com/course/react-redux/)
---
1. [Let's Dive In!](#Let's-Dive-In!)
    1. [Our First App](#Our-First-App)
    1. [Critical Questions](#Critical-Questions)
    1. [Generating a React Project](#Generating-a-React-Project)
    1. [Why Create React App?](#Why-Create-React-App?)
    1. [Exploring a create-react-app project](#Exploring-a-create-react-app-project)
    1. [Starting and Stopping a React App](#Starting-and-Stopping-a-React-App)
    1. [Displaying Content with Functional Components](#Displaying-Content-with-Functional-Components)
1. [Building Content with JSX](#Building-Content-with-JSX)
    1. [What is JSX](#What-is-JSX)
    1. [Converting HTML to JSX](#Converting-HTML-to-JSX)
    1. [Inline Styling with JSX](#Inline-Styling-with-JSX)
    1. [Converting Styling to JSX Format](#Converting-Styling-to-JSX-Format)
    1. [Class vs ClassName](#Class-vs-ClassName)
    1. [Referencing JS Variables in JSX](#Referencing-JS-Variables-in-JSX)
    1. [Values JSX Can't Show](#Values-JSX-Can't-Show)
    1. [Finding Forbidden Property Name](#Finding-Forbidden-Property-Name)
1. [Communicating with Props](#Communicating-with-Props)
    1. [Three Tenets of Components](#Three-Tenets-of-Components)
    1. [Getting Some Free Styling](#Getting-Some-Free-Styling)
    1. [Specifying Images in JSX](#Specifying-Images-in-JSX)
    1. [Duplicating a Single Component](#Duplicating-a-Single-Component)
    1. [Extracting JSX to New Components](#Extracting-JSX-to-New-Components)
    1. [React's Props System](#React's-Props-System)
1. [Strucuturing Apps with Class-based Components](#Strucuturing-Apps-with-Class-based-Components) 
    1. [Class-based Components](#Class-based-Components)
    1. [Application Overview](#Application-Overview)
    1. [Application Overview - Season Experiencing](#Application-Overview---Season-Experiencing)
    1. [Handling Async Operations with Functional Components](#Handling-Async-Operations-with-Functional-Components)
    1. [Refactoring from Functional to Class Components](#Refactoring-from-Functional-to-Class-Components)
1. [State in React Components](#State-in-React-Components) 
    1. [The Rules of State](#The-Rules-of-State)
    1. [Initializing State Through Constructors](#Initializing-State-Through-Constructors)
    1. [Updating State Properties](#Updating-State-Properties)
    1. [Handling Error Gracefully](#Handling-Error-Gracefully)
1. [Understanding Lifecycle Methods](#Understanding-Lifecycle-Methods) 
    1. [Introducing Lifecycle Methods](#Introducing-Lifecycle-Methods)
    1. [Why Lifecycle Methods](#Why-Lifecycle-Methods)
    1. [Alternate State Initialization](#Alternate-State-Initialization)
    1. [Passing State as Props](#Passing-State-as-Props)
    1. [Showing Icons](#Showing-Icons)
    1. [Specifying Default Props](#Specifying-Default-Props)
    1. [Avoid Conditionals in Render](#Avoid-Conditionals-in-Render)
    1. [Breather and Review](#Breather-and-Review)
1. [Handling User Input with Forms and Events](#Handling-User-Input-with-Forms-and-Events) 
    1. [App Overview](#App-Overview)
    1. [Component Design](#Component-Design)
    1. [Adding Some Project Structure](#Adding-Some-Project-Structure)
    1. [Showing Forms to the User](#Showing-Forms-to-the-User)
    1. [Creating Event Handlers](#Creating-Event-Handlers)
    1. [Uncontrolled vs Controlled Elements](#Uncontrolled-vs-Controlled-Elements)
    1. [More on Controlled Elements](#More-on-Controlled-Elements)
    1. [Handling Form Submittal](#Handling-Form-Submittal)
    1. [Understanding 'this' in JavaScript](#Understanding-'this'-in-JavaScript)
    1. [Solving Context Issues](#Solving-Context-Issues)
    1. [Communicating Child to Parent](#Communicating-Child-to-Parent)
    1. [Invoking Callbacks in Children](#Invoking-Callbacks-in-Children)
1. [Making API Requests with React](#Making-API-Requests-with-React) 
    1. [Fetching Data](#Fetching-Data)
    1. [Axios vs Fetch](#Axios-vs-Fetch)
    1. [Viewing Request Results](#Viewing-Request-Results)
    1. [Handling Requests with Async Await](#Handling-Requests-with-Async-Await)
    1. [Setting State After Async Requests](#Setting-State-After-Async-Requests)
    1. [Creating Custom Clients](#Creating-Custom-Clients)
1. [Building Lists of Records](#Building-Lists-of-Records) 
    1. [Rendering Lists](#Rendering-Lists)
    1. [Review of Map Statements](#Review-of-Map-Statements)
    1. [Rendering Lists of Components](#Rendering-Lists-of-Components)
    1. [The Purpose of Keys in Lists](#The-Purpose-of-Keys-in-Lists)
    1. [Implementing Keys in Lists](#Implementing-Keys-in-Lists)
1. [Using Ref's for DOM Access](#Using-Ref's-for-DOM-Access)
    1. [Grid CSS](#Grid-CSS)
    1. [Issues with Grid CSS](#Issues-with-Grid-CSS)
    1. [Creating an Image Card Component](#Creating-an-Image-Card-Component)
    1. [Accessing the DOM with Refs](#Accessing-the-DOM-with-Refs)
    1. [Accessing Image Height](#Accessing-Image-Height)
    1. [Callbacks on Image Load](#Callbacks-on-Image-Load)
    1. [Dynamic Spans](#Dynamic-Spans)
    1. [App Review](#App-Review)
1. [Let's Test Your React Mastery!](#Let's-Test-Your-React-Mastery!)
    1. [Component Design](#Component-Design)
    1. [Scaffolding the App](#Scaffolding-the-App)
    1. [Reminder on Event Handlers](#Reminder-on-Event-Handlers)
    1. [Handling Form Submittal](#Handling-Form-Submittal)
    1. [Searching for Videos](#Searching-for-Videos)
    1. [Putting All Together](#Putting-All-Together)
    1. [Updating State with Fetched Data](#Updating-State-with-Fetched-Data)
    1. [Passing State as Props](#Passing-State-as-Props)
    1. [Rendering a List of Videos](#Rendering-a-List-of-Videos)
    1. [Rendering Video Thumbnails](#Rendering-Video-Thumbnails)
    1. [Styling a List](#Styling-a-List)
    1. [Communicating from Child to Parent](#Communicating-from-Child-to-Parent)
    1. [Deeply Nested Callbacks](#Deeply-Nested-Callbacks)
    1. [Conditional Rendering](#Conditional-Rendering)
    1. [Styling the VideoDetail](#Styling-the-VideoDetail)
    1. [Displaying a Video Player](#Displaying-a-Video-Player)
    1. [Fixing a Few Warnings](#Fixing-a-Few-Warnings)
    1. [Default Video Selection](#Default-Video-Selection)
1. [Understanding Hooks in React](#Understanding-Hooks-in-React)
    1. [React Hooks](#React-Hooks)
    1. [App Architecture ](#App-Architecture)
    1. [Communicating the Items Prop](#Communicating-the-Items-Prop)
    1. [Building and Styling the Accordion](#Building-and-Styling-the-Accordion)
    1. [Helper Functinos in Function Components](#Helper-Functinos-in-Function-Components)
    1. [Introducing useState](#Introducing-useState)
    1. [Understanding useState](#Understanding-useState)
    1. [Setter Functions](#Setter-Functions)
    1. [Expanding the Accordion](#Expanding-the-Accordion)
    1. [Creating Additional Widgets](#Creating-Additional-Widgets)
    1. [The Search Widget Architecture](#The-Search-Widget-Architecture)
    1. [Scaffolding the Widget](#Scaffolding-the-Widget)
    1. [Text Inputs with Hooks](#Text-Inputs-with-Hooks)
    1. [When do we Search?](#When-do-we-Search?)
    1. [The useEffect Hook](#The-useEffect-Hook)
    1. [Testing Execution](#Testing-Execution)
    1. [Async Code in useEffect](#Async-Code-in-useEffect)
    1. [Executing the Request from useEffect](#Executing-the-Request-from-useEffect)
    1. [Default Search Terms](#Default-Search-Terms)
    1. [List Building](#List-Building)
    1. [XSS Attacks in React](#XSS-Attacks-in-React)
    1. [XSS Server Code](#XSS-Server-Code)
    1. [Linking to a Wikipedia Page](#Linking-to-a-Wikipedia-Page)
    1. [Only Search with a Term](#Only-Search-with-a-Term)
    1. [Throttling API Requests](#Throttling-API-Requests)
    1. [Reminder on setTimeout](#Reminder-on-setTimeout)
    1. [useEffect's Cleanup Function](#useEffect's-Cleanup-Function)
    1. [Implementing a Delayed Request](#Implementing-a-Delayed-Request)
    1. [Searching on Initial Render](#Searching-on-Initial-Render)
    1. [Edge Case When Clearing Out Input Form](#Edge-Case-When-Clearing-Out-Input-Form)
    1. [Optional Video - Fixing a Warning](#Optional-Video---Fixing-a-Warning)
    1. [Dropdown Architecture](#Dropdown-Architecture)
    1. [Scaffolding the Dropdown](#Scaffolding-the-Dropdown)
    1. [A Lot of JSX](#A-Lot-of-JSX)
    1. [Selection State](#Selection-State)
    1. [Filtering the Option List](#Filtering-the-Option-List)
    1. [Hiding and Showing the Option List](#Hiding-and-Showing-the-Option-List)
    1. [Err... Why is this Hard?](#Err...-Why-is-this-Hard?)
    1. [Reminder on Event Bubbling](#Reminder-on-Event-Bubbling)
    1. [Applying What We've Learned](#Applying-What-We've-Learned)
    1. [Binding an Event Handler](#Binding-an-Event-Handler)
    1. [Why Stay Open](#Why-Stay-Open)
    1. [Which Element Was Clicked?](#Which-Element-Was-Clicked?)
    1. [Making use of useRef](#Making-use-of-useRef)
    1. [Body Event Listener Cleanup](#Body-Event-Listener-Cleanup)
    1. [The Translate Widget](#The-Translate-Widget)
    1. [Scaffolding the Translate Component](#Scaffolding-the-Translate-Component)
    1. [Adding the Language Input](#Adding-the-Language-Input)
    1. [Understanding the Convert Component](#Understanding-the-Convert-Component)
    1. [Google Translate API Key](#Google-Translate-API-Key)
    1. [Building the Convert Component](#Building-the-Convert-Component)
    1. [Using the Google Translate API](#Using-the-Google-Translate-API)
    1. [Displaying Translated Text](#Displaying-Translated-Text)
    1. [Debouncing Translation Updates](#Debouncing-Translation-Updates)
    1. [Reviewing useState and useEffect](#Reviewing-useState-and-useEffect)
1. [Navigation From Scratch](#Navigation-From-Scratch)
    1. [Navigation in React](#Navigation-in-React)
    1. [Basic Component Routing](#Basic-Component-Routing)
    1. [Building a Reusable Route Component](#Building-a-Reusable-Route-Component)
    1. [Implementing a Header for Navigation](#Implementing-a-Header-for-Navigation)
    1. [Handling Navigation](#Handling-Navigation)
    1. [Building a Link](#Building-a-Link)
    1. [Changing the URL](#Changing-the-URL)
    1. [Detecting Navigation](#Detecting-Navigation)
    1. [Updating the Route](#Updating-the-Route)
    1. [Handling Command Clicks](#Handling-Command-Clicks)
1. [Hooks in Practice](#Hooks-in-Practice)
    1. [Project Overview](#Project-Overview)
    1. [Refactoring the SearchBar](#Refactoring-the-SearchBar)
    1. [Refactoring the App](#Refactoring-the-App)
    1. [Removing a Callback](#Removing-a-Callback)
    1. [Overview on Custom Hooks](#Overview-on-Custom-Hooks)
    1. [Process for Building Custom Hooks](#Process-for-Building-Custom-Hooks)
    1. [Extracting Video Logic](#Extracting-Video-Logic)
    1. [Using the Custom Hook](#Using-the-Custom-Hook)
1. [Deploying a React App](#Deploying-a-React-App)
    1. [Deployment Overview](#Deployment-Overview)
    1. [Deployment with Vercel](#Deployment-with-Vercel)
    1. [Deployment with Netlify](#Deployment-with-Netlify)
1. [On We Go...To Redux!](#On-We-GoTo-Redux!)
    1. [Introduction to Redux](#Introduction-to-Redux)
    1. [Redux by Analogy](#Redux-by-Analogy)
    1. [A Bit More Analogy](#A-Bit-More-Analogy)
    1. [Finishing the Analogy](#Finishing-the-Analogy)
    1. [Mapping the Analogy to Redux](#Mapping-the-Analogy-to-Redux)
    1. [Modeling with Redux](#Modeling-with-Redux)
    1. [Creating Reducers](#Creating-Reducers)
    1. [Rules of Reducers](#Rules-of-Reducers)
    1. [Testing Our Example](#Testing-Our-Example)
    1. [Important Redux Notes](#Important-Redux-Notes)
1. [Integrating React with Redux](#Integrating-React-with-Redux) 
    1. [React Cooperating with Redux](#React-Cooperating-with-Redux)
    1. [React, Redux, and React-Redux](#React,-Redux,-and-React-Redux)
    1. [Design of the Redux App](#Design-of-the-Redux-App)
    1. [How React-Redux Works](#How-React-Redux-Works)
    1. [Redux Project Structure](#Redux-Project-Structure)
    1. [Named vs Default Exports](#Named-vs-Default-Exports)
    1. [Building Reducers](#Building-Reducers)
    1. [Wiring Up the Provider](#Wiring-Up-the-Provider)
    1. [The Connect Function](#The-Connect-Function)
    1. [Configuring Connect with MapStateToProps](#Configuring-Connect-with-MapStateToProps)
    1. [Building a List with Redux Data ](#Building-a-List-with-Redux-Data)
    1. [Calling Action Creators from Components](#Calling-Action-Creators-from-Components)
    1. [Redux is Not Magic](#Redux-is-Not-Magic)
    1. [Functional Components with Connect](#Functional-Components-with-Connect)
    1. [Conditional Rendering](#Conditional-Rendering)
1. [Async Actions with Redux Thunk](#Async-Actions-with-Redux-Thunk)
    1. [App Overview and Goals](#App-Overview-and-Goals)
    1. [Initial App Setup](#Initial-App-Setup)
    1. [Tricking Redux with Dummy Reducers](#Tricking-Redux-with-Dummy-Reducers)
    1. [A Touch More Setup](#A-Touch-More-Setup)
    1. [How to Fetch Data in a Redux App](#How-to-Fetch-Data-in-a-Redux-App)
    1. [Wiring Up an Action Creator](#Wiring-Up-an-Action-Creator)
    1. [Making a Request From an Action Creator](#Making-a-Request-From-an-Action-Creator)
    1. [Understanding Async Action Creators](#Understanding-Async-Action-Creators)
    1. [More on Async Action Creators](#More-on-Async-Action-Creators)
    1. [Middlewares in Redux](#Middlewares-in-Redux)
    1. [Behind the Scenes of Redux Thunk](#Behind-the-Scenes-of-Redux-Thunk)
    1. [Shortened Syntax with Redux Thunk](#Shortened-Syntax-with-Redux-Thunk)
1. [Redux Store Design](#Redux-Store-Design)
    1. [Rules of Reducers](#Rules-of-Reducers)
    1. [Return Values from Reducers](#Return-Values-from-Reducers)
    1. [Argument Values](#Argument-Values)
    1. [Pure Reducers](#Pure-Reducers)
    1. [Mutations in JavaScript](#Mutations-in-JavaScript)
    1. [Equality of Arrays and Objects](#Equality-of-Arrays-and-Objects)
    1. [A Misleading Rule](#A-Misleading-Rule)
    1. [Safe State Updates in Reducers](#Safe-State-Updates-in-Reducers)
    1. [Switch Statements in Reducers](#Switch-Statements-in-Reducers)
    1. [Dispatching Correct Values](#Dispatching-Correct-Values)
    1. [List Building](#List-Building)
    1. [Displaying Users](#Displaying-Users)
    1. [Fetching Singular Records](#Fetching-Singular-Records)
    1. [Displaying the User Header](#Displaying-the-User-Header)
    1. [Finding Relevant Users](#Finding-Relevant-Users)
    1. [Extracting Logic to MapStateToProps](#Extracting-Logic-to-MapStateToProps)
    1. [That's the Issue](#That's-the-Issue)
    1. [Memoizing Functions](#Memoizing-Functions)
    1. [Memoization Issues](#Memoization-Issues)
    1. [One Time Memoization](#One-Time-Memoization)
    1. [Alternate Overfecthing Solution](#Alternate-Overfecthing-Solution)
    1. [Action Creators in Action Creators](#Action-Creators-in-Action-Creators)
    1. [Finding Unique User Ids](#Finding-Unique-User-Ids)
    1. [Quick Refactor with Chain](#Quick-Refactor-with-Chain)
    1. [App Wrapup](#App-Wrapup)
1. [Navigation with React Router](#Navigation-with-React-Router)
    1. [App Outline](#App-Outline)
    1. [Mockups in Details](#Mockups-in-Details)
    1. [App Challenges](#App-Challenges)
    1. [Inital Setup](#Inital-Setup)
    1. [Introducing React Router](#Introducing-React-Router)
    1. [How React Router Works](#How-React-Router-Works)
    1. [How Paths Get Matched](#How-Paths-Get-Matched)
    1. [How to "Not" Navigate with React Router](#How-to-"Not"-Navigate-with-React-Router)
    1. [Navigating with React Router](#Navigating-with-React-Router)
    1. [Different Router Types](#Different-Router-Types)
    1. [Component Scaffolding](#Component-Scaffolding)
    1. [Wiring Up Routes](#Wiring-Up-Routes)
    1. [Always Visible Components](#Always-Visible-Components)
    1. [Connecting the Header](#Connecting-the-Header)
    1. [Links Inside Routers](#Links-Inside-Routers)
1. [Handling Authenitcation with React](#Handling-Authenitcation-with-React)
    1. [OAuth-Based Authentication](#OAuth-Based-Authentication)
    1. [OAuth for Servers vs Browser Apps](#OAuth-for-Servers-vs-Browser-Apps)
    1. [Creating OAuth Credentials](#Creating-OAuth-Credentials)
    1. [Wiring Up the Google API Library](#Wiring-Up-the-Google-API-Library)
    1. [Sending a User Into the OAuth Flow](#Sending-a-User-Into-the-OAuth-Flow)
    1. [Rendering Authentication Status](#Rendering-Authentication-Status)
    1. [Updating Auth State](#Updating-Auth-State)
    1. [Displaying Sign in and Sign Out](#Displaying-Sign-in-and-Sign-Out)
    1. [On-Demand Sign in and Sign Out](#On-Demand-Sign-in-and-Sign-Out)
    1. [Redux Architecture Design](#Redux-Architecture-Design)
    1. [Redux Setup](#Redux-Setup)
    1. [Connecting Auth with Action Creators](#Connecting-Auth-with-Action-Creators)
    1. [Building the Auth Reducer](#Building-the-Auth-Reducer)
    1. [Handling Auth Status Through Redux](#Handling-Auth-Status-Through-Redux)
    1. [Fixed Action Types](#Fixed-Action-Types)
    1. [Recording the User's ID](#Recording-the-User's-ID)
1. [Reducx Dev Tools](#Reducx-Dev-Tools)
    1. [Using Redux Dev Tools to Inspect the Store](#Using-Redux-Dev-Tools-to-Inspect-the-Store)
    1. [Debug Sessions with Redux Dev Tools](#Debug-Sessions-with-Redux-Dev-Tools)
1. [Handling Forms with Redux Form](#Handling-Forms-with-Redux-Form)
    1. [Forms with Redux Form](#Forms-with-Redux-Form)
    1. [Useful Redux Form Examples](#Useful-Redux-Form-Examples)
    1. [Conencting Reux Form](#Conencting-Reux-Form)
    1. [Creating Forms](#Creating-Forms)
    1. [Automatically Handling Events](#Automatically-Handling-Events)
    1. [Customizing Form Fields](#Customizing-Form-Fields)
    1. [Handling Form Submission](#Handling-Form-Submission)
    1. [Validation of Form Inputs](#Validation-of-Form-Inputs)
    1. [Displaying Validation Messages](#Displaying-Validation-Messages)
    1. [Showing Errors on Touch](#Showing-Errors-on-Touch)
    1. [Highlighting Errored Fields](#Highlighting-Errored-Fields)
1. [REST-based React Apps](#REST-based-React-Apps)
    1. [Creating Streams ](#Creating-Streams)
    1. [REST-ful Conventions](#REST-ful-Conventions)
    1. [Setting Up an API Server](#Setting-Up-an-API-Server)
    1. [Creating Streams Through Action Creators](#Creating-Streams-Through-Action-Creators)
    1. [Creating a Stream with REST Conventions](#Creating-a-Stream-with-REST-Conventions)
    1. [Dispatching Actions After Stream Creation](#Dispatching-Actions-After-Stream-Creation)
    1. [Bulk Action Creators](#Bulk-Action-Creators)
    1. [Object-Based Reducers](#Object-Based-Reducers)
    1. [Key Interpolation Syntax](#Key-Interpolation-Syntax)
    1. [Handling Fetching, Creating, and Updating](#Handling-Fetching,-Creating,-and-Updating)
    1. [Deleting Properties with Omit](#Deleting-Properties-with-Omit)
    1. [Merging Lists of Records](#Merging-Lists-of-Records)
    1. [Fetching a List of All Streams](#Fetching-a-List-of-All-Streams)
    1. [Rendering All Streams](#Rendering-All-Streams)
    1. [Associating Streams with Users](#Associating-Streams-with-Users)
    1. [Conditionally Showing Edit and Delete](#Conditionally-Showing-Edit-and-Delete)
    1. [Linking to Stream Creation](#Linking-to-Stream-Creation)
    1. [When to Navigate Users](#When-to-Navigate-Users)
    1. [History Reference](#History-Reference)
    1. [Creating a Browser History Object](#Creating-a-Browser-History-Object)
    1. [Implementing Programmatic Navigation](#Implementing-Programmatic-Navigation)
    1. [Manually Changing API Records](#Manually-Changing-API-Records)
    1. [URL-Based Selection](#URL-Based-Selection)
    1. [Wildcard Navigation](#Wildcard-Navigation)
    1. [More on Route Params](#More-on-Route-Params)
    1. [Selecting Records from State](#Selecting-Records-from-State)
    1. [Component Isolation with React Router](#Component-Isolation-with-React-Router)
    1. [Fetching a Stream for Edit Stream](#Fetching-a-Stream-for-Edit-Stream)
    1. [Real Code Reuse](#Real-Code-Reuse)
    1. [Refactoring Stream Creation](#Refactoring-Stream-Creation)
    1. [Setting Initial Values](#Setting-Initial-Values)
    1. [Avoiding Changes to Properties](#Avoiding-Changes-to-Properties)
    1. [Edit Form Submission](#Edit-Form-Submission)
    1. [PUT vs PATCH Requests](#PUT-vs-PATCH-Requests)
1. [Using React Portals](#Using-React-Portals) 
1. [Implementing Streaming Video](#Implementing-Streaming-Video) 
1. [The Context System with React](#The-Context-System-with-React) 
1. [Replacing Redux with Context](#Replacing-Redux-with-Context) 
1. [Working with Older Versions of React](#Working-with-Older-Versions-of-React) 
1. [Ajax Requets with React ](#Ajax-Requets-with-React) 
1. [Modeling Application State](#Modeling-Application-State) 
1. [Managing App State with Redux](#Managing-App-State-with-Redux) 
1. [Intermediate Redux: Middleware](#Intermediate-Redux:-Middleware) 
1. [React Router + Redux Form v6](#React-Router-+-Redux-Form-v6) 
1. [Bonus Topics](#Bonus-Topics) 
1. [React Router + Redux Form v4](#React-Router-+-Redux-Form-v4) 
1. [Extras](#Extras) 
---
# Let's Dive In!
## Our First App
1. We imported several objects from the other JavaScript file. We can check the [demo](https://codesandbox.io/s/react-jg4cq)
    ```js
    import "./styles.css";
    import React, { useState } from "react";
    import Field from "./components/field";
    import Languages from "./components/languages";
    import Translate from "./components/translate";

    export default function App() {
        const [language, setLanguage] = useState("zh-CN");
        const [text, setText] = useState("");

        return (
            <div>
            <Field label="Enter English" onChange={setText} value={text} />
            <Languages language={language} onLanguageChange={setLanguage} />
            <hr />
            <Translate text={text} language={language} />
            </div>
        );
    }
    ```
    <img src="./images/firstReactAppDemo.gif">

## Critical Questions
1. What was the 'App' function? 
    1. The `App` function in the previous is a `React Component`. The `App Component` produces JSX and handles user events.
    1. `JSX` is a set of instructions to tell React what content we want to show on the screen.
    1. We can use JSX elements to tell React to create a normal HTML element or show another component that has been created. 
    1. `JSX` will go through each of the elements in the code to check if it is a DOM element. If there's a DOM element, it shows on the screen. If the entity is not a DOM element, it will call the component function and inspect all the JSX.
1. How did some content get displayed on the screen?
    1. The first step is that the browser make a request to the host for the `index.html`.
    1. In the `index.html`, there's more script that will request another `bundle.js` which is bundled from `index.js`, `app.js`, and `react.js`. 
    1. Therefore, we get `index.html` and `bundle.js` from 2 requests. 
    <img src="./images/reactAppFiles.png">    
    1. In this case, the browser will firstly get `index.html` from the `public` folder which will make another requst for the script `index.js`.
        ```js
        // index.js 
        import React from "react";
        import ReactDOM from "react-dom";
        import App from "./App";

        ReactDOM.render(
            <App />, 
            document.getElementById("root")
        );
        ```
    1. Checking from the code, we can find the first statement in `ReactDOM.render()` is `<App />` which is to check the `App` function in `App.js`, get back `JSX` and turn it into HTML.
    1. Then `ReactDOM.render()` will take the HTML created by `JSX` and put it into the element selected by `document.getElementById("root")`.
1. What's the difference between React and ReactDOM?
    1. When working with React, we are working with 2 separate libraries. `React` and `ReactDOM`. 
    1. `React` knows how to work with components and is called a `reconciler`.
    1. `ReactDOM` knows how to work with take instructions on what we want to show and turn it into HTML and is called a `renderer`. It works as to take the HTML elements rendered by JSX to show on the screen.
1. What was all the '`useState`' stuff?
    1. `useState` is a function for users to work with React's `state` system. 
    1. State system is used to manage data and track data that changes over time.
    1. State system can be used to update the HTML on the screen.    

## Generating a React Project
1. After installing `NodeJS`, we can use `npm install -g create-react-app` to install the npm package to install `create-react-app` which is used to generate react projects. 
1. We then can use `create-react-app project_name` to create a react project at current directory.
1. `npx create-react-app project_name` is an alternative way to generate and start a react project.
1. This command will install all the required packages to work on a react project.
1. Note that since some update in year 2020, the method to install react with `create-react-app` locally has made some new generated project issues. Therefore, it's recommended to use `npx create-react-app project_name` to generate new react app.

## Why Create React App?
1. The main topic introduced here is `Babel` which can take any version of JavaScript such as ES2015, ES2016, and so on to turn them into ES5 which is the version that mostly all the browser support.

## Exploring a create-react-app project
1. By default, several files and folders are generated when creating a react project. 
1. `src` is the folder where we put all the source code we write.
1. `public` is the folder that stores static files like images.
1. `node_modules` is the folder that contains all of our project dependencies.
1. `package.json` records the project dependencies.
1. `package-lock.json` records the exact version of packages that we install.
1. `README.md` has the instructions on how to use this project. 

## Starting and Stopping a React App
1. After creating the new project, we can `cd` into the directory and use `npm start` to start the developing server and start development. The testing server will create the app at `localhost` at port `3000`.

## JavaScript Module Systems
1. In React, the code is separated in different JavaScript files and each of the won't affect to each other. 
1. By developing the React App, we use JavaScript module system which syntax is `imoprt React from 'react'`
    1. `import` is the key word to indicate that we want to get code from some other file or dependency.
    1. `React` is the variable we want to assign this import to. We can use the name arbitrarily. However, we should try to follow the convention to name the variable.
    1. `from` is a keyword that used in the syntax.
    1. `'react'` is the name of the dependency or path to the file we are importing.
1. When `import` from a file, this statement is to ask JavaScript to find the desirable module from `node_module` directories. In this case, we want to use the code in `react` and `react-dom`. 
1. There are 2 ways to import code from different JavaScript files. One is using `import` which is "ES2015 Modules system, while `require` is from "CommonJS Modules" which is a different module system. 
    ```js
    import React from 'react';
    import ReactDOM from 'react-dom';
    ```

## Displaying Content with Functional Components
1. A component is a "Function" or "Class" that produces HTML to show the user using "JSX" and handles feedback from the user using "Event Handlers".
1. After creating the JSX component, we use `ReactDOM` with `.render()` method to give the component and render it on the `index.html`. Note that in the HTML template, we have a HTML element `<div id="root"></div>` that will be used to render the React App. 
    ```js
    // import the React and ReactDOM libraries
    import React from 'react';
    import ReactDOM from 'react-dom';

    // Create a react component
    const App = () => {
        return <div>Hi there!</div>;
    }

    // Take the react component and show it on the screen
    ReactDOM.render(
        <App />,
        document.querySelector('#root')
    );
    ```



# Building Content with JSX
## What is JSX
1. In React, we use `Babel` to tranform ES2015 or more modern JavaScript code into ES5 to ensure all the browser can run the JavaScript. 
1. `Babel` can not only translate modern JavaScript code but also JSX code to work as JavaScript DOM.

## Convert HTML to JSX
1. JSX is special dialect of JS (which is not HTML).
1. Browser don't understand JSX code. We write JSX then run tools to turn it into normal JS.
1. JSX is very similar in form and function to HTML with a couple differences.
1. In convention, we can put parenthesis to wrap the HTML in after the `return` keyword in `App` function. 
1. However, in the following case, the code doesn't work and can't be rendered on React App.
    ```js
    // import the React and ReactDOM libraries
    import React from 'react';
    import ReactDOM from 'react-dom';

    // Create a react component
    const App = () => {
        return (
            <div>
                <label class="label" for="name">Enter name:</label>
                <input id="name" type="text"/>
                    <button style="background-color: blue; color: white;">Submit</button>
            </div>
        );
    };

    // Take the react component and show it on the screen
    ReactDOM.render(
                <App />,
        document.querySelector('#root')
    );
    ```

## Inline Styling with JSX
1. In JSX, we can't use regular inline styling syntax to decorate HTML elements.
1. In the naming convention in JSX, any properties that has dash `-` as delimeter between strings shall be converted into camel case. For example we turn `background-color` into `backgroundColor`.
    ```html
    <!-- html -->
    <div style="background-color:red;"></div>
    ```
    ```js
    <div style={{backgroundColor:'red'}}></div>
    ```

## Converting Styling to JSX Format
## Class vs ClassName
## Referencing JS variable in JSX
1. The value of the property should be single-quoted and be put as JavaScript object. While single-line properties such as `class` and `for`, we can use double quotes to wrap them.
1. The custom styling syntax to an element are different in JSX and HTML.
1. JSX uses different syntax to add a class to an element.
1. JSX can reference JS variables.
1. In JSX, we use `className` for `class` property in HTML. The main reason is that `class` is a reserved keyword in JavaScript to create classes for OOP.
1. We can easily insert a JavaScript variable in JSX by wrapping the JavaScript variable with curly braces `{}`. Note that this JavaScript variable reference has its limitation for certain data type or returned data value from the function.
    ```js
    // import the React and ReactDOM libraries
    import React from 'react';
    import ReactDOM from 'react-dom';

    function getButtonText() {
        return 'Click Me!';
    }
    // Create a react component
    const App = () => {
        const labelName = 'Click Me!';
        return (
            <div>
                <label className="label" for="name"> // use className rather than class in JSX
                    {labelName} // use curly braces to wrap JavaScript variable 
                </label>
                <input id="name" type="text" />
                <button style={{ backgroundColor: 'blue', color: 'white'}}> // use JavaScript object and change css property to camelCase
                    {getButtonText()} // use curly braces to wrap JavaScript function
                </button>
            </div>
        );
    };

    // Take the react component and show it on the screen
    ReactDOM.render(
        <App />,
        document.querySelector('#root')
    );
    ```

## Values JSX Can't Show
## Finding Forbidden Property Names
1. The JavaScript variable reference can take `Number` and `String` or an `Array` that has `Number` or `String` as its elements.
1. The elements in the array will be concatenated 
1. However, regular `Objects` are not available to be used as React child. However, if the value of a property in an object is string or number type of value, we can refer it in JSX directly. 
1. `for` is also a reserved JavaScript keyword which is used in `for loop`. Therefore, in the following case, we can specify the `for` attribute for `label` element in HTML as `htmlFor` to prevent warnning message from React. 
    ```js
    const App = () => {
        const buttonText = {text: 'Click Me'};
        const style = {backgroundColor: 'blue', color: 'white'};
        const labelText = 'Enter name:';

        return (
            <div>
                <label className="label" for="name">
                    {labelText}
                </label>
                <input id="name" type="text"/>
                <button style={style}>
                    {buttonText.text}
                </button>
            </div>
        );
    };
    ```



# Communicating with Props
## Three Tenets of Components
1. Component Nesting - A component can be shown in side of another
1. Component Reusability - We want to make components that can be easily reused through out application.
1. Component Configuration - We should be able to configure a component when it is created. 

## Application Overview
1. We are going to create a React component which has user profile, user name, date and time, and user comment.
1. We will use `semantic` UI CDN, which is a CSS library similar to Bootstrap. We can use the cdn at [<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.css">](<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.css">).
1. In this case, we create a new react project `components` with `npx create-react-app components`.

## Getting Some Free Styling
1. After creating the new react project, we remove all the files in `src` directory to get a clean start. 
1. We then create `index.js` in `src` directory.
1. In this case, we use the [comment](https://semantic-ui.com/views/comment.html) styling from semantic UI.

## Naive Component Approach
1. In the JSX, we use the follow HTML elements with semantic UI css to style it. 
    ```js
    <div className="comment">
        <a href="/" className="avatar">
            <img alt="avatar" />
        </a>
        <div className="content">
            <a href="/" className="author">
                Sam
            </a>
            <div class="metadata">
                <span className="date">Today at 6:00PM</span>
            </div>
            <div className="text">Nice blog post!</div>
        </div>
    </div>
    ```

## Specifying Images in JSX
1. In this case, we use a npm package `faker` which can provide mock up contents, data, and images. We can use `npm i faker --save` in the project directory.
    ```js
    import faker from 'faker';
    const App = () => {
        return (
            <img alt="avatar" src={faker.image.image()} />
        );
    }
    ```

## Duplicating a Single Component
## Extracting JSX to New Components
1. From the previous case, if we'd like to duplicate the same components from the page, we can only copy the HTML elements to be rendered in JSX, which can be very confusing when the project goes larger. This is why we'd like to use reusable components.
1. To create a reusable, configurable component, we can 
    1. Identify the JSX taht appears to be duplicated.
    ```js
    <div className="comment">
        <a href="/" className="avatar">
            <img alt="avatar" src={faker.image.image()} />
        </a>
        <div className="content">
            <a href="/" className="author">
                Sam
            </a>
            <div class="metadata">
                <span className="date">Today at 6:00PM</span>
            </div>
            <div className="text">Nice blog post!</div>
        </div>
    </div>
    ```
    1. What is the purpose of that block of JSX? Think of a descriptive name for what it does.    
    1. Create a new file to house this new component - it should have the same name as the component. In convention, we can capitalize the first letter of each term of the name. 
    1. Create a new component in the new file, paste the JSX into it.
    1. Make the new component configurable by using React's "props" system.
    ```js
    // CommentDetail.js
    import React from 'react';

    const CommentDetail = () => {
        return (
            <div className="comment">
                <a href="/" className="avatar">
                    <img alt="avatar" src={faker.image.image()} />
                </a>
                <div className="content">
                    <a href="/" className="author">
                        Sam
                    </a>
                    <div class="metadata">
                        <span className="date">Today at 6:00PM</span>
                    </div>
                    <div className="text">Nice blog post!</div>
                </div>
            </div>
        );
    };
    ```

## Component Nesting
1. To use the component, we need to `export` to component from the JavaScript file
    ```js
    // CommentDetail.js
    export default CommentDetail;
    ```
1. In the main `index.js` file, we can import the component with relative path.
1. To use the component we can use it as HTML element in JSX directly. Note that we don't use curly braces to render them as regular JavaScript functions. 
1. In this case, the components and contents of it are still static from hard code.
1. After the structure and layout is settled, we can start working on "props" system.
    ```js
    // index.js
    import React from 'react';
    import ReactDOM from 'react-dom';
    import CommentDetail from './CommentDetail';

    const App = () => {
        return (
            <CommentDetail />
            <CommentDetail />
            <CommentDetail />
        );
    };
    ```

## React's Props System
1. `Props` is the system for passing data from a "parent" component to a "child" compponent.
1. The goal is to customize or configure a child component.
1. In this case, each "comment" component has variables as `name`, `time`, `content` of comment.
1. "Props" stands for properties.

## Passing and Receiving Props
1. We can pass the data or value for the variable through the parent component to child component.
1. The parent component are those in `index.js`. In this case, we give each `CommentDetail` component with `author` attribute.
    ```js
    // index.js
    import React from 'react';
    import ReactDOM from 'react-dom';
    import CommentDetail from './CommentDetail';

    const App = () => {
        return (
            <div className="ui container comments">
                <CommentDetail author="Sam" />
                <CommentDetail author="Alex" />
                <CommentDetail author="Jane" />
            </div>
        );
    };

    ReactDOM.render(<App />, document.querySelector('#root'));
    ```
1. If we check in the component JS file, we can give component function a argument, such as `props` and check what data is in the object.
    ```js
    // CommentDetail
    const CommentDetail = (props) => {
        console.log(props);
        return (
            <div className="comment">
                <a href="/" className="avatar">
                    <img alt="avatar" src={faker.image.image()} />
                </a>
                <div className="content">
                    <a href="/" className="author">
                        {props.author} // take data given from the parent component 
                    </a>
                    <div className="metadata">
                        <span className="date">Today at 6:00PM</span>
                    </div>
                    <div className="text">Nice blog post!</div>
                </div>
            </div>
        );
    };
    ```

## Passing Multiple Props
1. In the last section, we pass autor name of each user who left a comment on the page. 
1. We'd like to pass other variables to the component. We can reformat the component into multiple lines.
    ```js
    // CommentDetail
    const CommentDetail = (props) => {
        console.log(props);
        return (
            <div className="comment">
                <a href="/" className="avatar">
                    <img alt="avatar" src={props.avatar} />
                </a>
                <div className="content">
                    <a href="/" className="author">
                        {props.author}
                    </a>
                    <div className="metadata">
                        <span className="date">{props.timeAgo}</span>
                    </div>
                    <div className="text">{props.comment}</div>
                </div>
            </div>
        );
    };

    // index.js
    const App = () => {
        return (
            <div className="ui container comments">
                <CommentDetail 
                    author="Sam" 
                    timeAgo="Today at 4:45PM" 
                    avatar={faker.image.image()} 
                    comment={faker.lorem.slug()} 
                />
                <CommentDetail
                    author="Alex"
                    timeAgo="Today at 2:00AM"
                    avatar={faker.image.image()}
                    comment={faker.lorem.slug()}
                />
                <CommentDetail
                    author="Jane"
                    timeAgo="Yesterday at 5:00PM"
                    avatar={faker.image.image()}
                    comment={faker.lorem.slug()}
                />
            </div>
        );
    };
    ```

## Component Reuse
## Implementing an Approval Card
1. We'd like to add more features on the comment component. In this case, we'd like to add an "Approve" and "Reject".
1. We create a new file in the same directory. In this case, we create `ApprovalCard.js`. In this case, we refer to the [cards](https://semantic-ui.com/views/card.html) in Semantic UI.
    ```js
    // ApprovalCard 
    import React from 'react';

    const ApprovalCard = () => {
        return (
            <div className="ui card">
                <div className="content">Are you sure?</div>
                <div className="extra content">
                    <div className="ui two buttons">
                        <div className="ui basic green button">Approve</div>
                        <div className="ui basic red button">Reject</div>
                    </div>
                </div>
            </div>
        );
    };

    export default ApprovalCard;
    ```
1. We then can put the new component in `index.js` directly to use. However, we haven't know how to make the `CommentDetail` component as the child element in the `ApprovalCard`. In the current layout the 2 components are parallel to each other in the same tier. 
    ```js
    // index.js
    const App = () => {
        return (
            <div className="ui container comments">
                <ApprovalCard />
                <CommentDetail
                    author="Sam"
                    timeAgo="Today at 4:45PM"
                    avatar={faker.image.image()}
                    comment={faker.lorem.slug()}
                />
                <CommentDetail
                    author="Alex"
                    timeAgo="Today at 2:00AM"
                    avatar={faker.image.image()}
                    comment={faker.lorem.slug()}
                />
                <CommentDetail
                    author="Jane"
                    timeAgo="Yesterday at 5:00PM"
                    avatar={faker.image.image()}
                    comment={faker.lorem.slug()}
                />
            </div>
        );
    };
    ```

## Showing Custom Child
1. To create relationship between the components, we can use opening and closing tags as regular HTML element to wrap the child compnent.
    ```js
    // index.js
    <ApprovalCard>
        <CommentDetail
            author="Sam"
            timeAgo="Today at 4:45PM"
            avatar={faker.image.image()}
            comment={faker.lorem.slug()}
        />
    </ApprovalCard>
    ```
1. If we go to `ApprovalCard.js` and add an argument to the render function, we can find that the `CommentDetail` has now become a child property in the object.
1. Therefore, we can use JSX syntax to call the value from the property to have `CommentDetail` nested in the `ApprovalCard`. The property of the object is `children`. Note that if we don't call the `children` property in the parent component, the children won't show up.
    ```js
    const ApprovalCard = (props) => {
        console.log(props) // check the child object in the parent component
        return (
            <div className="ui card">
                <div className="content">{props.children}</div> // use the child object in the parent component
                <div className="extra content">
                    <div className="ui two buttons">
                        <div className="ui basic green button">Approve</div>
                        <div className="ui basic red button">Reject</div>
                    </div>
                </div>
            </div>
        );
    };
    ```
1. Besides putting other comopnent as child or to be nested, we can use the `ApprovalCard` component with regualr HTML elements. Note that in the child component, we must put and refer to the properties that send from parent component.
    ```js
    // index.js
    <ApprovalCard>
        <div>
            <h4>Warning!</h4>
            Are you sure you want to do this?
        </div>
    </ApprovalCard>

    // ApprovalCard
    ApprovalCard = (props) => {
        return (
            {props.children}
        );
    };
    ```

# Strucuturing Apps with Class-based Components
## Class-based Components
1. A component can be either a `Function` or `Class` that produces HTML to show the user (which is using JSX) and handles feedback from the user (which is using event handler).
1. React used to work as the followings
    1. Functional Components can product JSX to show content to the user
    1. Class Components can produce JSX to show content to the user
        1. Can use the "Lifecycle Method" system to run code at specific points in time.
        1. Can use the "State" system to update content on the screen.
    1. The main difference between `Function` and `Class` componenet is that the function one is more straight forward while the class one can access "lifecycle method system" and "state system".
    1. In the past, `Class` components have more features than `Function` components.
1. React is now working with `"Hook"` system, which makes `Function` components similar to `Class` components.
1. In this case, companies with "established projects" are using class-based components, while companies with "newer projects" may be using class-based or function-based components.
1. In this sense, we should learn both class-based and function-based components.

## Application Overview - Season Experiencing
1. This app requires
    1. Needs to get the users physical location
    1. Needs to determine the current month
    1. Need to change text and styling based on location and month

## Scaffoldingthe the App
1. For this project, we use semantic UI at [<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.css">](<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.css">).
1. The steps of building the app in 2 parts, `App` and `SeasonDisplay`.
    1. Has the code to determine `location` and `month`.
    1. Shows different text/icons based on props.
    ```js
    // index.js
    import React from 'react';
    import ReactDOM from 'react-dom';

    const App = () => {
        return <div>Hi there!</div>;
    };

    ReactDOM.render(
        <App />,
        document.querySelector('#root')
    );


    // SeasonDisplay
    import React from 'react';

    const SeasonDisplay = () => {
        return <div>Season Display</div>;
    };

    export default SeasonDisplay;
    ```

## Getting a Users Physical Location
1. We can use browser navigator API to fetch user's location under user permission.
1. `windows.navigator.geoloaction.getCurrentPosition` takes 2 function arguments which is to return the `coords` object with users latitude and longitude with other metadata and the other callback function for returning error message.
1. Therefore, we can check user's location or get the message to know that if the user deny for location access.
    ```js
    // index.js
    window.navigator.geolocation.getCurrentPosition(
        (position) => console.log(position),
        (err) => console.log(err)
    );
    ``` 

## Handling Async Operations with Functional Components
1. After getting the location of the user from the API, it is challenging to use function component to render the data from async operations on the screen.
1. When the app is working
    1. JS file loaded by browser
    1. App component get created
    1. We call geolocation service
    1. App returns JSX, gets rendered to page as HTML
    1. We get result of geolocation
1. In short, the page is rendered before we get the location data from the user. 

## Refactoring from Functional to Class Components
1. Rules of Class Components
    1. Must be JavaScript class
    1. Must extend (subclss) `React.Component`
    1. Must define a `render` method that returns some amount of JSX
    ```js
    import React from 'react';
    import ReactDOM from 'react-dom';

    class App extends React.Component {
        render() {
            window.navigator.geolocation.getCurrentPosition(
                (position) => console.log(position),
                (err) => console.log(err)
            );

            return <div>Latitude: </div>;
        }
    }

    ReactDOM.render(
        <App />,
        document.querySelector('#root')
    );
    ```



# State in React Components 
## The Rules of State
1. Rules of State
    1. Only useable with class component.
    1. You will confuse `props` with state.
    1. '`State`' is a JS object that contains data relevant to a component.
    1. Updating '`state`' on a component causes the component to (almost) instantly rerender.
    1. State must be initialized when a component is created. 
    1. State can only be updated using the function `setState`!
1. We should always remeber to update state of a component only through `setState` function.

## Initializing State Through Constructors
1. As learnt from the previous section, we know that the state of a react component must be initialized when it is created. Therefore, in JavaScript class, we can use `constructor` function which will be first initiated when an instance is created through the object. 
    ```js
    class App extends React.Component {
        constructor (props) {
            super(props);

            this.state = { lat: null };
        }

        render() {
            windows.navigator.geolocation.getCurrentPosition(
                position => console.log(position),
                err => console.log(err),
            );

            return <div>Latitude: </div>
        }
    }
    ```
1. In addition, a side note that we must declare a render method in `App` class, which is extended from `React.Component`. React will return an error if the method is not defined. 
1. Besides, `constructor (props) {super(props);}` is like ceremonial process which must be done for react. 
1. By initializing the state, we can firstly assign a default value. In this case, we'd like to have the "**latitude**" of the user. As we haven't got the data, we can give the inital value as `null`. 

## Updating State Properties
1. We then can put the `this.state.lat` to the JSX to allow it to be rendered on the screen. 
1. Note that at this point, there's nothing will be rendered because the `state.lat` is set to be `null` by default. This is the only time we will use direct assignment to assign a value to the state.
1. We should always remember that we should use `.setState` method to update the state only.
    ```js
    class App extends React.Component {
        constructor (props) {
            super(props);

            this.state = { lat: null };

            windows.navigator.geolocation.getCurrentPosition(
                position => {
                    // we update state only through .setState method
                    this.setState({ lat = position.coords.latitude });
                },
                err => console.log(err),
            );
        }

        render() {
            return <div>Latitude: { this.state.lat }</div> // provide the value according to state
        }
    }
    ```

## App Lifecycle Walkthrough
1. We can only use `this.state` property on `this` object. The state system doesn't work if we use other property other than `state`. 
1. Note that every time when `state` is updated, react will almost instantly rerender the component. 
1. When the react app is opened by browser
    1. JS file loaded by browser.
    1. Instance of App component is created.
    1. App component `constructor` function gets called.
    1. State object is created and assigned to the `this.state` property.
    1. We call geolocation service.
    1. React calls the components render method.
    1. App returns JSX, gets rendered to page as HTML.
    1. We get result of geolocation from the async request.
    1. We update our state object that contains data with a call to `this.setState`.
    1. React sees that we updated the state of a component.
    1. React calls our `render` method a second time. 
    1. Render method returns some (updated) JSX.
    1. React takes that JSX and updates contents on the screen.
1. An important take away is that the components are actually rendred twice in this case. 
1. In this case, the `state` is firstly assigned with `null`, so that there's nothing shown after "**Latitude**".
1. After we receive data from the geolocation API, the `state` is updated, so react created the view with the updated view with the same components again.

## Handling Error Gracefully
1. Though we may have multiple properties in the `state` object, we don't need to update all the properties when receiving the data.
1. Besides, when we change returned JSX component from single line to multiple line, we would easily forget to take the semi-column at the last off, which can be hard to identify for the compiling error. 
    ```js
    class App extends React.Component {
        constructor(props) {
            super(props);

            // assign a 2nd property on state object
            this.state = { lat: null, errorMessage: '' };

            window.navigator.geolocation.getCurrentPosition(
                (position) => {
                    this.setState({ lat: position.coords.latitude });
                    console.log(position);
                },
                (err) => {
                    this.setState({ errorMessage: err.message });
                    console.log(err);
                }
            );
        }

        // React says we have to define render
        render() {
            return (
                <div>
                    Latitude: {this.state.lat}
                    <br />
                    Error: {this.state.errorMessage}
                </div> // don't forget to take semi-column off at the last line when changing from single line to multiple line
            );
        }
    }
    ```

## Conditionally Rendering Content
1. In this app, we'd like to show different content on the screen in different conditions.
    1. If we have got the `latitude`, we can show `latitude`.
    1. If we have error message, we should show the error message.
    1. If we haven't had any change or update, we can show "loading...".
1. Though there's another way to render contents on the screen by conditions, we can simply use `if` statements to decide what to be shown according to the properties in the `state` object.
    ```js
    class App extends React.Component {
        constructor(props) {
            super(props);

            this.state = { lat: null, errorMessage: '' };

            window.navigator.geolocation.getCurrentPosition(
                (position) => {
                    this.setState({ lat: position.coords.latitude });
                    console.log(position);
                },
                (err) => {
                    this.setState({ errorMessage: err.message });
                    console.log(err);
                }
            );
        }

        // React says we have to define render
        render() {
            if (this.state.errorMessage && !this.state.lat) {
                return <div>Error: {this.state.errorMessage}</div>;
            }

            if (!this.state.errorMessage && this.state.lat) {
                return <div>Latitude: {this.state.lat}</div>;
            }

            return <div>Loading!</div>;
        }
    }
    ```



# Understanding Lifecycle Methods
## Introducing Lifecycle Methods
1. For the `App` class instance, we can give more methods other than `constructor` and `render`. We can have `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount`. 
1. Each of those methods will be called in the different stage of the lifecycle of a component. 
1. Besides, `render` will be called multiple times during the lifecycle to render the JSX w/n updated data and values.
1. Component Lifecycle
    1. `constructor`
    1. `render` (which makes content visible on the screen)
    1. `componentDidMount` (Sit and wait for updates)
    1. `componentDidUpdate` (Sit and wait until this component is not longer shown)
    1. `componentWillUnmount` 
    ```js
    class App extends React.Component {
        constructor(props) {
            // properties and states
        }

        componentDidMount() {
            console.log('My component was rendered to the screen');
        }

        componentDidUpdate() {
            console.log('My component was just updated - it rerendered!');
        }

        render() {
            // render view to the screen
        }
    }
    ```

## Why Lifecycle Methods?
1. `constructor`is a good place to do one-time setup.
1. `render` can avoid doing anything besides returning JSX.
1. `componentDidMount` is a good place to do data loading.
1. `componentDidUpdate` is good place to do more data loading when state/props change.
1. `componentWillUnmount` is good place to do cleanup (especially for non-React stuff).
1. Though we can make API calls for asnyc request in `constructor` directly, it's not recommended to do so.
1. By keeping the data request separated in constructor, we can make the code cleaner.
1. In addition, there are other lifecycle methods avaiable but not in frequent use, such as `shouldComponentUpdate`, `getDerivedStateFromProps`, and `getSnapshotBeforeUpdate`.

## Refactoring Data Loading to Lifecycle Methods
1. We put the geolocation API which request for user location in `componentDidMount` method
    ```js
    // index.js in App class
    componentDidMount() {
        window.navigator.geolocation.getCurrentPosition(
            position => this.setState({ lat: position.coords.latitude }),
            err => this.setState({ errorMessage: err.message })
        );
    }
    ```

## Alternate State Initialization
1. We can refactor the constructor function in the class. In this case, we can simply use `state = { lat: null, errorMessage: ''}` without using `constructor (props) { super(props) }`.
1. The reason that it works because `Babel` compile the JavaScript into another form which is compatible with ES5 and older browsers.
    ```js
    class App extends React.Component {
        // build state without constructor function
        state = { lat: null, errorMessage: '' };

        componentDidMount() {
            // data that is mounted
        }

        componentDidUpdate() {
            console.log('My component was just updated - it rerendered!');
        }

        // React says we have to define render
        render() {
            // render JSX on screen
        }
    }
    ```
    <img src="./images/buildWithoutConstructorInReact.png">

## Passing State as Props
1. If there's no error message and we have received the latitude from geolocation API, we can pass it to the component to be rendered on the screen.
    ```js
    render() {
        if (!this.state.errorMessage && this.state.lat) {
            return <SeasonDisplay lat={this.state.lat} />;
        }
    }
    ```
1. We can update in `SeasonDisplay` component to receive the data from state. 
    ```js
    // SeasonDisplay.js
    import React from 'react';

    const SeasonDisplay = (props) => {
        console.log(props.lat);
        return <div>Season Display</div>;
    };

    export default SeasonDisplay;
    ```

## Determing Season
1. As we have got the latitude to know which part in the world (or area) is the user at, we can return the aligned weather or season according to the location.
1. In this case, if the month is from March to October, the northern part will be in summer, while the southern part will be in winter and vice versa. 
    ```js
    const getSeason = (lat, month) => {
        if (month > 2 && month < 9) {
            return lat > 0 ? 'summer' : 'winter';
        } else {
            return lat > 0 ? 'winter' : 'summer';
        }
    }

    const SeasonDisplay = (props) => {
        const season = getSeason(props.lat, new Date().getMonth());
        console.log(season);
        return <div>Season Display: {season}</div>;
    };
    ```

## Ternary Expresssion in JSX
1. We then can show different contents based on the returned value from `getSeason` function.
1. As the case is relatively simple, we can use ternary statement to return the desirable statement.
    ```js
    const SeasonDisplay = (props) => {
        const season = getSeason(props.lat, new Date().getMonth());
        const text = season === 'winter' ? 'Burr, it is chilly' : 'Lets hit the beach';

        return (
            <div>
                <h1>{text}</h1>
            </div>
        );
    };
    ```

## Showing Icons
1. We can use the [icons](https://semantic-ui.com/elements/icon.html#/icon) from semantic UI. In this case, we can use `sun` and `snowflake`. The syntax for semantic UI is `<i class="icon_name icon"></i>`.
1. We then can import the icon according to the data from `season`.
    ```js
    const SeasonDisplay = (props) => {
        const season = getSeason(props.lat, new Date().getMonth());
        const text = season === 'winter' ? 'Burr, it is chilly' : 'Lets hit the beach';
        const icon = season === 'winter' ? 'snowflake' : 'sun';

        return (
            <div>
                <i className={`${icon} icon`} />
                <h1>{text}</h1>
                <i className={`${icon} icon`} />
            </div>
        );
    };
    ```

## Extracting Options to Config Objects
1. For the required data as configurations, we can create another object in the file to serve the purpose for cleaner code. 
1. We can also use ES6 distructure to create variables from object properties. 
    ```js
    // SeasonDisplay.js
    const seasonConfig = {
        summer: {
            text: `Let's hit the beach`,
            iconName: 'sun'
        },
        winter: {
            text: `Burr, it is chilly`,
            iconName: 'snowflake'
        }
    };

    const getSeason = (lat, month) => {
        if (month > 2 && month < 9) {
            return lat > 0 ? 'summer' : 'winter';
        } else {
            return lat > 0 ? 'winter' : 'summer';
        }
    }

    const SeasonDisplay = (props) => {
        const season = getSeason(props.lat, new Date().getMonth());
        // ES6 destructuring assignment
        const { text, iconName } = seasonConfig[season];

        return (
            <div>
                <i className={`${iconName} icon`} />
                <h1>{text}</h1>
                <i className={`${iconName} icon`} />
            </div>
        );
    };
    ```

## Adding some styling
1. For styling with CSS, we can create `SeasonDisplay.css` in the same directory (src) with `SeasonDisplay.js`.
1. Note that we give each icon a class as `icon-left` and `icon-right`.
    ```js
    <div>
        <i className={`icon-left massive ${iconName} icon`} />
        <h1>{text}</h1>
        <i className={`icon-right massive ${iconName} icon`} />
    </div>
    ```
1. After creating the css file, we can import it into the JavaScript by using webpack. In react framework, we can simply import the css file.
    ```js
    // SeasonDisplay
    import './SeasonDisplay.css';
    ```
1. It is suggested to have the component name as the class name of the wrapper (container) of the HTML element, so we can ensure the following HTML elements can be easily grouped and selected with CSS as well.
    ```js
    const SeasonDisplay = (props) => {
        const season = getSeason(props.lat, new Date().getMonth());
        const { text, iconName } = seasonConfig[season];

        return (
            <div className={`season-display ${season}`}> // use component name
                <i className={`icon-left massive ${iconName} icon`} />
                <h1>{text}</h1>
                <i className={`icon-right massive ${iconName} icon`} />
            </div>
        );
    };
    ```
1. We use the following css to style our page.
    ```css
    /* SeasonDisplay.css */
    .icon-left {
        position: absolute;
        top: 10px;
        left: 10px;
    }

    .icon-right {
        position: absolute;
        bottom: 10px;
        right: 10px;
    }

    .season-display {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
    }

    .season-display.winter i {
        color: blue;
    }

    .season-display.summer i {
        color: red;
    }

    .winter {
        background-color: aliceblue;
    }

    .summer {
        background-color: orange;
    }
    ```

## Showing a Loading Snipper
1. During the very first view when the page is rendered, as we haven't got the data of the location from the user because the browser is asking for user's permission, the page is blank in this case.
1. We can add a loader to improve user experience and understand the state of the program that it is waiting to receive and load the contents after getting the data or permission from the user. 
1. In this case, we can refer to the [loader](https://semantic-ui.com/elements/loader.html) element from semantic UI.
1. As we should avoid using raw JSX in `App` directly and tend to create reusable components, we can create another file for `Spinner`.
    ```js
    // Spinner.js
    import React from 'react';

    const Spinner = () => {
        return (
            <div className="ui active dimmer">
                <div className="ui big text loader">Loading...</div>
            </div>
        );
    };

    export default Spinner;
    ```
1. We then can import and use the component in `App`.
    ```js
    import Spinner from './Spinner';
    render() {
        return <Spinner />;
    }
    ```

## Specifying Default Props
1. Though we have installed a loader (spinner animation) to indicate that the page is loading, it will much clearer to users that what are the current requirements to them. 
1. Therefore, we can use `props` to send `prop.message` variable from `App`.
1. In the component file, we can use `||` logical operator to return a default message when there's nothing passed to the variable because we could forget to put variable in by chances. However, we can use another syntax for the case.
    ```js
    // Spinner.js
    Spinner.defaultProps = {
        message: 'Loading...'
    }
    ```

## Avoid Conditionals in Render
1. If we'd like to create a template-like styling feature to apply to all the JSX, we don't need to add raw JSX directly with classes to the components.
1. We can use "helper function" that can apply all the elements with styling to the components. In this case, we create another method `renderContent` in `App` instance.
1. We then can use single element to wrap the returned JSX and call the method by `this.renderContent()`.
    ```js
    renderContent() {
        if (this.state.errorMessage && !this.state.lat) {
            return <div>Error: {this.state.errorMessage}</div>;
        }

        if (!this.state.errorMessage && this.state.lat) {
            return <SeasonDisplay lat={this.state.lat} />;
        }

        // return <Spinner />;
        return <Spinner message="Please accept location request" />;
    }

    // React says we have to define render
    render() {
        return (
            <div className="border red">
                {this.renderContent()} // call the rednerContent function for JSX
            </div>
        );
    };
    ```

## Breather and Review
1. Benefits of using `class` components
    1. Easier code organization.
    1. Can use `state` (another React system) which makes it easier to handle user input.
    1. Understands lifecycle events which makes it easier to do things when the app first starts.
1. In convention, we should put components at the bottom of the code and put configure object and helper function above.
1. Rules of `Class Components`
    1. Must be a JavaScript class.
    1. Must extend (subclass) from `React.Component`.
    1. Must define a `render` method that returns some amount of JSX.
1. Rules of `State`
    1. Only useable with class components.
    1. You will confuse `props` with `state`.
    1. `State` is a JS object that contains data relevant to a component.
    1. Updating `state` on a component causes the component to (almost) instantly rerender.
    1. `State` must be initializd when a component is created.
    1. `State` can be updated using the function `setState`.
1. We should never assign the value to properties on `state` object.
1. Component Lifecycle
    1. `constructor`
    1. `render`
    1. `componentDidMount`
    1. `componentDidUpdate`
    1. `componentWillUnmount`



# Handling User Input with Forms and Events 
## App Overview
1. The main tasks for the app to acheive 
    1. How do we get feedback from the user?
    1. How do we fetch data from some outside API or server?
    1. How do we show lists of records?
1. We will have several versions of app
    1. Show a list of results that the user searches. Users can scroll down to check all the results.
    1. Show a grid of results which images are in different sizes.

## Component Design
1. App Challenges
    1. Need to get earch term from the user.
    1. Need to use that search term to make a request to an outside API and fetch data.
    1. Need to take the fetched images and show them on the screen in a list.
1. In the 1st version app, we have 2 main components, `SearchBar` and `ImageList`. 

## Adding Some Project Structure
1. In this case, we'd like to strucutre and keep the files organized.
1. As we will use several components, we can create another folder `components` in the `src` directory.
1. In this case, we can keep `App` in a separate file.
    ```js
    // index.js 
    import React from 'react';
    import ReactDOM from 'react-dom';
    import App from './components/App'

    ReactDOM.render(
        <App />,
        document.querySelector('#root')
    );

    // App.js
    import React from 'react';

    const App = (props) => {
        return <div>App</div>;
    }

    export default App;
    ```

## Showing Forms to the User
1. We can create a `SearchBar` component and import it into `App.js`.
    ```js
    // components/SearchBar.js
    import React from 'react';

    class SearchBar extends React.Component {
        render() {
            return (
                <div>
                    <form>
                        <input />
                    </form>
                </div>
            );
        }
    }

    export default SearchBar;
    ```

## Adding a Touch Style
1. We can use CDN and `<link>` tag to use semantic UI.
1. After importing semantic UI, we can modify the sturecture of JSX.
1. We then add some inline styling for the component for the magin on the top to give some space for the component.
    ```js
    // SearchBar.js
    class SearchBar extends React.Component {
        render() {
            return (
                <div className="ui segment">
                    <form className="ui form">
                        <div className="field">
                            <label>Image Search</label>
                            <input type="text" />
                        </div>
                    </form>
                </div>
            );
        }
    }

    // App.js
    const App = (props) => {
        return (
            <div className="ui container" style={{ marginTop: '10px' }}>
                <SearchBar />
            </div>
        );
    };
    ```
    <img src="./images/picsSearchBar.png">

## Creating Event Handlers
1. We can use some event handling properties on the HTML element directly.
1. In this case, we want to catch what the user has input to the `SearchBar` component.
1. There are several frequent used event hanlders that we can use in the case.
    1. `onClick` works when user clicks on something.
    1. `onChange` works when user changes text in an input.
    1. `onSubmit` works when user submits a form.
1. In convention, we can name the event handling method starting with `on` or `handle` and starts with lowercase.
1. Note that we should only pass the callback function for `onChange` or `onClick` rather than using parethesis because we don't want the function be fired every time when the page is loaded.
    ```js
    class SearchBar extends React.Component {
        onInputChange(event) {
            console.log(event.target.value);
        }

        render() {
            return (
                <div className="ui segment">
                    <form className="ui form">
                        <div className="field">
                            <label>Image Search</label>
                            // use onChange with callback function
                            <input type="text" onChange={this.onInputChange} />
                        </div>
                    </form>
                </div>
            );
        }
    }
    ```

## Alternate Event Handler Syntax
1. Besides passing a method for the object to work on event handling, we can pass an anonymous function directly.
    ```js
    class SearchBar extends React.Component {
        onInputChange(event) {
            console.log(event.target.value);
        }

        render() {
            return (
                <div className="ui segment">
                    <form className="ui form">
                        <div className="field">
                            <label>Image Search</label>
                            // pass anonymous function rather than referring to object method
                            <input type="text" onChange={e => console.log(e.target.value)} />
                        </div>
                    </form>
                </div>
            );
        }
    }
    ```

## Uncontrolled vs Controlled Elements
1. The component is not controlled so far, and we can create a `state` object to catch the value when the user is working with the `App`.
1. In this case, we can use `value` property of `input` element to store the value that the user gives.
    ```js
    class SearchBar extends React.Component {
        state = { term: '' }

        render() {
            return (
                <div className="ui segment">
                    <form className="ui form">
                        <div className="field">
                            <label>Image Search</label>
                            <input
                                type="text"
                                value={this.state.term}
                                onChange={e => this.setState({ term: e.target.value })}
                            />
                        </div>
                    </form>
                </div>
            );
        }
    }
    ```

## More on Controlled Elements
1. Before we refactor the element to be controlled, we can use JavaScript and use DOM to check the value of the `input` element.
1. In this case, the react app itself doesn't actually know the value that is given by the user. 
1. This improve the preformance and efficiency for react app to manipulate the data, as the value is stored in the `state` and can be used instantly without fetching from the DOM (which is relatively slow) and use it somewhere else.
1. After refactoring the component, the process is changing from "fetching the data and use it" to "create with it since the beginning". 
1. When the component is rendered the data is stored in the `value` property at the beginning.
1. Besides, we can apply filter when receiving data input from users. For example, we can turn all the input string into uppercase or lowercase. 
    ```js
    class SearchBar extends React.Component {
        state = { term: '' }

        render() {
            return (
                <div className="ui segment">
                    <form className="ui form">
                        <div className="field">
                            <label>Image Search</label>
                            <input
                                type="text"
                                value={this.state.term}
                                // turn all the input into uppercase
                                onChange={e => this.setState({ term: e.target.value.toUpperCase() })}
                            />
                        </div>
                    </form>
                </div>
            );
        }
    }
    ```

## Handling Form Submittal
1. When user gives input in the input block and press <kbd>Enter</kbd>, the browser will send a request to the backend and refresh the page by default.
1. In vanilla JavaScript, We can use JavaScript DOM to select the `<form>` element and prevent it to proceed default behavior. 
1. In react, we can use `onSubmit` event handler in `<form>` tag and put the callback function in the object method to be called.
    ```js
    class SearchBar extends React.Component {
        state = { term: '' }

        onFormSubmit(event) {
            event.preventDefault();

            console.log(this.state.term);
        }

        render() {
            return (
                <div className="ui segment">
                    // use onSubmit property and callback function to prevent default behavior
                    <form className="ui form" onSubmit={this.onFormSubmit}>
                        <div className="field">
                            <label>Image Search</label>
                            <input
                                type="text"
                                value={this.state.term}
                                onChange={e => this.setState({ term: e.target.value })}
                            />
                        </div>
                    </form>
                </div>
            );
        }
    }
    ```
1. We can also put `console.log` in the `onFormSubmit` method to print what has the user gave to the app. However, at the current solution, it casues problems and turns the app collapse if we simply print the `state` in the method.
    ```js
    onFormSubmit() {
        // only printing the state make the app crashes
        console.log(this.state.term);
    }
    ```

## Understanding 'this' in JavaScript
1. The main reason that causes problems in the last section is the "**lexical scope**" where to call the method of the object. 
1. As the `render` method is called in the regular condition, the method can access `this` correct from the object. 
1. However, when we use callback in the method, the lexical scope changes, and `this` is pointing to the current lexical scope which doesn't have `this.state` property. This is the main reason why we get a reference error that the system prompts us that we are trying to fetch the value of a property from `undefined`.
1. Therefore, one of the solution is to use `.bind` method and refer to `this` when assigning callback function in the `onSubmit` property.
    ```js
    // this solution is from experience and current knowledge rather than from the course
    <form className="ui form" onSubmit={this.onFormSubmit.bind(this)}>
    ```

## Solving Context Issues
1. One of the solutions is to use `.bind` to method to refere to `this` when building the constructor
    ```js
    class Car {
        constructor() {
            // use bind to assign this to ensure 'this' is referred to correct object
            this.drive = this.drive.bind(this);
        }

        setDriveSound(sound) {
            this.sound = sound;
        }

        drive() {
            return this.sound;
        }
    }

    const car = new Car;
    car.setDriveSround('vroom');

    const drive = car.drive;
    ```
1. The other solution is to use arrow function in which `this` will refer to the parent scope of the arrow function. In this case, we have 2 ways to use arrow function.
    1. We can use arrow function to build the method when declaring the class.    
    ```js
    class SearchBar extends React.Component {
        // use arrow function to prevent incorrect scope reference
        onFormSubmit = (event) => {
            event.preventDefault();
            console.log(this.state.term);
        }

        render() {
            return(
                <form onSubmit={this.onFormSubmit}>
                    // ...
                </form>
            );
        }
    }
    ```
    1. The other way is to use arrow function in `render` method to as passing an anonymous arrow function for `onSubmit` property.
    ```js
    class SearchBar extends React.Component {
        onFormSubmit(event) {
            event.preventDefault();
            console.log(this.state.term);
        }

        render(){
            return (
                // pass an anonymous arrow function
                <form onSubmit={(event) => this.onFormSubmit(event)} className="ui form">
                    // ...
                </form>
            );
        };
    }
    ```

## Communicating Child to Parent
1. In this project, the main purpose for `SearchBar` component is to collect user input and pass the data to `App` component to work on further functions such as making a API request.
1. In the previous sections, we learnt usnig `props` system which only allows us to pass value from parent to child. 
1. The solution in this case is to turn `App` into a "**class**" component which has method that can be called by `SearchBar` component, so the value can be passed and retreived from `SearchBar` to `App`.
    ```js
    // App.js
    class App extends React.Component {
        onSearchSubmit(term) {
            console.log(term);
        }

        render() {
            return (
                <div className="ui container" style={{ marginTop: '10px' }}>
                    // pass the method of the class with 'this'
                    <SearchBar onSubmit={this.onSearchSubmit} />
                </div>
            );
        }
    };
    ``

## Invoking Callbacks in Children
1. In class based components, we need to refer to `this` to use `.prop` from parent component.
    ```js
    class SearchBar extends React.Component {
        state = { term: '' };

        onFormSubmit = (event) => {
            event.preventDefault();
            // use this.props to get the methods from parent component
            this.props.onSubmit(this.state.term);
        };

        render(props) {
            return (
                <div className="ui segment">
                    <form className="ui form" onSubmit={this.onFormSubmit}>
                        <div className="field">
                            <label>Image Search</label>
                            <input
                                type="text"
                                value={this.state.term}
                                onChange={e => this.setState({ term: e.target.value })}
                            />
                        </div>
                    </form>
                </div>
            );
        }
    }
    ```



# Making API Requests with React 
## Fetching Data
1. In this project, we can use unsplash api which provides HD images. Our task is to send request from our App to unsplash endpoint which will return a JSON file with data. We firstly go to register at [Unsplash Developer](https://unsplash.com/developers).
1. We can also check its [documentation](https://unsplash.com/documentation) to learn how to use unsplash endpoint.

## Axios vs Fetch
1. In React, we can use 3rd part package such as `axios` or `fetch` function that is built into modern browsers.
1. The tradeoff of using `fetch` is that it is a reltative low-level function that there's much more code we have to write. 
1. We can use `npm i axios --save` to install `axios` for the project. We then can use `import` syntax to use the package.
    ```js
    // App.js
    import axios from 'axios';
    ```

## Viewing Request Results
1. According to [Unsplash documentation](https://unsplash.com/documentation#search-photos), we can search for photos through `/search/photos` through `GET` request.
1. Note that the [root location](https://unsplash.com/documentation#location) for unsplash API is `https://api.unsplash.com/`.
1. To do [authentication](#https://unsplash.com/documentation#public-authentication), we can put the access key in the header of the request.
1. Note that we should follow the syntax and requirements from unsplash for the request specifically. For example, according to documentation `Authorization: Client-ID YOUR_ACCESS_KEY` is with uppercase `A` and `Client-ID` as part of the value for the property. We then put this in `headers` object in the request.
1. Besides, we can put the `term` which is the user input to `params` to send with the `GET` request.
1. Note that we haven't handle the JSON returned by reponse. However, we can check the data in develop console in the browser in "network" tab. We can find that a big object is returned and find `urls` in the `results` array for the images.
    ```js
    import React from 'react';
    import axios from 'axios';

    class App extends React.Component {
        onSearchSubmit(term) {
            axios.get('https://api.unsplash.com/search/photos', {
                params: {
                    query: term
                },
                headers: {
                    Authorization: 'Client-ID Aej6-RfDMJ9kg1hnpdUdDwgT9-A-HcEpol9FMj9ugn4'
                }
            });
        }

        render() {
            return (
                <div className="ui container" style={{ marginTop: '10px' }}>
                    <SearchBar onSubmit={this.onSearchSubmit} />
                </div>
            );
        }
    }

    export default App;
    ```

## Handling Requests with Async Await
1. The process of React app when running on request
    1. Component renders itself one time with no list of images
    1. `onSearchSubmit` method is called
    1. Request is made to `unspalsh`
    1. Wait for response from the API
    1. Request complete
    1. Set image data on `state` of `App` component
    1. `App` component rerenders and shows images
1. There are 2 ways to handle async events, `Promise` or `Async Await`.
    1. To use `Promise`, we can take off the semi-column after the `axios` request and put `.then()` method to handle the response data.
    ```js
    onSearchSubmit(term) {
        axios.get('https://api.unsplash.com/search/photos', {
            params: {
                query: term
            },
            headers: {
                Authorization: 'Client-ID Aej6-RfDMJ9kg1hnpdUdDwgT9-A-HcEpol9FMj9ugn4'
            }
        })
        .then(response => {
            console.log(response.data.results);
        })
    }
    ```
    1. For `Async Await`, we should mark `onSearchSubmit` as `async` function.
    ```js
    async onSearchSubmit(term) { // decalre for async function
        const response = await axios.get('https://api.unsplash.com/search/photos', { // use await to put the function to event loop
            params: {
                query: term
            },
            headers: {
                Authorization: 'Client-ID Aej6-RfDMJ9kg1hnpdUdDwgT9-A-HcEpol9FMj9ugn4'
            }
        });

        // manipulate the response data in async function
        console.log(response.data.results);
    }
    ```

## Setting State After Async Requests
1. We then declare a `state` property in `App` class and give `images` as a property with default value as an empty array. In convention, if the data structure is confirmed, we can give either an empty array or object according to the requirements.
1. We will face the same issue for referring `this` to the correct object. According to previous sections, we can choose 1 of the 3 strategies to solve the issue.
1. In this case, we choose to declare the method with async arrow function.
1. In addition, we can modulize the `axios` API into another separated code to keep the code clean.
    1. Use `constructor` with `.bind`.
    ```js
    class App extends React.Component {
        constructor (props) {
            super(props);
            this.onSearchSubmit = this.onSearchSubmit.bind(this);
        }

        state = { images: [] };

        async onSearchSubmit(term) {
            const response = await axois.get('https://api.unsplash.com/search/photos', {
                params: {
                    query: term
                },
                headers: {
                    Authorization: 'Client-ID Your_Accesss_Key'
                }
            });

            this.setState({ images: response.data.results });
        }
    }
    ```
    1. Declare the method with arrow function in the class
    ```js
    onSearchSubmit = async (term) => {
        const response = await axois.get('https://api.unsplash.com/search/photos', {
            params: {
                query: term
            },
            headers: {
                Authorization: 'Client-ID Your_Accesss_Key'
            }
        });

        this.setState({ images: response.data.results });
    }
    ```
    1. Pass an anonymous arrow function for the callback function
    ```js
    class App extends React.Component {
        render() {
            return(
                <SearchBar onSubmit={this.onSearchSubmit} />
            );
        }
    }
    ```

## Creating Custom Clients
1. We create `api` folder in `src` folder, which we use to keep the `axios` request to unsplash endpoint.
1. In this case, we can separate the default parameters and keep them in a separate files to keep the main code cleaner.
1. According to `axios` library, we can create an `axios` object with pre-defined parameters and endpoint.
    ```js
    // src/api/unsplash.js
    import axios from 'axios';

    export default axios.create({
        baseURL: 'https://api.unsplash.com',
        headers: {
            Authorization: 'Client-ID Your_Unsplash_Access_Key'
        }
    });
    ```
1. We the can import the file and use it in the `App`.
    ```js
    // src/components/App.js
    import unsplash from '../api/unsplash.js';

    async onSearchSubmit(term) {
        // make GET request through unsplash object that is an axios object with pre-defined params
        const response = await unsplash.get('/search/photos', {
            params: { query: term }
        });

        this.setState({ images: response.data.results });
    }
    ```



# Building Lists of Records
## Rendering Lists
1. We create a new component `ImageList` in component directory to render the list of images returned from unsplash API. Note that we can retreieve data passed from parent object 
    ```js
    // src/components/ImageList.js
    import React from 'react';

    const ImageList = (props) => {
        return (
            console.log(props.images);
            <div>ImageList</div>;
        );
    };

    export defualt ImageList;
    ```
1. We import the `ImageList` to `App` comopnent and pass the array of image URLs from parent to child component. Note that we should pass the fetched data from `App` to `ImageList`, so it can be retreived from `props` argument. 
    ```js
    import ImageList from './ImageList.js';

    class App extends React.Component {
        state = {images: []};

        render() {
            return (
                <ImageList images={this.state.images} />
            );
        }
    }
    ```

## Review of Map Statements
1. `.map` is an array method for arrays in JavaScript that we can use the method to create a new array based on the elements of a given array.
1. Without the array method, we have to declare a new empty array and use `for loop` to push 
    ```js
    const numbers = [0, 1, 2, 3, 4];

    let newNumbers = [];

    for (let i = 0; i < numbers.length; i++) {
        newNumbers.push(numbers[i] * 10);
    }

    numbers.map( num => num * 10);

    numbers.map(num => <div>{num}</div>);
    ```

## Rendering Lists of Components
1. With `.map` array method, we can create a new array from the `props` which has an array of URLs and turn them into `<img>` tags that can show the images. 
1. Note that we will get a warning about the `key` prop for each child element. Note that the app still works though there's warning for this.
    ```js
    // ImageList.js
    import React from 'react';

    const ImageList = (props) => {
        const images = props.images.map((image) => {
            return <img src={image.urls.regular} />
        });

        return <div>{images}</div>;
    }

    export default ImageList;
    ```

## The Purpose of Keys in Lists
1. From the last section, we get warning noticed that "**Each child in an array or iterator should have a unique 'key' prop**".
1. The main purpose of using `key` is to prevent React repeating the tasks that have been done. For example, we have a list of 3 tasks that have been rendered on the screen. If we have another new task added to the list, we only want the React App to be efficient that it only renders the latest one which hasn't been rendered to the screen rather tahn rerender all the items again. 
1. Therefore, we use the `key` for each item that is iterated through an array.

## Implementing Keys in Lists
1. To give `key` to each item through iteration, we can give another property `key` to each `<img>` tag when creating the new array through `.map`.
1. After we give `key` property to each element, React also prompted another warning to request `alt` property for each image. `alt` is used and shown when the image can't be imported correctly, so it can describe what's going on with the image. This property is good for SEO and impaired users when browsing the web.
1. Besides, we can use destructuring assignment to create new arguments from the object directly.
    ```js
    import React from 'react';

    const ImageList = (props) => {
        console.log(props.images)
        const images = props.images.map(({ alt_description, id, urls }) => { // use destructuring assignment
            return <img key={id} src={urls.regular} alt={alt_description} />
        });

        return <div>{images}</div>;
    }

    export default ImageList;
    ```



# Using Ref's for DOM Access
## Grid CSS
1. In `pics` project, the images responded by Unsplash API is too large to provide a decent UI. 
1. For images, we can use CSS `Grid` system to create a layout. We create `ImageList.css` in comopnents directory.
    ```css
    .image-list {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
        grid-gap: 10px;
    }

    .image-list img {
        width: 250px;
    }
    ```
1. We need to assign class to the `<div>` tag which wraps all the images. Besides, we need to import the CSS file to use the style.
    ```js
    import './ImageList.css';
    import React from 'react';

    const ImageList = (props) => {
        console.log(props.images)
        const images = props.images.map(({ alt_description, id, urls }) => {
            return <img key={id} src={urls.regular} alt={alt_description} />
        });

        return <div className="image-list">{images}</div>;
    }

    export default ImageList;
    ```
    <img src="./images/pics_first_grid.png">

## Issues with Grid CSS
1. Though we give a grid layout for all the images in the list, each image has different size with various width and height. Besides, the white space between each cell in the grid can be either too large or small. If the white space is not enough, the image will overflow its own cell and overlap then cover images in the nearby cells. 
1. In this case, we can give a single CSS property `grid-row-end: span 2` which can span the space for the image. 
1. However, we can't hard coded for the case because each image would require different number of span in the grid. For example, some images can be held by a single regular cell, while some may need up to 4 spans.
1. Therefore, we can't simply solve the issue with only CSS. 
    ```css
    .image-list {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
        grid-gap: 10px;
        grid-auto-rows: 150px;
    }

    .image-list img {
        width: 250px;
        grid-row-end: span 2;
    }
    ```

## Creating an Image Card Component
1. We will create a new React component which will render each individual image. Besides, it will adjust the component according to the height of the single image. 
1. We then create a new JS file in `component` folder name `ImageCard.js`. We can use destructuring assignment to avoid retreiving data from object properties.
    ```js
    // src/components/ImageCard.js
    import React from 'react';

    class ImageCard extends React.Component {
        render() {
            const { alt_description, urls } = this.props.image;
            return (
                <div>
                    <img
                        alt={alt_description}
                        src={urls.regular}
                    />
                </div>
            );
        };
    }

    export default ImageCard;
    ```
1. Besides, we need to refactor `ImageList.js` 
    ```js
    import './ImageList.css';
    import React from 'react';
    import ImageCard from './ImageCard';

    const ImageList = (props) => {
        console.log(props.images)
        const images = props.images.map((image) => {
            return <ImageCard key={image.id} image={image} />
        });

        return <div className="image-list">{images}</div>;
    }

    export default ImageList;
    ``` 

## Accessing the DOM with Refs
1. The flow of how the components work
    1. Let the `ImageCard` render itself and its image
    1. Reach into the DOM and figure out the height of the image
    1. Set the image height on state to get the component to rerender
    1. When rerendering, assign a `grid-row-end` to make sure the image takes up the appropriate space. 
1. Note that in vanilla JavaScript, we can use DOM such as `document.querySelector('img')` to select the first image element on the page. Then we can use `.clientHeight` to check the height of the image.
1. In this case, we use "**React Reference System**" (`React Refs`) which can
    1. Gives access to a single DOM element
    1. We create `refs` in the constructor, assign them to instance variables, then pass to a particular JSX element as `props`.

## Accessing Image Height
1. To use `refs` in this case, we create `constructor` in `ImageCard` component.
1. Besides, we need to refer to its parent properties by using `super`.
1. Then we can declare the property for the object with `React.createRef()` to create a DOM node which selects the element.
1. We put `ref` with the value from the property in the `img` tag. Note that this is a JSX tag rather than HTML. This tag will become a DOM selector that collects the node info.
1. We then can use `componentDidMount` which will be triggered when the request has got the respond data. We can check the data that we select with `this.imageRef`. This will show the element that we select by the DOM.
1. However, we can't actually access the data from the DOM at this step. If the data is given and updated from an API, at the moment when the DOM is checked, the data is actually not returned from the API yet. 
1. Therefore, in the following case, we will see all `0`s printed in the console when we try to check `this.imageRef.current.clientHeight`. Note that we still can check the value from the object in the console directly because the web browser engine is fancy enough to get and show the data in the developer console. 
1. Nevertheless, we have to understand that in this step, the data hasn't actually been returned and this is the reason why we will get `0` printed from the property of the DOM node. 
    ```js
    import React from 'react';

    class ImageCard extends React.Component {
        constructor(props) {
            super(props);

            this.imageRef = React.createRef();
        }

        componentDidMount() {
            console.log(this.imageRef.current.clientHeight);
        }

        render() {
            const { alt_description, urls } = this.props.image;
            return (
                <div>
                    <img
                        ref={this.imageRef}
                        alt={alt_description}
                        src={urls.regular}
                    />
                </div>
            );
        };
    }

    export default ImageCard;
    ```

## Callbacks on Image Load
1. We then add an event listener on the node directly with an event `load`, which only fires when the image is loaded completely and call the callback function.
1. Note that this callback function is a method from the same object. To avoid incorrect `this` scope reference, we should use arrow function to declare the method in the class. 
    ```js
    import React from 'react';

    class ImageCard extends React.Component {
        constructor(props) {
            super(props);

            this.imageRef = React.createRef();
        }

        // add event listener and only runs the callback function after the image is loaded
        componentDidMount() {
            this.imageRef.current.addEventListener('load', this.setSpans);
        }

        // use arrow function to prevent incorrect this reference
        setSpans = () => {
            console.log(this.imageRef.current.clientHeight);
        }

        render() {
            const { alt_description, urls } = this.props.image;
            return (
                <div>
                    <img
                        ref={this.imageRef}
                        alt={alt_description}
                        src={urls.regular}
                    />
                </div>
            );
        };
    }

    export default ImageCard;
    ```

## Dynamic Spans
1. In the callback function `setSpan`, we can decide how much `span` we are going to assign to the element according to its height. 
1. We use `state` property to keep the updated and calculated number for `span` in `state.spans` and give the default value at `0`.
1. We calculate the number of `spans` that should be given to the image according to the height of each row in the `grid`. In this case, we have default height for each row as `grid-auto-rows: 10px`. Note that the initila height at `150px` is way too much that it gives too much white space between the images.
    ```js
    // src/components/ImageCard.js
    import React from 'react';

    class ImageCard extends React.Component {
        constructor(props) {
            super(props);

            this.state = { spans: 0 };

            this.imageRef = React.createRef();
        }

        componentDidMount() {
            this.imageRef.current.addEventListener('load', this.setSpans);
        }

        setSpans = () => {
            const height = this.imageRef.current.clientHeight;
            const spans = Math.ceil(height / 10);
            this.setState({ spans });
        }

        render() {
            const { alt_description, urls } = this.props.image;
            return (
                <div style={{ gridRowEnd: `span ${this.state.spans}` }}>
                    <img
                        ref={this.imageRef}
                        alt={alt_description}
                        src={urls.regular}
                    />
                </div>
            );
        };
    }

    export default ImageCard;
    ```
1. Note that we also need to adjust CSS to render the gap between the cells in the grid with `grid-gap`. Besides, we can give 2 values to the property, as the 1st one is for horizontal, and the 2nd one is for vertical. In this case, we only need gap between cells in the vertical way.
    ```css
    .image-list {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
        grid-gap: 0 10px;
        grid-auto-rows: 10px;
    }

    .image-list img {
        width: 250px;
        grid-row-end: span 2;
    }
    ```
    <img src="./images/picsGridFinal.png">


## App Review
1. As we learn from this project, in most of the cases to avoid incorrect `this` reference, we can use arrow function to declare functions.
1. We can use `props` system to communicate and send data from parent to child component. 
1. On the other hand, if we'd like to pass data from a child to its parent component, we can send a callback function for the child component to call and send the data back. 
1. `.map` is a useful array method to create a list in React app. 
1. To interact with DOM or individual element, we can use `refs` system to create a `ref` in the consturctor with `React.createRef()` then pass it as `ref` property into the tag of the element. We then can manipulate it as regular JavaScript DOM node.



# Let's Test Your React Mastery! 
## App Overview
## Component Design
1. In this case, we'd like to create a react app which allows users to search from YouTube open API to get a list of videos and have the video player at the middle of the page. 
1. In this case, we may have several components
    1. `SearchBar` is for users to input terms to search from YouTube open API.
    1. `VideoDetail` which is the video player with video details.
    1. `VideoList` contains VideoItems as a list.
    1. `VideoItem` is the child component in the `VideoList`.

## Scaffolding the App
1. In this case, we initiate the project by removing all the pre-created files in the `src` directory.
1. We create `App.js` and `SearchBar.js` in `components` folder in `src` and import them accordingly.
    ```js
    // SearchBar.js
    import React from 'react';

    class SearchBar extends React.Component {
        render() {
            return <div>SearchBar</div>;
        }
    }

    export default SearchBar;

    // App.js
    import React from 'react';
    import SearchBar from './SearchBar';

    class App extends React.Component {
        render() {
            return(
                <SearchBar />
            );
        }
    }

    export default App;

    // index.js
    import React from 'react';
    import ReactDOM from 'react-dom';
    import App from './component/App';

    ReactDOM.render(
        <App />,
        document.querySelector('#root')
    );
    ```

## Reminder on Event Handlers
1. We can import Semantic CSS with `<link>` tag in the index.html in the `public` folder.
1. Note that we'd like to change and trace on the value on the `input` element which user gives. Besides, we should be aware of the `this` scope that is referring, so we use arrow function to declare the method for the class.
    ```js
    import React from 'react';

    class SearchBar extends React.Component {
        state = { term: "" };

        onInputChange = (event) => {
            this.setState({term: event.target.value});
        }

        render() {
            return (
                <div className="search-bar ui segment">
                    <form className="ui form">
                        <label>Video Search</label>
                        <input
                            type="text"
                            value={this.state.term}
                            onChange={this.onInputChange}
                        />
                    </form>
                </div>
            );
        }
    }

    export default SearchBar;
    ```

## Handling Form Submittal
1. To handle and retrieve the value from the element, we can declare a method
    ```js
    class SearchBar extends React.Component {
        state = {term: ''};

        onInputChange = (event) => {
            this.setState({term: event.target.value});
        }

        onFormSubmit = (event) => {
            event.preventDefault();

            // TODO: Make sure we call 
            // callback from parent component
        }

        render() {
            return (
                <form onSubmit={this.onFormSubmit}>
                <input
                    type="text"
                    value={this.state.term}
                    onChange={this.onInputChange}
                />
                </form>
            )
        }
    }
    ```
1. Note that we can also use an anonymous arrow function with `onChange` property to update the value of the `state`.
    ```js
    <input
        type="text"
        value={this.state.term}
        onChange={ e => this.setState({term: e.target.value})}
    />
    ```

## Accessing the YouTube API
1. In this case, we can use YouTube Data API (which is v3 at the time of learning). We can create a new project and enable the API in Google Developer Console.
1. We then create a new folder `apis` in `src` directory and create `youtube.js` to keep the credentials (the API key from Google). Besides, we can configure the usage of the key such as limiting domain to access the API and what API services can be called by using the key. 

## Search for Videos
1. According to YouTube API documentation, we can check the details for `list` in [`Search`](https://developers.google.com/youtube/v3/docs/search/list) section. 
1. From here, we can check that what are the public data should we retreive from the API. The main parameters we will use are the followings 
    ```js 
    GET https://www.googleapis.com/youtube/v3/search

    let params = {
        part: String, // set as 'snippet'
        maxResults: Number, // default is 5 and can range from 0 to 50
        q: String,
        type: String // channel, playlist, or video
    }
    ```
1. We then update the `youtube.js`. Note that we only put part of the params here without `q`, as this parameter can be set in the other components. Besides, we only give the `baseURL` up to `v3` with a slash to close it because later we can use `axios.get('/search')` to make a GET request.
1. In addition, to prevent warning for not having `key` property for child component in React, we can add `type: 'video'` in the `params` when setting up the `axios` object. This will ensure the API calls only request for video rather than platlist or channel. 
    ```js
    import axios from 'axios';

    const KEY = 'AIzaSyBtvThRXE9n-l_Y1jIXhx_EtLitcWbb3kI';

    export default axios.create({
        baseURL: 'https://www.googleapis.com/youtube/v3',
        params: {
            part: 'snippet',
            maxResults: 5,
            key: KEY,
            type: 'video'
        }
    });
    ```

## Putting All Together
1. After configuring the `axios` object, we can use it in the `App` in a callback function and fire it every time when a user search for something. We add another method in `SearchBar` to pass data when a user search.
    ```js
    // SearchBar
    onFormSubmit = event => {
        event.preventDefault();
        this.props.onFormSubmit(this.state.term);
    }
    ```
1. We then configure the method in `App.js` to handle the request made by `axios`.
    ```js
    onTermSubmit = (term) => {
        youtube.get('/search', {
            params: {
                q: term
            }
        });
    }
    ```
1. We then can check if `axios` make a request to YouTube API. For example, in the developer console, we can check "Network" tab with `XHR` request. We can see if there's a request made to `search`. 

## Updating State with Fetched Data
1. Since we are expecting to use the data from a GET request, we should use async function to handle the respond data from the API call. In this case, we are going to use the `items` array from the response data. 
1. Besides, we need to use `state` system to keep the data response from the API. 
1. Note that we should always be careful with the inital data for the state properties. For example, we have a placeholder to show how many videos are in the list by using `.length` to check the number of elements in an array. Therefore, if we use `null` as the initial value for `state`, it will return an error as we can't check the `length` property of a `null` object.
    ```js
    import React from 'react';
    import SearchBar from './SearchBar';
    import youtube from '../apis/youtube';

    class App extends React.Component {
        state = { videos: new Array }; // this must be an empty array

        onTermSubmit = async (term) => {
            const response = await youtube.get('/search', {
                params: {
                    q: term
                }
            });

            this.setState({ videos: response.data.items });
        }

        render() {
            return (
                <div className="ui container">
                    <SearchBar onFormSubmit={this.onTermSubmit} />
                    I have {this.state.videos.length} videos; // if we use null as initial value in state, this may cause error
                </div>
            );
        };
    }

    export default App;
    ```

## Passing State as Props
1. In this project, we have 3 main components, `SearchBar`, `VideoDetail`, `VideoList` with `VideoItem` as child components.
    ```js
    // VideoList.js
    import React from 'react';

    const VideoList = (props) => {
        return (
            <div>{props.videos.length}</div>
        );
    }

    export default VideoList;
    ```
1. Besides, we need to update the `App` for the new data.
    ```js
    // App.js
    class App extends React.Component {
        state = { videos: new Array };

        onTermSubmit = async (term) => {
            const response = await youtube.get('/search', {
                params: {
                    q: term
                }
            });

            this.setState({ videos: response.data.items });
        }

        render() {
            return (
                <div className="ui container">
                    <SearchBar onFormSubmit={this.onTermSubmit} />
                    <VideoList videos={this.state.videos} />
                </div>
            );
        };
    }
    ```

## Rendering a List of Videos
1. We can use destructuring assignment for to get the array from `props` in `VideoList.js`.
1. As we will repeatly render each video with its data, we can create a new component as `VideoItem`.
    ```js
    // VideoItem.js
    import React from 'react';

    const VideoItem = (props) => {
        return <div>VideoItem</div>
    }

    export default VideoItem;
    ```
1. We use `.map()` method to create an array that has multiple `VideoItem` in it.
    ```js
    import React from 'react';
    import VideoItem from './VideoItem';

    const VideoList = ({ videos }) => {
        const renderedList = videos.map((video) => { // create an array of 'VideoItem'
            return <VideoItem />;
        });

        return (
            <div>{renderedList}</div>
        );
    }

    export default VideoList;
    ```

## Rendering Video Thumbnails
1. In the last section, we can have a list of `VideoItem`s in the `VideoList`. We'd like to pass in fetched data from YouTube API to create the components with useful information.
1. In this case, we just simply update the structure in `VideoItem` with an `<img>` tag and get the thumbnail from the fetched data. 
    ```js
    // VideoItem.js
    import React from 'react';

    const VideoItem = ({ video }) => {
        return (
            <div>
                <img src={video.snippet.thumbnails.medium.url} />
                {video.snippet.title}
            </div>
        );
    }

    export default VideoItem;
    ```

## Styling a List
1. In this section, we will use [`list]`(https://semantic-ui.com/elements/list.html) styling from Semantic UI. Accroding to the document, the HTML structure should be as the following with classes.
1. Besides, we will use the list with image from semantic ui. However, as we don't want the image becomes a circle for avatar, we can use `ui image` for the element.
    ```html
    <div class="ui relaxed divided list"> <!-- this should be the layer of VideoList -->
        <div class="item"> <!-- this is the layer for VideoItem -->
            <img class="ui avatar image" src="image.jpg">
            <div class="content">
                <a class="header">Header</a>
                <div class="description">
                    Here's the description
                </div>
            </div>
        </div>
    </div>
    ```
1. In this case, we'd have more custom styling on the elements, so we can create another CSS in `component directly. 
1. Note that we can give a specific `class` named as the component, so we will ensure the CSS selector selects the correct component and elements in it. 
    ```html
    <div className="video-item item">
        <img className="ui image" src={video.snippet.thumbnails.medium.url} />
        <div className="content">
            <a className="header" href="https://youtube.com/watch?v=${video.id.videoId}">{video.snippet.title}</a>
            <div className="description">{video.snippet.description}</div>
        </div>
    </div>
    ```
1. Note that as we are using CSS library, some of the selector and styling would be applied to the elements. For example, the `max-width` wouldn't work if the selector is only `.video-item img`. We can only select and apply styling with more specific selector such as `.video-item.item img`.
    ```css
    /* VideoItem.css */
    .video-item {
        display: flex !important;
        align-items: center !important;
        cursor: pointer;
    }

    .video-item.item img {
        max-width: 180px;
    }
    ```

## Communicating from Child to Parent
1. In this react app, we have 2 main property in `state` system which are the "**video list**" returned from the API called, and the "**selected video**" which the user picks from the rendered list. 
    <img src="./images/videoAppStructure.png">
1. Therefore, after the list is rendered, the user can choose one of the videos in the list. When the user click the list, the `state` is updated with the chosen one.
1. As the state property should be updated and reflect the user interaction on the components in the child ones, we can pass a callback function from `App` through `VideoList` to `VideoItem`. Therefore, each of the `VideoItem` component in the very bottom layer of the app will have 2 `props`, `video` and `onVideoSelect`.
1. When the user clicks one of the videos in the list, `onVideoSelect` callback is triggered and takes the value back to the `state` in `App`. This will cause `selectedVideo` on the very top in `App` also be fired and update the `state`.

## Deeply Nested Callbacks
1. We create a callback function in `App.js` to update the state when there's data caught by event handler and returend from child component. 
    ```js
    // App.js
    class App extends React.Component {
        state = { videos: new Array, selectedVideo: null };

        onTermSubmit = async (term) => {
            const response = await youtube.get('/search', {
                params: {
                    q: term
                }
            });

            this.setState({ videos: response.data.items });
        }

        // catch data from event handler in child component
        onVideoSelect = (video) => {
            console.log('From the App!', video);
        }

        render() {
            return (
                <div className="ui container">
                    <SearchBar onFormSubmit={this.onTermSubmit} />
                    // pass callback function to the child component
                    <VideoList onVideoSelect={this.onVideoSelect} videos={this.state.videos} />
                </div>
            );
        };
    }
    ```
1. As the middleware, we receive the callback function `onVideoSelect` from `App`. We then pass this callback function into the child component `VideoItem` for the event handler.
    ```js
    // VideoList.js
    const VideoList = ({ videos, onVideoSelect }) => {
        const renderedList = videos.map((video) => {
            // pass onVideoSelect callback function into VideoItem
            return <VideoItem onVideoSelect={onVideoSelect} video={video} />;
        });

        return (
            <div className="ui relaxed divided list">{renderedList}</div>
        );
    }
    ```
1. In `VideoItem`, we receive the callback function in `props`, while we use constructuring assignment to assign the callback function to a variable `onVideoSelect`. 
1. However, we want to call the callback function with an argument. We need to use arrow function syntax to call the callback function with an argument.
1. Therefore, when the user clicks the `VideoItem` component, it will trigger the callback function and send the data back to `App` layer and update the `state` object.
    ```js
    // VideoItem.js
    const VideoItem = ({ video, onVideoSelect }) => {
        return (
            <div onClick={() => onVideoSelect(video)} className="video-item item">
                <img className="ui image" src={video.snippet.thumbnails.medium.url} />
                <div className="content">
                    <div className="header">{video.snippet.title}</div>
                </div>
            </div>
        );
    }
    ```

## Conditional Rendering
1. We can create another component to show the details of the video, so we have `VideoDetail.js` created in `component directory.
    ```js
    // VideoDetail.js
    import React from 'react';

    const VideoDetail = ({ video }) => {
        if (!video) {
            return <div>Loading...</div>
        }
        return (
            <div>{video.snippet.title}</div>
        );
    }

    export default VideoDetail;
    ```
1. We have to ensure that our `App` has updated its method to update its `state` when a video from the list is selected. Besides, we should render the `VideoDetial` component on the screen.
    ```js
    // App.js
    import VideoDetail from './VideoDetail';
    class App extends React.Component {
        state = { videos: new Array, selectedVideo: null };
        
        onVideoSelect = (video) => {
            this.setState({ selectedVideo: video });
        }

        render() {
            return (
                <div className="ui container">
                    <SearchBar onFormSubmit={this.onTermSubmit} />
                    <VideoDetail video={this.state.selectedVideo} />
                    <VideoList onVideoSelect={this.onVideoSelect} videos={this.state.videos} />
                </div>
            );
        };
    }
    ```

## Styling the VideoDetail
1. In this case, we use some classes from Semantic UI to style `VideoDetail`
    ```html
    <div>
        <div className="ui segment">
            <h4 className="ui header">
                {video.snippet.title}
            </h4>
            <p>{video.snippet.description}</p>
        </div>
    </div>
    ```
    <img src="./images/videoDetail.png">

## Displaying a Video Player
1. In thic case, we can use `iframe` to show the YouTube player in the list. 
1. To embed the video from YouTube, we can refer to the "share" button in each video to check how does `iframe` work with it. For very basic we can give the embeding URL from YouTube in the `iframe` tag.
    ```html
    <iframe src="https://www.youtube.com/embed/{videoId}" />    
    ```
1. There are some issues that we haven't fixed at this moment that 
    1. The video list should be on the side of the embeded video rather than downbelow in a regualr screen size. 
    1. The `state` is not updated when the user searches another video that the selected video shown in `VideoDetail` can be very different from those in the `VideoList` after giving another search.
    1. Some warnings are given by React that `key` property is not given to each component in the list. 
    1. `alt` property is not given to `img` element.
    1. `title` property to `iframe` tag.
    ```js
    // VideoDetails
    import React from 'react';

    const VideoDetail = ({ video }) => {
        if (!video) {
            return <div>Loading...</div>
        }

        const videoSrc = `https://www.youtube.com/embed/${video.id.videoId}`;

        return (
            <div>
                <div className="ui embed">
                    <iframe src={videoSrc} />
                </div>
                <div className="ui segment">
                    <h4 className="ui header">
                        {video.snippet.title}
                    </h4>
                    <p>{video.snippet.description}</p>
                </div>
            </div>
        );
    }

    export default VideoDetail;
    ```

## Fixing a Few Warnings
1. We add `title` property in `iframe` in `VideoDetail`. In this case, we can just specify what is inside the `iframe`, and it is `video player`.
1. Add `alt` property in `VideoItem` for each image tag. We can use `video.snippet.title` to indicate what is the image.
1. In `VideoList` each of the `VideoItem` in the list, which is rendered by an array of components, should have a `key` property. Therefore, we can use `video.id.videoId` from each video object to have unique for each of them.
    ```js
    // VideoDetail.js
    <iframe title="video player" src={videoSrc} />
    // VideoItem.js
    <img alt={video.snippet.title} className="ui image" src={video.snippet.thumbnails.medium.url} />
    // VideoList.js
    const renderedList = videos.map((video) => {
        return <VideoItem key={video.id.videoId} onVideoSelect={onVideoSelect} video={video} />;
    });
    ```
1. After fixing the warnings and issues prompted from developer console, we can adjust the layout to have `VideoDetail` and `VideoList` stay side by side on the same position on the page. In this case, we can use "[grid system](https://semantic-ui.com/collections/grid.html)" from Semantic UI.
    ```html
    <!-- app.js -->
    <div className="ui container">
        <SearchBar onFormSubmit={this.onTermSubmit} />
        <div className="ui grid">
            <div className="ui row">
                <div className="eleven wide column">
                    <VideoDetail video={this.state.selectedVideo} />
                </div>
                <div className="five wide column">
                    <VideoList
                        onVideoSelect={this.onVideoSelect}
                        videos={this.state.videos} />
                </div>
            </div>
        </div>
    </div>
    ```
    <img src="./images/semanticUIGrid.png">

## Default Video Selection
1. In the last optimization, we'd like to give a default search term when users firstly start to use the React App, so it can show the appropriate prompt to let users know what to do. 
1. Besides, an issue that after the user selects one of the video from the video list, the `state` is updated but doesn't go along when the user searches something else which can give an awkward user experience.
1. To have the default video rendered in the `VideoDetail`, we can update the `state` when we get response from a new search from YouTube API. We can update the video with the very first element in the returned array, so the video player will show the video by default when the user search for a topic.
1. After that we can use `componentDidMount` as a method in `App` class. We can call `this.onTermSubmit('default searching term')` in this case. Therefore, when users open the App, they will see the `Loading` in a moment, then after the App get response from AJAX call, the content will be udpated to the default search term that we give in `componentDidMount`. 
    ```js
    // App.js
    componentDidMount() {
        this.onTermSubmit('Thailand Travel');
    }

    onTermSubmit = async (term) => {
        const response = await youtube.get('/search', {
            params: {
                q: term
            }
        });

        this.setState({
            videos: response.data.items,
            selectedVideo: response.data.items[0]
        });
    }
    ```



# Understanding Hooks in React 
## React Hooks
1. Hook System
    1. `useState` is a function that lets you use `state` in a functional component.
    1. `useEffect` is a function that lets you use something like "**lifecycle methods**" in a functional component.
    1. `useRef` is a function that lets you create a `ref` in a function component.
1. Hooks are a way to write resuable code, instead of more classic techniques like Inheritance.
1. There is a list of 10 "**Primitive**" Hooks (which are defined by the lecturer and not officially called primitive hooks in React).
    1. `useState`
    1. `useEffect`
    1. `useContext`
    1. `useRender`
    1. `useCallback`
    1. `useMemo`
    1. `useRef`
    1. `useImperativeHandle`
    1. `useLayoutEffect`
    1. `useDebugValue`
1. We can use the pre-defined hooks and use `useTranslate` to create "**custom**" hooks for repeatable and reuseable code.

## App Architecture
1. The architecture of this App includes the followings components
    1. Accordion component
    1. Wikipedia API search component
    1. Dropdown item selection component
    1. Google Translate API component
1. In this case, we can send `items` props from `App` to `Accordion` to render the item on the screen. This `items` can be an array of `item` that includes `title` and `content` for the topic.
1. For `State`, as we have only a question and answer opened at the same time. When the user click a question, only an answer section will be expanded. 
1. Therefore, we can have a single `state` as `activeIndex` to show which `item` is activated (which the user selects or clicks). However, this `state` can be used in `Accordion` directly because no other component really cares the state of the expansion of component. We then set up 2 files in `src`, `App.js` and `index.js`.
    ```js
    // index.js
    import React from 'react';
    import ReactDOM from 'react-dom';
    import App from './App';
    ReactDOM.render(<App />, document.querySelector('#root'));

    // App.js
    import React from 'react';
    export default () => {
        return <h1>Widgets App</h1>;
    }
    ```

## Communicating the Items Prop
1. We create a mockup array in `App.js` and send it to `Accordion` component to render it on screen.
    ```js
    // App.js
    import React from 'react';
    import Accordion from './components/Accordion';

    const items = [
        {
            title: 'What is React?',
            content: 'React is a front end JavaScript framework'
        },
        {
            title: 'why use React?',
            content: 'React is a favorite JS library among engineers'
        },
        {
            title: 'How do you use React?',
            content: 'You use React by creating components'
        }
    ]

    export default () => {
        return (
            <div>
                <Accordion items={items} />
            </div>
        );
    }
    ```

## Building and Styling the Accordion
1. In this case, we use Semantic UI for styling. However, as the CSS library is very strict on the HTML element structure, if we use a `<div>` tag to wrap the contents inside, it will has 2 broder overlapping on the top.
1. We can use `React.Fragment` as the JSX componont to prevent it returning another `<div>` tag. This is because all the child component to be rendered in a component shall be wrapped by a `<div>` tag. This is also useful when we have component in a HTML table. 
1. According to new official [React documentation](https://zh-hant.reactjs.org/docs/fragments.html), we can even use an empty `<>` brackets to represent `React.Fragment`.
    ```js
    import React from 'react';
    const Accordion = ({ items }) => {
        const renderedItems = items.map(item => {
            return (
                <React.Fragment key={item.title}> // use React.Fragment to prevent border overlapping on the top
                    <div className="title active">
                        <i className="dropdown icon"></i>
                        {item.title}
                    </div>
                    <div className="content active">
                        <p>{item.content}</p>
                    </div>
                </React.Fragment>
            );
        });

        return (
            <div className="ui styled accordion">
                {renderedItems}
            </div>)
            ;
    }

    export default Accordion;
    ```

## Helper Functinos in Function Components
1. In function-based component, we can't add a method and call it as class-based component directly. However, in JavaScript, we can declare a function in nearly any scope. This function is a "helper function".
1. We then pass the function in an anonymous arrow function for `onClick` event handler.
1. Therefore, when the user clicks any of the item in the list, it will print the prompt and index of the item in the developer console.
    ```js
    // Accordion.js 
    const Accordion = ({ items }) => {
        const onTitleClick = (index) => {
            console.log('Title clicked', index);
        }

        const renderedItems = items.map((item, index) => {
            return (
                <React.Fragment key={item.title}>
                    <div
                        className="title active"
                        onClick={() => onTitleClick(index)} // use arrow function for the correct function scope and prevent the function is called when the app startup
                    >
                        <i className="dropdown icon"></i>
                        {item.title}
                    </div>
                    <div className="content active">
                        <p>{item.content}</p>
                    </div>
                </React.Fragment>
            );
        });

        return (
            <div className="ui styled accordion">
                {renderedItems}
            </div>)
            ;
    }
    ```

## Introducing useState
## Understanding useState
1. In class-based component, the flow can go as the followings
    1. Declare a `state` in the class and assign it an initial value.
    1. Declare a method that uses `setState` to update the property in `state`.
    1. Refer value of the `state` from `this.state`. 
1. To use React Hook, we firstly use destructuring assignment to get `useState` from React library. Remember that `useState` in React Hook system is to enable use to use `state` system in functional component.
1. We then declare 2 variables `activeIndex` and `setActiveIndex` by initiate `useState` as `null` with desctructuring assignment. Note that `useState` returns an array. Besides, as the desctructuring assignment are creating new variables, we can actually change the name for `activeIndex`, `setActiveIndex`, and the initial value for the `state` according to the scenario.
1. In the helper function `onTitleClick`, we call `setActiveIndex` with the lastest value send with `onClick` event handler. Note that `setActiveIndex` is a setter function. When it is called, React will render the component. 
    ```js
    import React, { useState } from 'react';

    const Accordion = ({ items }) => {
        const [activeIndex, setActiveIndex] = useState(null);

        const onTitleClick = (index) => {
            setActiveIndex(index);
        }

        const renderedItems = items.map((item, index) => {
            return (
                <React.Fragment key={item.title}>
                    <div
                        className="title active"
                        onClick={() => onTitleClick(index)}
                    >
                        <i className="dropdown icon"></i>
                        {item.title}
                    </div>
                    <div className="content active">
                        <p>{item.content}</p>
                    </div>
                </React.Fragment>
            );
        });

        return (
            <div className="ui styled accordion">
                {renderedItems}
                <h1>{activeIndex}</h1>
            </div>)
            ;
    }

    export default Accordion;
    ```
    <img src="./images/compareFlowClassAndFunctionalComponent.png">
1. In this case, the downside of functional component is obvious that functional component can't set or change multiple `state` properties at the same time as class-based components do.
    <img src="./images/flowClassAndFunctionalComponentMultipleState.png">

## Setter Functions
1. The setter function, which is the 2nd function variable declare from the destructuring array assignment, will update the property in the `state` as `setState` method for class-based component. 
1. In this case, `activeIndex` will be updated after `setActiveIndex` is called with an argument.

## Expanding the Accordion
1. As `activeIndex` state will be updated all the time when the user clicks on any of the item in the list, we want the CSS styling be updated aligned with the value change. 
1. With Semantic UI, the component will be shrinked or expanded with the class name `active` in this HTML structure.
1. Therefore, when `renderedItems` is rendered, the App should check if `index` matches `activeIndex` and assign the `active` class to the element. 
    ```js
    // Accordion.js
    const renderedItems = items.map((item, index) => {
        const active = index === activeIndex ? 'active' : ''; // check if index is equal to activeIndex. If yes, assign active class to the element 

        return (
            <React.Fragment key={item.title}>
                <div
                    className={`title ${active}`}
                    onClick={() => onTitleClick(index)}
                >
                    <i className="dropdown icon"></i>
                    {item.title}
                </div>
                <div className={`content ${active}`}>
                    <p>{item.content}</p>
                </div>
            </React.Fragment>
        );
    });
    ```

## Creating Additional Widgets
1. `Accordion` is only one of the widgets we create for this App. In this project, we have 4 main components. Each of them uses different functions in React Hook System.
    1. Accordion uses `useState`
    1. Search with a list of results uses `useState` and `useEffect`
    1. A dropdown input uses `useState`, `useEffect`, and `useRef`
    1. Translation function with a text input, dropdown input, and an output that uses `useState`, `useEffect`, and `useRef`.

## The Search Widget Architecture
1. The main feature of the "**search widget**" is to allow users to give input for a topic from Wikipedia API. Then the App will render a list of results.
1. Wikipedia API is relatively easy to use as it doesn't require authentication. We can just give a request with the topic that we want to search in `srsearch` property. Wikipedia will send us back a JSON.
    ```
    en.wikipedia.org/w/api.php?action=query&list=search&format=json&srsearch={SEARCHTERM}
    ```

## Scaffolding the Widget
1. We create another component `Search.js` in the directory. 
1. In this case, as we haven't built the navigation bar on the top, users can't switch between the widgets in the App, so we just comment `<Accordion>` component in `App.js`.
    ```js
    // /component/Search.js
    import React from 'react';
    const Search = () => {
        return <h1>Search</h1>;
    }
    export default Search;
    ```

## Text Inputs with Hooks
1. Note that we **DO NOT** have any submit button for users to click for the search term. Therefore, we will make API call every time when there's a changing event in the input element. Though this is very inefficient for API calls, we will optimize and solve this problem later.
1. In this case, we just ensure that we have the inital setup for the App and doesn't have any error returned. 
1. There are 2 ways we can make to make API calls to the endpoint.
    ```js
    import React, { useState } from 'react';

    const Search = () => {
        const [term, setTerm] = useState('');

        return (
            <div>
                <div className="ui form">
                    <div className="field">
                        <label>Enter Search Term</label>
                        <input
                            className="input"
                            value={term}
                            onChange={(e) => setTerm(e.target.value)}
                        />
                    </div>
                </div>
            </div>
        );
    }

    export default Search;
    ```

## When do we Search?
1. There are 2 options to make API calls.
    1. Option 1
        1. User types in input
        1. `onChange` event handler called
        1. We take value from input and make request to API
        1. **Wait for response from the endponit**
        1. Get response from the endpoint
        1. Update '`results`' piece of `state`
        1. Component rerenders, we show list of results
    2. Option 2
        1. User types in input
        1. `onChange` event handler called
        1. Update '`term`' piece of `state`
        1. Component rerenders
        1. We add code to detect that '`term`' has changed
        1. Make request to API
        1. **Wait for response from the endpoint**
        1. Get response
        1. Update '`results`' piece of state
        1. Component rerenders, we show list of results
1. In Option 1, 
    1. Search instantly when `onChange` event triggers
    1. Tightly couples '`onChange`' event with search
1. In option 2, 
    1. Search when `'term'` piece of state changes
    1. Can easily trigger a search when other parameters change
    1. Easier to extract code out into a more reusable function
1. By using option 1, the search when fire every time when the user put some thing in the input, even though it is just a single character. This is not really efficient and can give too many requests to the endpoint that can affect user experience.
1. Therefore, we can use option 2 and check if everything is ready and make the API call. 

## The useEffect Hook
1. `useEffect` hook allows function components to use _something like_ lifecycle methods
1. We configure the hook to run some code automatically in one of three scenarios
    1. When the component is rendered **for the first time only**
    1. When the component is rendered **for the first time and whenever it rerenders**
    1. When the component is rendred **for the first time and whenever it rerenders and some piece of data has changed**
1. Note that though `useEffect` hook is similar to lifecycle methods such as `componentDidMount`, it doesn't work exactly the same that this pre-set methods, such as `componentWillMount` have no meaning to functional components. 
1. We then can use destructuring assignemnt to import it as `useState`. Then we can pass an anonymous arrow function that is code we want to run in the scenarios.
1. The 2nd argument for `useEffect` for the 3 scenarios are 
    1. `[]` that is an "empty array" that runs only at initial render.
    1. "nothing" (which means there's no 2nd argument) to run at inital render and run after eery rerender.
    1. "an array of elements" to run at initial render and run after every rerender if data has changed since last render.
    <img src="./images/useEffect2ndArg.png">

    ```js
    const Search = () => {
        const [term, setTerm] = useState('');

        useEffect(() => {
            console.log('useEffect');
        }, []);

        return (
            <div>
                <div className="ui form">
                    <div className="field">
                        <label>Enter Search Term</label>
                        <input
                            className="input"
                            value={term}
                            onChange={(e) => setTerm(e.target.value)}
                        />
                    </div>
                </div>
            </div>
        );
    }
    ```

## Testing Execution
1. In this case, as `term` is the `state` set for the component, it will change every time when the user gives something to the input. 
1. Therefore, giving no 2nd argument and give the array with `[term]` actually work the same in this case.
1. On the other hand, if we pass an empty array as the 2nd argument, the code will only be triggered once. 
1. In most of the cases, we will use scenarios with an empty array or array of elements. We rarely don't pass any argument. 

## Async Code in useEffect
1. We can use `axios` to make API request in this case. The purpose of this `Search` widget it to fire a GET request to Wikipedia endpoint every time the user gives value to input. 
1. For functional component in React, we can't mark a function `async` if it is to be passed to `useEffect` as a callback function. However, we have several solutions for the case. In this case, we will use the fist option that is have a function variable.
    1. Have another function variable and declare it as `async`.
        ```js
        useEffect(() => {
            const search = async() => {
                await axios.get('url');
            }
            search();
        }, [term])
        ```
    1. Use JavaScript `IIFE` to execute an anonymous function immediately after it's declared. 
        ```js
        useEffect(() => {
            (async () => {
                await axios.get()
            })();
        }, [term]);
        ```
    1. Use regular `Promise` syntax to work on the response.
        ```js
        useEffect(() => {
            axios.get('url')
                .then((response) => {
                    console.log(response.data);
                });
        }, [term]);
        ```

## Executing the Request from useEffect
1. We use `axios` to make GET request to Wikipedia endpoint. Note that in the 2nd parameter as the object that passed to `axios` to make the call, we only need to have `params` to send the parameters as those in URLs if we access it from browser search bar. This is tricky that as modern website as `CORS` security that if the configure isn't correct, the request will be blocked and somehow it's now easy to figure out the issue. 
    ```js
    // components/Search.js
    useEffect(() => {
        const search = async () => {
            await axios.get('https://en.wikipedia.org/w/api.php', {
                params: {
                    action: 'query',
                    list: 'search',
                    origin: '*',
                    format: 'json',
                    srsearch: term,
                },
            });
        }
        search();
    }, [term]);
    ```

## Default Search Terms
1. With an array that has element in it, the setter function from React Hook system will render when the component is rendred **for the first time and whenever it rerenders and some piece of data has changed**.
1. Therefore, we may have 2 options for the inital value for `term` state. 
    1. Give a string value as default, so users can see a search result of a given term by default.
    1. Use `if` statement to check if `term` is given by the user and not empty, so the `axios` request won't be triggered in the initial stage when there's no thing given for `term`.
1. In this case, we can set a default string for users to check when they firstly access the App.

## List Building
1. After we get the response from the API call, we can create an array with `.map` method and render it on teh screen.
1. Note that when creating array of components in a list, we need to add `key` property.
1. However, Wikipedia API gives another feature to provide HTML tags in its contents, which can't be used directly and doesn't look good. 
    ```js
    // Search.js
    const Search = () => {
        const [term, setTerm] = useState('programming');
        const [results, setResults] = useState([]);

        console.log(results);

        useEffect(() => {
            const search = async () => {
                const { data } = await axios.get('https://en.wikipedia.org/w/api.php', {
                    params: {
                        action: 'query',
                        list: 'search',
                        origin: '*',
                        format: 'json',
                        srsearch: term,
                    },
                });

                setResults(data.query.search);
            }
            search();
        }, [term]);

        const renderedResults = results.map((result) => {
            return (
                <div key={result.pageid} className="item">
                    <div className="content">
                        <div className="header">
                            {result.title}
                        </div>
                        {result.snippet}
                    </div>
                </div>
            );
        })

        return (
            <div>
                <div className="ui form">
                    <div className="field">
                        <label>Enter Search Term</label>
                        <input
                            className="input"
                            value={term}
                            onChange={(e) => setTerm(e.target.value)}
                        />
                    </div>
                </div>
                <div className="ui celled list">{renderedResults}</div>
            </div>
        );
    }
    ```

## XSS Attacks in React
1. As the endpoint returning us contents with HTML tags, we can consider render the content as HTML directly.
1. In React, we actually have a way to render the HTML content received from another endpoint directly though this **IS NOT** recommended because this will be a security hole for the App. This is called `XSS` attack which stands for "**Cross Site Scripting**". This will allow others to run JavaScript in the App.
1. The syntax is to use `<span>` tag with a property `dangerouslySetInnerHTML` and give it an object with `__html` property.
    ```js
    // Search.js
    const renderedResults = results.map((result) => {
        return (
            <div key={result.pageid} className="item">
                <div className="content">
                    <div className="header">
                        {result.title}
                    </div>
                    // use dangerouslySetInnerHTML to render HTML contents directly
                    <span dangerouslySetInnerHTML={{ __html: result.snippet }}></span>
                </div>
            </div>
        );
    })
    ```
1. Therefore, we can only use this if the source of code is trustworthy. However, this is still not recommended to use.

## XSS Server Code
1. This is the code to set up a simple server to simulate XSS attack to the website. 
1. If you run the mini server and connect to the endpoint, we can press "t" in the search bar and see the result that the endpoint can inject code to control over the website or App which can steal sensitive user info.

## Linking to a Wikipedia Page
1. As we import and render teh snippet from Wikipedia endpoint, we'd like to create a button on the right to allow users to click and direct to Wikipedia for the full contents.
    ```js
    // Search.js
    const renderedResults = results.map((result) => {
        return (
            <div key={result.pageid} className="item">
                <div className="right floated content">
                    // add a new button
                    <a
                        className="ui button"
                        href={`https://en.wikipedia.org?curid=${result.pageid}`}
                    >
                        Go
                    </a>
                </div>
                <div className="content">
                    <div className="header">
                        {result.title}
                    </div>
                    <span dangerouslySetInnerHTML={{ __html: result.snippet }}></span>
                </div>
            </div>
        );
    });
    ```
1. However, at this point, the App still has some issue that when the user delete all the value in the input search bar, this React app will return an error because nothing can be searched or rendered. 
1. Remember that we fire the search request to Wikipedia all the time when user is typing something in the input search bar. 
1. Therefore, we'd like to improve the App that it only fire a request when the user has finished typing to improve efficiency, reduce workload, and prevent possible issues.

## Only Search with a Term
1. We can apply a relatively easy solution to prevent `search()` function fires when there's no text in the search bar.
1. However, this still hasn't prevent the app fire search request every time when the user types something in the search bar.
    ```js
    useEffect(() => {
        const search = async () => {
            const { data } = await axios.get('https://en.wikipedia.org/w/api.php', {
                params: {
                    action: 'query',
                    list: 'search',
                    origin: '*',
                    format: 'json',
                    srsearch: term,
                },
            });

            setResults(data.query.search);
        }

        // fire search function only when term is not empty
        if (term) {
            search();
        }
    }, [term]);
    ```

## Throttling API Requests
1. In this case, we can set a function to check and wait for every `500ms` to fire the search request if the user does typing and stop. Note that this time gap for waiting can be set arbitrarily.
    <img src="./images/setTimerFlowThrottle.png">

## Reminder on setTimeout
1. We can use `setTimeout` API in JavaScript to delay the search request. 
1. Every time the user types something, `setTimeout` API will create an async task in queue. Besides, we will cancel the time delay if this `setTimeout` is called again.
1. When execute `setTimeout`, it will return a number that we can use it with `clearTimeout` to cancel the execution.
1. Note that there are 2 ways we can solve this issue,
    1. We can use `state` to track on the condition of execution.
    1. We can use `useEffect` hook to cancel it.

## useEffect's Cleanup Function
1. Remember that `useEffect` works as lifecycle methods for components. In the current setting, we pass the 2nd argument as an array with element(s). Therefore, this `useEffect` will be triggered when the App initiates and every time the element(s) in the given array is changed.
1. In addition, this `useEffect` function is only allowed to "**execute functions inside**" (as to fire search request and update `state`) or return another function.
1. Keep in mind that `useEffect` is only allowed to return a "**function**" rather than any other type of value. This returned function will be handled by React and be called sometime in the future in certain condition.
1. This returned function will be triggered when the `state` is updated again. Then the `useEffect` will be executed once again. The flow is as 
    1. App initate and run `useEffect` first time for initial render. The returned function from `useEffect` is held and does nothing.
    1. When the user gives any input or change in the search bar, which update the `state` and rerender the component, returned function will be fired.
    1. After the returned function executed, `useEffect` will run and return the function to standby once again (as the feature of server that standing by and listening to request all the time).
    <img src="./images/useEffectReturnFunction.png">

## Implementing a Delayed Request
1. We then can add and return an arrow function to cancel the `setTimeout` by `clearTimeout`. Note that as the functions are in the same scope, we can catch the `setTimeoutId` directly. 
1. Therefore, this will cause an delay to fire the search request every time when users type in the search bar. 
1. This can reduce number of times that the App sending request to the endpoint, as it only works when the user finishes typing or if the user types slowly. Besides, we can even increase the delay time from `500ms` to `1000ms` as 1 second.
    ```js
    // Search.js
    useEffect(() => {
        const search = async () => {
            const { data } = await axios.get('https://en.wikipedia.org/w/api.php', {
                params: {
                    action: 'query',
                    list: 'search',
                    origin: '*',
                    format: 'json',
                    srsearch: term,
                },
            });

            setResults(data.query.search);
        }

        const timeoutId = setTimeout(() => {
            if (term) {
                search();
            }
        }, 500);

        return () => {
            clearTimeout(timeoutId);
        }
    }, [term]);
    ```
1. Though this has solved the problem and prevent sending requests to the endpoint very often, we have another issue that this will give another delay when the App initiates. The App will be delayed for the initial search at the beginning as well.

## Searching on Initial Render
1. We can use an `if` statement to check if the App is on the initla run. For example, if `term` has value and `results.length` is 0, it means we haven't got any response from the request call. Therefore, we can consider this as the inital stage of the App and do not run `setTimeout`. 
    ```js
    // Search.js
    useEffect(() => {
        const search = async () => {
            const { data } = await axios.get('https://en.wikipedia.org/w/api.php', {
                params: {
                    action: 'query',
                    list: 'search',
                    origin: '*',
                    format: 'json',
                    srsearch: term,
                },
            });

            setResults(data.query.search);
        }

        if (term && !results.length) {
            search();
        } else {
            const timeoutId = setTimeout(() => {
                if (term) {
                    search();
                }
            }, 500);

            return () => {
                clearTimeout(timeoutId);
            }
        }
    }, [term]);
    ```

## Edge Case When Clearing Out Input Form
## Optional Video - Fixing a Warning
1. From the previous section, we get a warning from React that "**React Hook `useEffect` has a missing dependency: 'results.length'**".
1. This is because when we decalre `useEffect` function, we didn't pass `results` as an element in the 2nd argument which is the array.
1. Without referring the `state` properties properly, the App may have some hard to debug issues or problems which are not easy to find. Therefore, the `ESlint` in React warns the programmer to correctly refer to the dependecies when using `useEffect`. 
    ```js
    // Search.js
    useEffect (() => {
    }, [term]);
    ```
1. We could consider to add `results.length` in this case to resolve the warning in developer console. However, this leads us to another bug that having 2 elements in the array will make the app fires request twice.
1. In this app, we have an `if` statement to check and fire the initial search when `term` has value and `results.length` is `0`. However, after we get the response from the request call, `results` is updated, so the `useEffect` is triggered and run the code with `setTimeout` once which makes another request to the endpoint. 
    <img src="./images/componentRenderingFlowWithUseEffect.png">
1. Therefore, if we'd like to solve the issue by preventing sending the 2nd request and provide the dependency in the array, we need to restructure the search code.
1. In this case, we will set up 2 `useEffect` functions and create another `state` as `debouncedTerm`. Each of the `useEffect` function focus and run on different `state`. One watches over `term`, and the other watches over `devouncedTerm`. However, we are now going to modify the workflow of the app. 
    1. For the `useEffect` that watches over `debouncedTerm`, it will proceed on the data fetching request to the endpoint and will be initiated when the app starts.
    1. When the user types something, `term` in the `state` will be updated by the other `useEffect`. Besides, this `useEffect` function will set a timer to upadte `debouncedTerm`.
    1. If the user hasn't finished typing and before the timer stops, this `useEffect` will be triggered and cancel the previous timer, updates `term` in `state`, and set a new timer to `debouncedTerm` again.
    1. When the user stops for `500ms`, or the timer runs out, `debouncedTerm` in state will be updated and be set to the same value as that in `term`. 
    1. When `state` updates, the component will be rerendered. 
1. As we have initial value for `term` state from the beginning, `term` is assigned to `debouncedTerm`, so `useEffect` for `debouncedTerm` can fire immediately and send a request to fetch data when the app initiates. After that, the app works as the flow shown below that `debouncedTerm` will only be updated if the user change the vaule in input search bar and stop typing for more than `1000ms`, which is the given time gap in this case.
    <img src="./images/useDebounceTerm169.png">
    <img src="./images/useDebounceTerm169_2.png">
    ```js
    // Search.js
    const Search = () => {
        const [term, setTerm] = useState('programming');
        const [debouncedTerm, setDebouncedTerm] = useState(term);
        const [results, setResults] = useState([]);

        useEffect(() => { // useEffect for term state
            const timerId = setTimeout(() => { // delay the function if the user is still styping
                setDebouncedTerm(term);
            }, 1000);

            return () => { // return a function and cancel setTimeout if the user keeps typing
                clearTimeout(timerId);
            }
        }, [term]); // initiate when the component is firstly rendered and whenever 'term' is udpated

        useEffect(() => { // useEffect for debouncedTerm state
            const search = async () => { // request to wikipedia endpoint with axios 
                const { data } = await axios.get('https://en.wikipedia.org/w/api.php', {
                    params: {
                        action: 'query',
                        list: 'search',
                        origin: '*',
                        format: 'json',
                        srsearch: term,
                    },
                });

                setResults(data.query.search); // update results state
            }

            search();
        }, [debouncedTerm]); // initiate when the component is firstly rendered and whenever 'debouncedTerm' is udpated

        const renderedResults = results.map((result) => {
            return (
                <div key={result.pageid} className="item">
                    <div className="right floated content">
                        <a
                            className="ui button"
                            href={`https://en.wikipedia.org?curid=${result.pageid}`}
                        >
                            Go
                        </a>
                    </div>
                    <div className="content">
                        <div className="header">
                            {result.title}
                        </div>
                        <span dangerouslySetInnerHTML={{ __html: result.snippet }}></span>
                    </div>
                </div>
            );
        });

        return (
            <div>
                <div className="ui form">
                    <div className="field">
                        <label>Enter Search Term</label>
                        <input
                            className="input"
                            value={term}
                            onChange={(e) => setTerm(e.target.value)}
                        />
                    </div>
                </div>
                <div className="ui celled list">{renderedResults}</div>
            </div>
        );
    }
    ```

## Dropdown Architecture
1. We will use `useState`, `useEffect`, and `useRef` hooks for this widget. 
1. The widget has a dropdown list for users to select a desirable color which will change the color of the content below.
1. This feature should be reuseable that it accepts `props` rather than `state` which will update and rerender the components.
1. In this project, we will pass down 
    1. `options` as `props` which is an array of objects that has `label` and `value` that provides options for users to select from `App` to `Dropdown`.
    1. A `selection` as `state` from `App` to `Dropdown` to tell what the user selects.
    ```js
    const options = {
        label: 'The Color Red', 
        value: 'red'
    }
    ```

## Scaffolding the Dropdown
1. We create `Dropdown.js` in components directory and have it with simple boilerplate.
    ```js
    // Dropdown.js
    import React from 'react';

    const Dropdown = () => {
        return <h1>Dropdown</h1>
    }

    export default Dropdown; 

    // App.js
    import React from 'react';
    import Dropdown from './components/Dropdown';
    const options = [
        {
            label: 'The Color Red',
            value: 'red'
        },
        {
            label: 'The Color Green',
            value: 'green'
        },
        {
            label: 'A Shade of Blue',
            value: 'blue'
        }
    ];

    export default () => {
        return (
            <div>
                <Dropdown options={options} />
            </div>
        );
    }
    ```

## A Lot of JSX
1. We create the layout with Semantic UI classes for the user interface as a dropdown list. 
1. Note that part of the HTML structure can be refined such as in `<label>` tag, the content is hard coded that this list can only be used with selecting colors. 
1. Besides, the dropdown list is opened by default.
    ```js
    // Dropdown.js
    const Dropdown = ({ options }) => {
        const renderedOptions = options.map((option) => {
            return (
                <div key={option.value} className="item">
                    {option.label}
                </div>
            );
        });
        return (
            <div className="ui form">
                <div className="field">
                    <label className="label">Select a Color</label>
                    <div className="ui selection dropdown visible active">
                        <i className="dropdown icon"></i>
                        <div className="text">Select Color</div>
                        <div className="menu visible transition">
                            {renderedOptions}
                        </div>
                    </div>
                </div>
            </div>
        );
    }
    ```
    <img src="./images/dropdownJSX173.png">

## Selection State
1. We create a `state` in `App` to keep tracking that which color is selected by the user.
1. Having this structure is because that we may have multiple dropdown lists for users to select different properties. For example, one `Dropdown` is used for selecting `color`, while the other can be used for `size` or `country` according to the App requirements.
1. We use `useState` in App to create `state` to collect what users has selected and pass it to `Dropdown` component as `props`.
    ```js
    // App.js
    import React, { useState } from 'react';
    export default () => {
        const [selected, setSelected] = useState(options[0]);

        return (
            <div>
                <Dropdown
                    selected={selected}
                    onSelectedChange={setSelected}
                    options={options}
                />
            </div>
        );
    }
    ```
1. In `Dropdown` component, we can import `props` with destructuring assignments.
1. In each item in the list, we can use `onClick` event handler to hire `onSelectedChange` to send the value back to `App`, which will then update `selected` `state` and rerender the component.
1. Note that we can refine the UI as in this case, the list will still show have the user has selected. It would be confusing for users to see the same option and think it can be selected twice. Therefore, we can make a filter to remove the selected item from the options if it's selected.
    ```js
    // Dropdown.js
    const Dropdown = ({options, selected, onSelectedChange}) => {
        const renderedOptions = options.map((option) => {
            return (
                <div
                    key={option.value}
                    className="item"
                    onClick={() => onSelectedChange(option)} // handling click event when the user selects any item from the list and send it back to App
                >
                    {option.label}
                </div>
            );
        });

        return (
            <div className="ui form">
                <div className="field">
                    <label className="label">Select a Color</label>
                    <div className="ui selection dropdown visible active">
                        <i className="dropdown icon"></i>
                        <div className="text">{selected.label}</div> // change hard-coded label with options for users to select
                        <div className="menu visible transition">
                            {renderedOptions}
                        </div>
                    </div>
                </div>
            </div>
        );
    }
    ```

## Filtering the Option List
1. To filter the selected option and remove it from the list, we can use an `if` statement to check the current `selected` and return `null` in the array through `.map` method, so the item will be "removed" as the element becomes `null`.
    ```js
    const renderedOptions = options.map((option) => {
        if (option.value === selected.value) { // return null when creating the new array if the item is the same as selected value
            return null;
        }

        return (
            <div
                key={option.value}
                className="item"
                onClick={() => onSelectedChange(option)}
            >
                {option.label}
            </div>
        );
    });
    ```

## Hiding and Showing the Option List
1. In the current state, the dropdown list is opened by default. The `dropdown` menu current has `visible`, `active`, and `trasition` class which make the list opens.
    ```html
    <div className="ui form">
        <div className="field">
            <label className="label">Select a Color</label>
            <div className="ui selection dropdown visible active"> <!-- this makes the dropdown list open -->
                <i className="dropdown icon"></i>
                <div className="text">{selected.label}</div>
                <div className="menu visible transition"> <!-- this makes the dropdown list open -->
                    {renderedOptions}
                </div>
            </div>
        </div>
    </div>
    ```
1. To enable toggling the dropdown list, we can create another state to track on the status of the dropdown list. In this case, the `state` can be simple that just be `true` when the list opens, and `false` when it is closed.
1. We then use ternary operator to return the classes according to the `state`, so it will be either with the aligned classes or just empty string as to cancel the styling on the element. 
1. Note that we can improve the user experience to allow users to close the dropdown list out of the whole list element. In this case, the list can only be toggled by clicking on the list element directly. 
1. However, in convention, most of the apps will allow users to close the list container if they click or tap somewhere else out of the element. Note that this is an advanced feature which is a little bit challenging.
    ```js
    // Dropdown.js
    import React, { useState } from 'react';
    const Dropdown = () => {
        const [open, setOpen] = useState(false);

        return (
            <div className="ui form">
                <div className="field">
                    <label className="label">Select a Color</label>
                    <div
                        onClick={() => setOpen(!open)}
                        // use ternary operator to check the state and return aligned classes
                        className={`ui selection dropdown ${open ? 'visible active' : ''}`}
                    >
                        <i className="dropdown icon"></i>
                        <div className="text">{selected.label}</div>
                        // use ternary operator to check the state and return aligned classes
                        <div className={`menu ${open ? 'visible transition' : ''}`}>
                            {renderedOptions}
                        </div>
                    </div>
                </div>
            </div>
        );
    }
    ``` 

## Err... Why is this Hard?
1. In this section, we are going to reason about how to allow users to click any area out of the list component and close the expanded dropdown list. 
1. One of the challenge is that event handlers can only be added to the component and its child element, while it can't add event handler to its parent or parallel elements or components.
1. Therefore, we can't add event listener to other elements on the screen to handle the click event directly. 

## Reminder on Event Bubbling
1. When a event handler catches an event to an element that has the event listener, JavaScript will create an event object which will travel up to its parents until the root element, which usually is the `<html>` tag. This event is called `event bubbling`. Along the way, if any of the element has event handler for '`click`', it will also be triggered. 
1. This event bubbling phenomenon occurs in the current app, as if a user clicks any item in the dropdown list to select a color, the dropdown list will close.
1. This is because the event objects floats up and trigger the `onClick` event handler of the dropdown list. As the handler is triggered, the dropdown list is toggled. 
    <img src="./images/eventBubbling177.png">

## Applying What We've Learned
1. The `Dropdown` needs to detect a click event on **_any element besides one_** it created.
1. The `Dropdown` has a hardtime setting up event handlers on elements that it does not create.
1. Event bubbling can be used in the case. 
1. Therefore, the Dropdown can set up a manual event listener (without React) on the `body` element. Note that a "click" on **_any element_**  will bubble up to the boddy. 

## Binding an Event Handler
1. We set up event handler for body with `useEffect` and the function to add an event listener to body in the initial case. Therefore, we use `useEffect` with an empty array as the 2nd argument. Note that after React v17, we need to have 2nd argument, an object `{ capture: true }` to `addEventListener` method. We can check more information at [JavaScript Info](https://javascript.info/bubbling-and-capturing#capturing)
1. However, the current solution is still buggy that the dropdown list won't be closed after users select an item from the list. 
    ```js
    import React, {useState, useEffect} from 'react';
    
    useEffect(() => {
        document.body.addEventListener('click', () => { // add an event listener to body
            setOpen(false);
        }, { capture: true }); // add { capture: true } if using react v17
    }, []);
    ```

## Why Stay Open
1. The manually added event listener is added to the `<body>` tag directly and will be triggered before event handlers created in React app. We can add `console.log()` in each event handler to check the order that each event handler is executed. 
1. When click on the dropdown list directly, we can check from developer console that the order of the execution is 
    1. body
    1. item 
    1. list    
    ```js
    // Dropdown.js
    const Dropdown = ({ options, selected, onSelectedChange }) => {
        const [open, setOpen] = useState(false);

        useEffect(() => {
            document.body.addEventListener('click', () => {
                console.log('body click');
                setOpen(false);
            }, { capture: true });
        }, []);
    }
    ```
    <img src="./images/OrderEventHandlerExecution180.png">

## Which Element Was Clicked?
1. In the current stage, we have 2 main scenarios to focus
    1. Scenarios 1
        1. User clicks on an element that is created by the `Dropdown` component.
        1. If a user clicks on one of these elements, then we probably **_don't want the body event listener to do anything_**.
    1. Scenario 2
        1. User clicks on any element besides the ones created by the `Dropdown`.
        1. If a user clicks on any of these elements, we **_do want the body event listener to close the dropdown_**.
1. In the callback function of the event listener, we can have an argument as the `event` object. We then can check with `event.target` to learn which element in the HTML document does the user click. 
1. Therefore, we can use `useRef` hook which is similar to `ref` system for class-based React components.
1. In this case, we will add a `ref` to `<div className="ui form">`, then we can check if the element we click on is inside the referred element or not to decide whether to trigger a function to close the dropdown list. 

## Making use of useRef
1. We can use `console.log(ref.current)` to check what's the current object that `ref` refers to. Note that console will print `undefined` when the app firstly renders because at the time the component is not on the screen yet. After that, every time the `state` changes (when the component is rerendered), the console will print the whole `Dropdown` component.
1.  We then can give the condition with `if` statement in `useEffect` to check if the clicked object is in the `Dropdown component`. If yes, we can use `return` to stop the function immediately before it turn `open` state into `false`. After the component is toggled, the dropdown list will work as expected.
    ```js
    // Dropdown.js
    const Dropdown = ({ options, selected, onSelectedChange }) => {
        const [open, setOpen] = useState(false);
        const ref = useRef();

        useEffect(() => {
            document.body.addEventListener('click', (event) => {
                // use both ref.current && ref.current.contains(event.target) if using React v17
                if (ref.current && ref.current.contains(event.target)) {
                    return;
                }
                setOpen(false);
            }, { capture: true });
        }, []);

        // console.log(ref.current); // check what's the object that ref refers to
        return (
            <div ref={ref} className="ui form"></div>
        );
    }
    ```

## Body Event Listener Cleanup
1. In the case that if we want to toggle the whole `Dropdown` component in `App`, we can add a button and refactor the `App`.
1. We create a new `state` `showDropdown` and set its default to be `true`, as we want the `Dropdown` component show on the screen by default. 
1. When users click the button, the `showDropdown` state will be toggled, and we can use ternary operator to decide whether to show `Dropdown` component.
1. However, this will cause an error that after we click the button to hide the whole `Dropdown` component, if we click anywhere on the screen it will cause an error says "`TypeError: Cannot read property 'contains' of null`".
1. This is beacause when we hide the component, the manual event listener is still added to body. However, its callback function is checking to `ref.current` which has nothing, as `Dropdown` component is not rendered in `App`. 
    ```js
    // App.js
    () => {
        const [selected, setSelected] = useState(options[0]);
        const [showDropdown, setShowDropdown] = useState(true);

        return (
            <div>
                <button onClick={() => setShowDropdown(!showDropdown)}>Toggle Dropdown</button>
                {/* <Accordion items={items} /> */}
                {/* <Search /> */}
                {showDropdown ?
                    <Dropdown
                        selected={selected}
                        onSelectedChange={setSelected}
                        options={options}
                    /> : null
                }
            </div>
        );
    }
    ```
1. In this case, we need to refactor the `useEffect` and return a function to remove the event listener added to document body. 
1. Assign the callback function as a variable, so we can use `removeEventListener` method to delete it. In this case, we create a variable `onBodyClick`. 
1. Return a function with `useEffect` which can be triggered in 2 scenario according to React official doc about [Using the Effect Hook](https://reactjs.org/docs/hooks-effect.html#example-using-hooks-1).
    1. React performs the cleanup when the component unmounts.
    1. The function runs both after the first render and after every update.
1. Therefore, when the component is removed, the returned function will fire and remove the event listener on `body`. 
    ```js
    // Dropdown.js
    useEffect(() => {
        const onBodyClick = (event) => {
            if (ref.current && ref.current.contains(event.target)) {
                return;
            }
            setOpen(false);
        }

        document.body.addEventListener('click', onBodyClick, { capture: true });

        return () => { // this function will be triggered when the component is going to be rerendered or when the component is removed
            document.body.removeEventListener('click', onBodyClick);
        };
    }, []);
    ```

## The Translate Widget
1. In this widget, the user can 
    1. Input some text into the text bar to search.
    1. Select a language from dropdown list to translate the given text.
1. The app will then render the translated text as the output. 
1. In this case, we have `Translate` as the main component which is the responsible to handle all the views, take the input and render the output. 
1. In `Translate`, we will have a `Dropdown` that gives the `options` for language translation. The `options` is an array of `objects` (similar to the color object in the previous widget).
1. For this widget, we can use the same exact `Dropdown` component that we made for color changing widget.
    <img src="./images/translateWidgetStructure185.png">

## Scaffolding the Translate Component
1. Since we are going to use language translation API, the `value` from the `options` array is important that we should refer to the requiremetns and syntax of the API.q
1. We firstly build up the structure of the `Translate` component. As we are using `Dropdown` component here directly, we should follow its syntax and pass `state` and `setState` functions accordingly.
    1. `selected` will be the `language` `state` which we set as the first element in the array by default.
    1. `onSelectedChange` is the callback function to update `state` when the user selects any item from the `Dropdown` menu, so it can send the `state` back to its parent component. 
1. Note that we still have some issues here that the label for `Dropdown` component was hard-coded for color changing widget, so it still shows "select a color" by default. 
    ```js
    // /components/Translate.js
    import React, { useState, useEffect, useRef } from 'react';
    import Dropdown from './Dropdown';

    const options = [
        {
            label: 'Afrikaans',
            value: 'af'
        },
        {
            label: 'Arabic',
            value: 'ar'
        },
        {
            label: 'Hindi',
            value: 'hi'
        }
    ]

    const Translate = () => {
        const [language, setLanguage] = useState(options[0]);

        return (
            <div>
                <Dropdown selected={language} onSelectedChange={setLanguage} options={options} />
            </div>
        );
    };

    export default Translate;
    ```
    <img src="./images/scaffoldingTranslateComponent186.png">

## Adding the Language Input
1. We create `text` `state` to track on the user' input from the `input` tag and use some HTML elements from semantic UI to style the elements.
1. As in other projects, we can pass an anonymous arrow function to handle the event and take the user input every time there's new value given in the tag. 
    ```js
    const Translate = () => {
        const [language, setLanguage] = useState(options[0]);
        const [text, setText] = useState('');

        return (
            <div>
                <div className="ui form">
                    <div className="field">
                        <label>Enter Text</label>
                        <input value={text} onChange={(e) => setText(e.target.value)} type="text" />
                    </div>
                </div>
                <Dropdown
                    label="Select a Language"
                    selected={language}
                    onSelectedChange={setLanguage}
                    options={options}
                />
            </div>
        );
    };
    ```

## Understanding the Convert Component
## Google Translate API Key
1. In `Translate` widget, we will pass both `text` and the `language` that the user wants to translate to the sub component `Convert`. Therefore, we can use `useEffect` hook to handle the request.
    1. A new value for `language` or `text` has appeared! We should convert it and show the output.
    1. Make request to Google Translate API
    1. Update `state` with data from response 
    1. Show data from response on the screen
1. For the parameters, we can refer to [Google Cloud Translate API and Reference](https://cloud.google.com/translate/docs/reference/rest/v2/translate). In this case, we will use the following parameters and send it to Google Translate API endpoint with `POST` request. 
    1. `q` is the term that we want to translate
    1. `target` is the language that we want to translate to
    1. `key` is the authentication key to use the API. 
1. The authentication key is given by the course and can only be used to call from `localhost:3000`.

## Building the Convert Component
1. We create another component `Convert`. 
    ```js
    // component/Convert.js
    import React, { useState, useEffect } from 'react';

    const Convert = ({ language, text }) => {
        useEffect(() => {
            console.log("new language or text");
        }, [language, text]);

        return (
            <div></div>
        );
    }

    export default Convert
    ```
1. We need to pass `language` and `text` through property system from `Translate` to `Convert`.
    ```html
    <!-- Translate.js -->
    <div>
        <div className="ui form">
            <div className="field">
                <label>Enter Text</label>
                <input value={text} onChange={(e) => setText(e.target.value)} type="text" />
            </div>
        </div>
        <Dropdown
            label="Select a Language"
            selected={language}
            onSelectedChange={setLanguage}
            options={options}
        />
        <hr />
        <h3 className="ui header">Output</h3>
        <Convert text={text} language={language} />
    </div>
    ```

## Using the Google Translate API
1. We can use `axios` to make a request to Google Translate API endpoint. Then we can check from "network" tab in deverlop console that the app makes a request every time we type something and got a response from Google's API endpoint.
1. Note that we need to pass an empty object as the 2nd argument in `axios` call. The 2nd object is the `body` or `params` that passed as to make request. We can check more information about [how `axios` call works](https://github.com/axios/axios#axiosposturl-data-config).
1. However, according to Google Translate API, we need to pass the parameters as "**[query string](https://en.wikipedia.org/wiki/Query_string)**". Therefore, we will leave the 2nd object empty as we don't have parameters.
1. The query parameters will be send through query string, we will set them up in `config` which is the 3rd argument for `axios`, and we set them up in the `params` property.
    ```js
    // component/Convert.js
    import React, {useState, useEfect} from 'react';
    import axios from 'axios';

    const googleTranslateAPI = `AIzaSyCHUCmpR7cT_yDFHC98CZJy2LTms-IwDlM`;

    const Convert = ({language, text}) => {
        useEffect(() => {
            axios.post('', {}, {
                params: {
                    q: text,
                    target: langauge,
                    key: googleTranslateAPI
                }
            });
        }, [text, language])
    }
    ```

## Displaying Translated Text
1. We create a new state `translated` to keep the translated output responded from Google API.
1. The solution here is similar to what we did for the `Search` component that making request to and API. 
1. Note that we get `data` from the response object by `axios`. There's another `data` property which holds the data we need from Google API that can be confusing. 
1. However, the current function will have the same problem that every time the user types someting, the App will make a call to the endpoint. This can be pricy if the API service charges every time we make a request. 
1. Therefore, we can use another `state` and `useEffect` to have a "delay" and wait for user finsihing typing.
    ```js
    const Convert = ({ language, text }) => {
        const [translated, setTranslated] = useState('');

        useEffect(() => {
            const doTranslation = async () => {
                const { data } = await axios.post('https://translation.googleapis.com/language/translate/v2', {}, {
                    params: {
                        q: debouncedText,
                        target: language.value,
                        key: googleTranslateAPI
                    }
                });

                // this data structure can be confusing 
                setTranslated(data.data.translations[0].translatedText);
            };

            doTranslation();
        }, [language, text]);

        return (
            <div>
                <h1 className="ui header">
                    {translated}
                </h1>
            </div>
        );
    }
    ```

## Debouncing Translation Updates
1. The solution uses here is the same as the widget we did for `Search` component. 
1. We use 2 `state` and `useEffect` to track on user input.
    1. One `state` and `useEffect` has a timer and will be cancel if the user keeps typing in 500ms. 
    1. After the user finishes typing, the 2nd `state` will be updatd and triggered the other `useEffect` to make API request.
1. Note that in the 2nd `useEffect` we should put `language` in the 2nd array argument to have better user experience. As users won't switch languages as often as typing something in the `input` tag. Besides, this feature will allow users to switch translation for the same input. Without it, the user must switch the language and change the input and type it back again. 
    ```js
    const Convert = ({ language, text }) => {
        const [translated, setTranslated] = useState('');
        const [debouncedText, setDeboucedtext] = useState('');

        useEffect(() => {
            const timerId = setTimeout(() => {
                setDeboucedtext(text);
            }, 500);

            return () => {
                clearTimeout(timerId);
            }
        }, [language, text]);

        useEffect(() => {
            const doTranslation = async () => {
                const { data } = await axios.post('https://translation.googleapis.com/language/translate/v2', {}, {
                    params: {
                        q: debouncedText,
                        target: language.value,
                        key: googleTranslateAPI
                    }
                });

                setTranslated(data.data.translations[0].translatedText);
            };

            doTranslation();
        }, [language, debouncedText]) // put language will allow users to swtich translation between languages with the same input

        return (
            <div>
                <h1 className="ui header">
                    {translated}
                </h1>
            </div>
        );
    }
    ```



# Navigation From Scratch
## Navigation in React
1. In this section, we will work on "**Navigation**" which shows different sets of components when the URL changes.
1. In last sections, we create `Accordion`, `Dropdown` (color changing), `Translate`, and `Search`. We will create a navigation bar on the top for users to switch between the widgets.
    1. At the `root` route, we will show `Accordion` by default.
    1. `dropdown` for color changing feature
    1. `translate` for `Translate` component
1. For the purpose, we will use a library `React-Router`. However, there's some features we should be aware of.
    1. React Router has frequent breaking changes
    1. **More important to learn the ideas and theory of navigation**
    1. We are going to build some navigation stuff from scratch
    1. React-Router will be covered later in the course

## Basic Component Routing
1. Firstly we draw out the route mappings to understand the structure of the routes
    1. `/` shows `Accordion` 
    1. `/list` shows `Search`
    1. `/dropdown` shows `Dropdown`
    1. `/translaet` shows `Translate`
1. `window.location` is a global object that we can keep track on the user's route, which is the URL in the search bar. There are several properties that we can check of current user's state, such as `href` for the full URL, `port` for the port that the user is visiting and fetching data, and `host` for the domain name. 
1. In this case, we can check the route from `pathname` property, which is the route where the user locates.
    ```js
    window.location.href
    window.location.pathname
    window.location.port
    window.location.host
    ```
1. In `App.js`, we can add functions to check routes to find where is the current user. If the `pathname` matches the setting, we will show the ailgned components. 
1. Howeer, the current approach is not optimized as the logic to check each route and show components is repetitive.
    ```js
    // App.js
    const showAccordion = () => {
        if (window.location.pathname === '/') {
            return <Accordion items={items} />;
        }
    }

    const showList = () => {
        if (window.location.pathname === '/list') {
            return <Search />;
        }
    }

    const showDropdown = () => {
        if (window.location.pathname === '/dropdown') {
            return <Dropdown />;
        }
    }

    const showTranslate = () => {
        if (window.location.pathname === '/translate') {
            return <Translate />;
        }
    }

    export default () => {
        return (
            <div>
                {showAccordion()}
                {showList()}
                {showDropdown()}
                {showTranslate()}
            </div>
        );
    }
    ```

## Building a Reusable Route Component
1. Though we can make a standalone function to check the current route and decide what components to render, we can create another component for the case.
1. We create `Route.js` to check the `pathname` and decide what to show on the screen. Note that we didn't use `React` component, so we don't need to import `React` in this case. 
1. Besides, we get 2 arguments from `App` component that check the path and return `children` which is the child component of another component. We can check the structure in `App.js`. 
    ```js
    // comopnents/Route.js
    const Route = ({ path, children }) => {
        return window.location.pathname === path
            ? children
            : null;
    }

    export default Route;
    ```
1. In `App`, we can use `Route` to wrap which component we created and pass the `path` to check which component should React render. 
    ```js
    // App.js
    export default () => {
        const [selected, setSelected] = useState(options[0]);
        return (
            <div>
                <Route path="/"> // parent component 
                    <Accordion items={items} /> // children of a component
                </Route>
                <Route path="/list">
                    <Search />
                </Route>
                <Route path="/dropdown">
                    <Dropdown
                        label="Select a color"
                        options={options}
                        selected={selected}
                        onSelectedChange={setSelected}
                    />
                </Route>
                <Route path="/translate">
                    <Translate />
                </Route>
            </div>
        );
    }
    ```

## Implementing a Header for Navigation
1. After setting the route, we can create `Header` which is the navigation bar for users to switch between widgets. We then create `Header.js` in components directory.
    ```js
    // comopnents/Header.js
    import React from 'react';

    const Header = () => {
        return (
            <div className="ui secondary pointing menu">
                <a href="/" className="item">
                    Accordion
                </a>
                <a href="/list" className="item">
                    Search
                </a>
                <a href="/dropdown" className="item">
                    Dropdown
                </a>
                <a href="/translate" className="item">
                    Translate
                </a>
            </div>
        )
    }

    export default Header;
    ```
1. We then can just put the `Header` component right above the other `Route` component.
1. Though this solution works at the moment, there's a downside for this and we will discuss in the later section.
    ```js
    // App.js
    import Header from './components/Header';

    return () => {
        return 
        <div>
            <Header />
        </div>
    }
    ```
    <img src="./images/reactNavigation199.gif">

## Handling Navigation
1. The current solution has an issue that every time the user switches between widgets, the browser will make request too various resources for the event. This is consider bad approach because this can dramatically slow down the process and affect user experience. 
1. For regular web app, every time the user clicks on a hyper link (anchor tag) or switch between routes, the browser will make a request by the route to the server, and the server will respond will aligned HTML documents and its JavaScript and CSS file.
1. Therefore, in the current React structure with the `Header` component, every time user switch the route, the whole React App is rerendered and request for all the resources from server. This includes all the components, media, and CSS file. This can be a huge drag down when the App goes bigger. 
1. In summary, we'd like to request for part of the files and components we need when the user switches between widgets rather than requesting for the whole web app.
1. The App can be modified to adpat the following workflow.
    1. User clicks on `List`.
    1. Change the URL, but don't do a **_full page refresh_**!
    1. Each Route could detect the URL has changed.
    1. Route could update piece of `state` tracking the current pathname.
    1. Each Route rerenders, showing/hiding comopnents appropriately.

## Building a Link
1. We create `Link` component to handle each event when the user click on the links to switch between routes. Therefore, we replace all the anchor tags in `Header` with `Link` component.
    ```js
    // components/Header.js
    import Link from './Link.js';
    const Header = () => {
        return (
            <div className="ui secondary pointing menu">
                <Link href="/" className="item">
                    Accordion
                </Link>
                <Link href="/list" className="item">
                    Search
                </Link>
                <Link href="/dropdown" className="item">
                    Dropdown
                </Link>
                <Link href="/translate" className="item">
                    Translate
                </Link>
            </div>
        )
    }
    ```
1. Besides, we should import and use `className`, `href`, and `children` properties sending from `Header` component. Note that `children` is the content or element that wrapped by the component. It can be regular value or other HTML elements or components. 
1. To handle the `click` event, we create a helper function `onClick` and use `preventDefault()` to prevent the App from reloading the resources when switching between routes.
    ```js
    // components/Link.js
    import React from 'react';
    const Link = ({ className, href, children }) => {
        const onClick = (event) => {
            event.preventDefault();
        }

        return (
            <a onClick={onClick} className={className} href={href}>
                {children}
            </a>
        );
    };

    export default Link;
    ```

## Changing the URL
1. In browsers, we can use `window.history.pushState({}, '', '/route')` to change URL in the search bar without redirect the user and reload the page. 
1. Therefore, we can update `Header` component and change URL when users clicks any item in the navigation. 
1. However, we should be careful with the content and component rendered by each route, as users can save the link as bookmark and access it again in the future. We should persist and return the same content on the same route.
    ```js
    // Header.js
    const Link = ({ className, href, children }) => {
        const onClick = (event) => {
            event.preventDefault();
            window.history.pushState({}, '', href);
        }

        return (
            <a onClick={onClick} className={className} href={href}>
                {children}
            </a>
        );
    };
    ```

## Detecting Navigation
1. In this case, we'd like to track on the changes on URL and render the components accordingly. 
1. In `onClick` helper event, we put `new PopstateEvent('popstate')` and pass this object to `window.dispatchEvent(navEvent)`. What this basically does is that it indicates to the `Route` component that the URL is changed.
1. However, there's no explanation from the browser that why and how to use `PopstateEvent()` and `window.dispatchEvent()`.
    ```js
    // Links.js
    const Link = ({ className, href, children }) => {
        const onClick = (event) => {
            event.preventDefault();
            window.history.pushState({}, '', href);

            const navEvent = new PopStateEvent('popstate');
            window.dispatchEvent(navEvent);
        }

        return (
            <a onClick={onClick} className={className} href={href}>
                {children}
            </a>
        );
    };
    ```
1. In `Route` component, we need to catch the `popstate` event when it changes. Besides, we only want this `useEffect` happens when the component rerenders, so we pass an empty array, as the 2nd argument.
1. Besides, we can return a clean up function to remove the event listener `onLocationChange`.
1. After the update, we can find `onLocationChange` is triggered 4 times when we click on the anchor tag. 
    ```js
    // Route.js
    import { useEffect } from 'react';

    const Route = ({ path, children }) => {
        useEffect(() => {
            const onLocationChange = () => { // fires when the user clicks on any Link component in Header and switch the URL
                console.log('Location Change');
            };

            window.addEventListener('popstate', onLocationChange);

            return () => {
                window.removeEventListener('popstate', onLocationChange);
            }
        }, []);

        return window.location.pathname === path
            ? children
            : null;
    }

    export default Route;
    ```

## Updating the Route
1. To let `Route` component rerender only itself, we create a specific state `currentPath` which is only used to check if the route is updated. 
1. We then updaet `onLocationChange` helper function and make it update `currentPath` state. Down below for the object to return, we can change to check if `currentPath` is equal to the `path` to show the component or return `null` to keep it empty.
1. Note that we can still use `window.location.pathname` as if it equals to the `path`. 
    ```js
    //Route.js
    const Route = ({ path, children }) => {
        const [currentPath, setCurrentPath] = useState(window.location.path);
        useEffect(() => {
            const onLocationChange = () => {
                setCurrentPath(window.location.pathname);
            };

            window.addEventListener('popstate', onLocationChange);

            return () => {
                window.removeEventListener('popstate', onLocationChange);
            }
        }, []);

        return currentPath === path
            ? children
            : null;
    }
    ```
1. Note that there's one last feature missing here is that in regular condition, users can press <kbd>Ctrl</kbd> and click a link and create a new tab in the browser. However, this feature is not available in the current configuration, as we have use `event.preventDefault()` in an event handler to prevent the scenario.

## Handling Command Clicks
1. Note that when users press <kbd>Ctrl</kbd> and click a link, we should track on the event and ensure that we return the correct components as users want to see. Besides, as it's in the new tab, all the resources should be loaded again.
1. Therefore, we can update `Link.js` and check the `event` argument with its `.metaKey` and `.ctrlKey` from user request. If the user does press <kbd>Ctrl</kbd> on Windows system or <kbd>Commend</kbd> on Mac, we use `return` to bypass the event handler, so the page on the given route will be loaded as a new page.
    ```js
    // components/Link.js
    const Link = ({ className, href, children }) => {
        const onClick = (event) => {
            if (event.metaKey || event.ctrlKey) { // allow users to create a new tab in the browser when press Ctrl and click the link
                return;
            }

            event.preventDefault();
            window.history.pushState({}, '', href);

            const navEvent = new PopStateEvent('popstate');
            window.dispatchEvent(navEvent);
        }

        return (
            <a onClick={onClick} className={className} href={href}>
                {children}
            </a>
        );
    };
    ```



# Hooks in Practice
## Project Overview
1. The target of this section is to "**rebuild YouTube Video App with Hooks**".
1. We are going to use files from `video` project which as 3 main components, `SearchBar`, `VideoList` with `VideoItem` in it, and `VideoDetail`.

## Refactoring the SearchBar
1. This section is to refactor `SearchBar.js` component and turn it from class-based to functional component.
    ```js
    // SearchBar.js
    import React, { useState } from 'react';

    const SearchBar = ({ onFormSubmit }) => {
        const [term, setTerm] = useState('');

        const onSubmit = (event) => { // as we have had 'onFormSubmit' passed from props system, so we change the helper function to 'onSubmit'
            event.preventDefault();
            onFormSubmit(term);
        }

        return (
            <div className="search-bar ui segment">
                <form onSubmit={onSubmit} className="ui form">
                <div className="field">
                    <label>Video Search</label>
                    <input 
                        type="text"
                        value={term}
                        // pass an anonymous arrow function here rather than declaring another function
                        onChange={(event) => setTerm(event.target.value)}
                    />
                </div>
            </div>
        );
    }

    export default SearchBar;
    ```

## Refactoring the App
1. In `App` component, we found 2 states, `videos` and `selectedVideo`. Therefore, we can use `useState` twice for each of them. 
1. Besides, we use `componentDidMount` which is a lifecycle method, so we can use `useEffect` to replace the function. Besides, `componentDidMount` only runs the callback function passed to it once when the component is rendered. Therefore, we pass an empty array as the 2nd argument.
    ```js
    // App.js
    import React, {useState, useEffect} from 'react';

    const App = () => {
        const [videos, setVideos] = useState([]);
        const [selectedVideo, setSelectedVideo] = useState(null);

        useEffect(() => {
            onTermSubmit('buildings');
        }, []);

        const onTermSubmit = async (term) => {
            const response = await youtube.get('/search', {
                params: {
                    q: term
                }
            });

            setVideo(response.data.items);
            setSelectedVideos(response.data.items[0]);
        };

        const onVideoSelect = (video) => {
            setSelectedVideo(video);
        };

        return (
            <div className="ui container">
                <SearchBar onFormSubmit={onTermSubmit} />
                <div className="ui grid">
                    <div className="ui row">
                        <div className="eleven wide column">
                            <VideoDetail video={selectedVideo} />
                        </div>
                        <div className="five wide column">
                            <VideoDetail 
                                onVideoSelect{onVideoSelect}
                                videos={videos}
                            />
                        </div>
                    </div>
                </div>
            </div>
        );
    };
    ```

## Removing a Callback
1. We can notice that every time we find a one line function, we can consider to use anonymous function to pass it to event handler rather than declare a new function variable.
1. Besides, if the function take a single argument and pass it to the callback function, we can consider to remove the whole function and pass the callback function as variable directly. 
    ```js
    // App.js
    <VideoList 
        onVideoSelect={(video) => setSelected(video)} 
        videos={videos} 
    />

    // we can refactor it to
    <VideoList 
        onVideoSelect={onVideoSelect} 
        videos={videos} 
    />
    ```

## Overview on Custom Hooks
1. In some cases, we may use the same or similar functions on different components, such as fetching data from URL. This can be used to render data and contents to users or provide insights in the user backend system.
1. For example, in this project, we have logic for video fetching in `App` component, while this can be used on `Analytic` component which is to show the list of videos that the user uploads. Though the endpoint to fetch data can b different, the logic is similar and we can make this function in component to make it reusable.
1. In this case, we can create "**_Custom Hook_**" to be used for both `App` and `Analytics` components.
1. There are some feature and advantages from custom hooks
    1. Best way to create reusable code in a React project (besides components).
    1. Created by extracting hook-related code out of a function component.
    1. Custom hooks always make use of at least one primitive hook internally.
    1. Each custom hook should have "**_only one purpose_**". 
    1. Kind of an art form. (This concept is abstract and not easy to understand)
    1. Data-fetching is a great thing to try to make reusable.
1. Note that `custom hooks` are not related to `JSX`. If we want to make JSX reusable, we just create another component.

## Process for Building Custom Hooks
1. To create a `custom hook`
    1. Identify each line of code related to some single purpose.
    1. Identify the `inputs` to that code.
    1. Identify the `outputs` to that code.
    1. Extract all the code into a separate function, receiving the inputs as arguments, and returning the outputs.
1. By summarizing the process into a sentence, we get "If you give me a `default search term`, I will give you `a way to search for videos` (and `a list of videos`).
1. In this project, we focus on the part that is not JSX. There are 2 main purpose in the following code.
    1. Managing a list of videos in the current state.
    1. Managing the selected video.
    ```js
    // App.js
    const [videos, setVideos] = useState([]); // an updated videos state is the output from custom hook
    const [selectedVideo, setSelectedVideo] = useState(null);

    useEffect(() => {
        // this is the input for custom hook 
        onTermSubmit('buildings');
    }, []);

    const onTermSubmit = async (term) => { // an api calling method is the output from the custom hook
        const response = await youtube.get('/search', {
        params: {
            q: term,
        },
        });

        // data responded from the endpoint is the output from the custom hook
        setVideos(response.data.items);
        setSelectedVideo(response.data.items[0]);
    };
    ```

## Extracting Video Logic
## Using the Custom Hook
1. We create a new directory in `src` as `hooks` to put the `custom hooks` we create. 
1. In convention, we will set the name similar to `useState` and `useEffect`. Therefore, we can use `useVideo` for the purpose. 
1. We start to copy the code from `App.js` to `useVideos` custom hook. Note that we only transfer the code that handles "**videos**" state.
    1. We take off the default search term `buildings` because this custom hook can be used in other components. We'd like to make a default search according to the component using it. This is consider the `input` from this custom hook.
    1. For `output`, we'd like to get a list after the user searchs a specific topic or term. In this case, we can return 2 data, which is the "**videos list**" generated from the API call, and "**a function that can be used to search for new videos**".
    1. To return the `outputs`, we can use pattern similar to other hooks, such as `useState` that an array of `data` and the `set function`.
    1. On the other hand, we can use an object to wrap the outputs as well. 
    1. Note that `onTermSubmit` makes sense to be used in the original component. However, to make this more reusable, we can rename it as `search`, as the callback function simply does an API fetch request to the endpoint and a list of videos from it. 
    ```js
    // src/hooks/useVideos.js
    import { useState, useEffet } from 'react';
    import youtube from '../apis/youtube';

    const useVideos = (defaultSearchTerm) => { // take argument from component
        const [videos, setVideos] = useState([]);

        useEffect(() => {
            search(defaultSearchTerm); // the default search term is given from the component using this hook 
        }, [defaultSearchTerm]); // put defaultSearchTerm here to track on and ensure everytime the argument changes, the function will be called

        // rename the setter function
        const search = async (term) => {
            const response = await youtube.get('/search', {
                params: {
                    q: term,
                },
            });

            setVideos(response.data.items);
        };

        return [videos, search];
        // return { videos, search };
    };

    export default useVideos;
    ```
1. We then import the custom hook as other hooks in React.
    1. Pass a term as the default search term. 
    1. Change the callback function pass to `SearchBar` component as the setter function from the custom hook, which is `search`. 
    1. Use `useEffect` hook to check everytime the custom hook get updated from the API fetch and updates the video list from the fetched results. 
    ```js
    // App.js
    import useVideos from '../hooks/useVideos';

    const App = () => {
        const [selectedVideo, setSelectedVideo] = useState(null);
        const [videos, search] = useVideos('building');

        useEffect(() => {
            setSelectedVideo(videos[0]);
        }, [videos]);

        return (
            <div className="ui container">
            <SearchBar onFormSubmit={search} /> // use setter function from the custom hook
            <div className="ui grid">
                <div className="ui row">
                <div className="eleven wide column">
                    <VideoDetail video={selectedVideo} />
                </div>
                <div className="five wide column">
                    <VideoList onVideoSelect={setSelectedVideo} videos={videos} />
                </div>
                </div>
            </div>
            </div>
        );
    };
    ```



# Deploying a React App
## Deployment Overview
1. When we run `create-react-app`, the preset `npm` package will create and handle all the required files and structure for us. During development, we use `npm start` to run a local development server.
1. After finishing development, we can bundle the file and generate 4 main static files and deploy it a web server.
    1. `index.html`
    1. `bundle.js`
    1. `image.jpg`
    1. `index.css`
    <img src="./images/reactDeploymentFlow216.png">
1. Note that we don't need a virtual machine to run the app because the files are actually static as we are only creating the user interface that are static files. 
1. In the case, we will use [`vercel`](https://vercel.com/) for the case. We can install the tool with `npm -g install vercel` to install the package globally on the machine. Note that to deploy the project on vercel, we have to change directory at the path of the project.

## Deployment with Vercel
1. We register an account on Vercel first and run `vercel` in the project directory.
1. Vercel will ask for the first login. We can give the email that we register for the account and verify the email to login.
1. Then vercel will ask for the initial configuration for the project. After that, it will run `npm run build` by itself to bundle the files.
1. If we update the project and want to redeploy the app, we can use `vercel --prod` in the same project directory. Vercel will bundel the project again and deploy the app itself.

## Deployment with Netlify
1. To deploy on Netlify, we should put the app in a separated repo on Github (or other git hosting cloud service).
1. We then choose the repository that is hosted on Github that we want to deploy.
1. For Netlify, the process is relatively simple that every time we does commit on the branch to deploy, such as `master`, it will be deployed to Netlify automatically. 
1. Note that we may see error after deployment on Netlify as we have limited the Youtube API to be accessible only via `localhost`. Therefore, if we go checking in the developer console, we can find that the request to YouTube endpoint gets a `403` error.



# On We Go...To Redux!
## Introduction to Redux
1. State management library
1. Makes creating complex applications easier
1. Not required to create a React app
1. Not explicitly designed to work with React

## Redux by Analogy
1. Redux Cycle
    1. Action Creator 
    1. Action
    1. Dispatch
    1. Reducers
    1. State
1. In this section, we are going to create an insurance company.
    1. `policy` - Customer holds a `policy`, if bad stuff happens to them then we pay them.
    1. `claim` - Customer had something bad happen to them, we need to pay them.
    1. Note that these are insurance terms, not Redux terms.
1. The insurance company works in 3 main functions after they receive forms from their customers
    1. "Claims History" - Stores a list of all claims ever made.
    1. "Policies" - Stores a list of who has policy with our insurance company.
    1. "Accounting" - Stores a big bag of cash, we pay people from this.
    <img src="./images/reduxAnalogyInsuranceCompany220.png">

## A Bit More Analogy
1. We can go further details in to each department with its function in the insurance company. For example, the "**Policy**" department.
    1. When a `form` comes in as to sign up for a policy, the department update the list of customers who owns a policy with the insurance company. 
    1. The management team of the insurance company can check the list of customers. 
1. Though the data can store internally in the department, we can have a central repository which stores all the data from each department in the company. 

## Finishing the Analogy
1. Every `form` submitted to the insurance company has 2 main fields, which are `Type` and `Payload`. 
1. When we receive a `form` from customers, we need to verify what is the purpose of it. For example, the user may want to sign up a new policy or claim for compensation. 
1. Besides, we need more detail on the type form, such as the `name` of the owner of the policy and the `claim amount` that the owner requests.
1. For this insurance company case, we can have 3 main type policies with aligned data.
    1. `create policy` is with `name` and `cash`
    1. `create claim` is with `name` and `claim amount`
    1. `delete policy` is with only the `name`.
1. Therefore, each department in the company will look up the incoming `form` and check if it's related to their business. If yes, the department will update the list of their data to the central repository with the `name` in the `form`. Otherwise, it just returns an unchanged list.
1. For "**Accounting**" department, they may work and update their data according to multiple types of `forms`. For example, when a user signs up a new policy and pay for it, accounting department will receive the money and update their data. Besides, when a user claims for compensation, accounting department will provide the money and update the money left in the company as well. 
1. For "**Policy**" department, they will check only if a `form` indicates that if the user wants to create or end a policy with the company.

## Mapping the Analogy to Redux
1. We can check the diagram for the flow aligned betwen Redux cycle and Insurance company.
1. The central data repository of the insurance company is the `state` that Redux manages.
    <img src="./images/reduxCycleAsInsuranceCompany223.png">

## Modeling with Redux
1. These models are simulated with `codepen.io`.
1. Note that the syntax for creating function to work no Redux will look repetitive to serve its purpose. 
    ```js
    // code simulated on codepen.io for insurance company
    // require to import Redux library 

    // clear console when the JS file runs
    console.clear();

    // People dropping off a form
    const createPolicy = (name, amount) => {
        return { // Action (a form in our analogy)
            type: 'CREATE_POLICY',
            payload: {
                name,
                amount
            }
        }
    }

    const deletePolicy = (name) => {
        return {
            type: 'DELETE_POLICY',
            payload: {
                name
            }
        }
    }

    const createClaim = (name, amountOfMoneyToCollect) => {
        return {
            type: 'CREATE_CLAIM',
            payload: {
                name,
                amountOfMoneyToCollect
            }
        }
    }
    ```

## Creating Reducers
1. When update the objects in `reducers` in Redux, we always want to create and return a new array rather than modifying on the old data directly. Therefore, we rarely see `.push` method used in the reducer functions
1. Some of the parameters requires default value. As the first time they are called, they may not have value yet and can be `undefined` which can cause error to the function.
    ```js    
    // Reducers (Departments)
    const claimsHistory = (oldListOfClaims = [], action) => {
        if (action.type === 'CREATE_CLAIM') {
            // we are about this action (FORM)
            return [...oldListOfClaims, action.payload];
            /*
            we don't use .push method to update the array because it's modifying on the same object
                oldListOfClaims.push(action.payload);
            */
        }
    
        // we don't care the action (form)
        return oldListOfClaims;
    };

    // assume that the company initially has 100 dollars in their money bag
    const accounting = (bagOfMoney = 100, action) => {
        if (action.type === 'CREATE_CLAIM') {
            return bagOfMoney - action.payload.amountOfMoneyToCollect;
        } else if (action.type === 'CREATE_POLICY') {
            return bagOfMoney + action.payload.amount;
        }
        
        return bagOfMoney;
    };
    ```

## Rules of Reducers
1. In this case, we can use `.filter` array method in JavaScript which will iterate through the elements in the array and return only elements that is in the `true` condition in the callback function. 
1. Note this array method creates and returns a new array.
1. In convention of using Redux, we will only create and return new arrays that derive from the old data rather than modify the old objects directly. 
    ```js
    const policies = (listOfPolicies = [], action) => {
        if (action.type === 'CREATE_POLICY') {
            return [...listOfPolicies, action.payload.name];
        } else if (action.type === 'DELETE_POLICY') {
            return listOfPolicies.filter(name => name !== action.payload.name);
        }  
        
        return listOfPolicies;
    }
    ```

## Testing Our Example
1. In this case, we will use the imported Redux library and destructuring assignment to create `ourDepartment` the reducers object.
1. We then can use `createStore` method to create the `store` from the combined reducers.
1. To work on `dispatch` action, we can use `store.dispatch()` with `action` which is the functions we declare to use for different departments.
1. Besides, we can use `store.getState()` to get the current `states` stored in the `store` object.
    ```js
    const {createStore, combineReducers} = Redux;
    const ourDepartments = combineReducers({
        accounting,
        claimsHistory,
        policies
    });

    const store = createStore(ourDepartments);

    const action = createPolicy('Alex', 20);
    console.log(action);

    store.dispatch(createPolicy('Alex', 20));
    store.dispatch(createPolicy('Jim', 30));
    store.dispatch(createPolicy('Bob', 40));

    console.log(store.getState());

    store.dispatch(createClaim('Alex', 120));
    store.dispatch(createClaim('Jim', 50));

    console.log(store.getState());

    store.dispatch(deletePolicy('Bob'));

    console.log(store.getState());
    ``` 
    <img src="./images/reduxMethods227.png">

## Important Redux Notes
1. When we want to change the `state` and update date to the `store`, we will use the `action creator` which will produce an `action` object.
1. The `action` object describe exactly how we want to change the data in the application.
1. The `action` object is passed to `dispatch` function which will duplicate the data from `action` and feed the copies to `reducers`.
1. `Reducers` will proceed on the data and update the `state`.
    <img src="./images/reduxCycle228.png">
1. Note that we must use `combineReducers`, so the properties will be udpate to the central `state` to keep the data with initial values since the beginning.
1. Each `store.dispatch` method we use is actually running the whole Redux cycle from receiving the data and update to `state`. 
1. One of the main feature from Redux is that we can't modify the `store` object directly or manually, so we must use `.dispatch` method with an `action` object to update it.
1. Besides, it limits the way how developers modifying the data and define the ways of how to udpate the `state`. Therefore, the complexity of the app can be reduced when the app goes bigger.



# Integrating React with Redux
## React Cooperating with Redux
1. We are going to create an project with simple integration of `React` and `Redux`. We will create a list of songs with their title. When the user click any of the songs in the list, there's details of the song rendered on the side of the page. 

## React, Redux, and React-Redux
1. The `songs` app has 2 main components.
    1. `SongList` is a list of songs with their titles.
    1. `SongDetail` is the detail of the selected song when the user selects one of the songs.
1. To work with both `React` and `Redux`, we will use 3 libraries `React`, `Redux`, and `React-Redux` which is the library to allow React and Redux work together.
1. Note that `Redux` is not developed to work with `React` only and it can be used in the other cases as well.
1. In this case, we work similar to other projects that we take the boilerplates off from the `src` folder.
1. Besides, we will use `Semantic UI` CSS library.
    ```js
    // components/App.js
    import React from 'react';

    const App = () => {
        return (
            <div>App</div>
        );
    };

    export default App;

    // index.js
    import React from 'react';
    import ReactDOM from 'react-dom';

    ReactDOM.render(<App />, document.querySelector('#root'));
    ```

## Design of the Redux App
1. In many cases, if we use `Redux` to manage `state`, we will skip `useState` from `React` library. However, in some scenarios, we will use both to manage the `state`.
1. For the structure, if we'd like to use without `Redux`, we may have `state` as the following structure.
    <img src="./images/reactStructureWithoutRedux232.png">
1. On the other hand, we can use `Redux` and simplify the structure.
    <img src="./images/reactStructureWithRedux232.png">

## How React-Redux Works
1. We will use `React-Redux` to create 2 new components to work on both `React` and `Redux`.
    1. `Provider`
    1. `Connect`
    <img src="./images/howReactReduxWork233.png">
1. By using `Redux`, we will get a `store` object which stores all the `states`. Therefore, we will pass the `store` object as a `prop` to `Provider` which is derived from `React-Redux`. 
1. Note that `Provider` component will be rendered at the very top hierarchy in the application, which is even higher than `App`. Thus, `App` is actually showing inside of the `Provider` component. By meaning of its name, the `Provider` will provide the information to all the components in the app. 
1. The `Connect` component allows the child component inside of it communicate with `Provider` directly that it can bypass all the parent comopnents in between. The system these components used to communicte is the `context` system.
1. When the `Connect` component receives data from `Provider` it passes it to the child component with `prop` system.
1. To modify the data in `Redux`, we need to use `Action Creators` which uses `store.dispatch(action)` method to update the `states`.

## Redux Project Structure
1. Under `src` directory, we have several folders
    1. `/actions` contains files related to action creators
    1. `/components` has files related to components
    1. `/reducers` has files related to reducers
    1. `/index.js` sets up both the react and redux sides of the app. As we have more configuration in this file, we have moved `App.js` as a component to `/component` directory.
1. We then create `actions` and `reducers` directory in `src` folder. Besides, in `actions` folder, we create a new file `index.js`. 
1. Note that in vast majority of React app, this is the naming convention, and we will see many files in a directory is named `index.js`. This is because that when webpack bundle the code, if we don't provide the file name but the directory directly, it will find file name `index.js` as default. Therefore, we can have a shorthand for the case and pass only the dierctory rather than the whole route with the file name.

## Named vs Default Exports
1. In this course, we are using `export default` all the time. However, we can also use "**named exports**" for the case. Note that to import named exports in the other file, we can use destructuring assignment with curly braces to assign new variable. 
1. Named export is one way to export multiple variables from a file. 
1. We can simply notice that if a JS file is using `export default`, we can import the single variable without using curly braces. Otherwise, we can use destructuring assigment as the shorthand to import multiple variables from the file at the same time.
    ```js
    // src/actions/index.js
    // Action creator
    export const selectSong = song => {
        // Return an action
        return {
            type: 'SONG_SELECTED',
            payload: song
        };
    };
    ```

## Building Reducers
1. We create `index.js` in `reducers` directory. Note that we are returning a static array with no argument given to the reducer function in this case. This is just a demo app to show how to integrate using React and Redux.
    ```js
    // src/reducers/index.js
    const songsReducer = () => {
        return [
            { title: 'No Scrubs', duration: '4:05' },
            { title: 'Macarena', duration: '2:30' },
            { title: 'All Star', duration: '3:15' },
            { title: 'I Want it That Way', duration: '1:45' }
        ];
    };

    const selectedSongReducer = (selectedSong = null, action) => {
        if (action.type === 'SONG_SELECTED') {
            return action.payload;
        }

        return selectedSong;
    }
    ```

## Wiring Up the Provider
1. We import `Redux` to use it in `index.js` for the reducer function. To know whether to use curly braces to declare variables when import a library, we can check its documentation.
    ```js
    // src/reducers/index.js
    import { combineReducers } from 'redux';

    const songsReducer = () => {
        return [
            { title: 'No Scrubs', duration: '4:05' },
            { title: 'Macarena', duration: '2:30' },
            { title: 'All Star', duration: '3:15' },
            { title: 'I Want it That Way', duration: '1:45' }
        ];
    };

    const selectedSongReducer = (selectedSong = null, action) => {
        if (action.type === 'SONG_SELECTED') {
            return action.payload;
        }

        return selectedSong;
    }

    export default combineReducers({
        songs: songsReducer,
        selectedSong: selectedSongReducer
    });
    ```
1. After configure the reducer function for `Redux`, we get back to work on the `index.js` in `src`. We import `Provider` from `react-redux` and `createStore` to update the `state` stored in `store` in `Redux`. 
1. We then wrap the `App` component with `Provider` component and pass the `store` object with `props` which is created with `createStore` with reducer function.
1. Note that this provider is created to enable the child components in `App` to use `Connect` componenet to communicate with `Provider` component directly.
    ```js
    // src/index.js
    import React from 'react';
    import ReactDOM from 'react-dom';
    import { Provider } from 'react-redux';
    import { createStore } from 'redux';

    import App from './components/App';
    import reducers from './reducers';

    ReactDOM.render(
        <Provider store={createStore(reducers)}>
            <App />
        </Provider>,
        document.querySelector('#root')
    );
    ```

## The Connect Function
1. After we set up the `Provider`, child components in the `App` component can now use `Connect` component to communicate the `Provider` and manipulate data from `state`. 
1. We create `SongList` component for the app as a class-based component. Note that we can use destructuring assignment to create a variable. 
1. To use `Connect`, we import `react-redux` library and use the method before exporting the component. Note that we use 2 sets of parenthesis to call the `connect` function. This is using the feature fo closure and the first layer of the function returns a function. 
    ```js
    // src/component/SongList.js
    import React, { Component } from 'react';
    import { connect } from 'react-redux';

    class SongList extends Component {
        render() {
            return <div>SongList</div>;
        }
    }

    export default connect()(SongList);

    // 2 sets of parenthesis in JavaScript
    function plusOne() {
        let num = 0;
        return function() {
            return num++;
        }
    }
    console.log(plusOne()()); // 0

    let addOne = plusOne();
    console.log(addOne()); // 1
    console.log(addOne()); // 2
    console.log(addOne()); // 3
    ```
1. Structure in `App`
    ```js
    // components/App
    import React from 'react';
    import SongList from './SongList';

    const App = () => {
        return (
            <div>
                <SongList />
            </div>
        );
    };

    export default App;
    ```

## Configuring Connect with MapStateToProps
1. Note the `connect` function we created in `SongList` is actually a React component.
1. We then declare a function to fetch data from `store` via connect and link between `state` and `props` for React components. In convention, we declare the function name as `mapStateToProps`. This can be either a regular function statement or an arrow function.
1. We then can pass the function to configure `connect` function. Therefore,
    ```js
    // src/components/SongList.js
    import React, { Component } from 'react';
    import { connect } from 'react-redux';

    class SongList extends Component {
        render() {
            console.log(this.props); // the state with the list of songs is passed to the component via props
            return <div>SongList</div>;
        }
    }

    const mapStateToProps = (state) => {
        console.log(state); // we can check what is inside the state object
        return { songs: state.songs }; // we only need songs porperty passed from Provider to the component
    }

    export default connect(mapStateToProps)(SongList);
    ```

## Building a List with Redux Data 
1. We use Semantic UI library to build up the interface for `SongList`.
    ```js
    // src/components/SongList.js
    import React, { Component } from 'react';
    import { connect } from 'react-redux';

    class SongList extends Component {
        renderList() {
            return this.props.songs.map((song) => {
                return (
                    <div className="item" key={song.title}> // better to assign unique keys to each element in the list
                        <div className="right floated content">
                            <button className="ui button primary">
                                Select
                            </button>
                        </div>
                        <div className="content">{song.title}</div>
                    </div>
                );
            });
        }

        render() {
            return <div className="ui divided list">{this.renderList()}</div>;
        }
    }

    const mapStateToProps = (state) => {
        return { songs: state.songs };
    }

    export default connect(mapStateToProps)(SongList);
    ```
1. To constrain the width of `SongList` component, we can modify the structure in `App`. 
    ```js
    // src/components/App.js
    import React from 'react';
    import SongList from './SongList';

    const App = () => {
        return (
            <div className="ui container grid">
                <div className="ui row">
                    <div className="column eight wide">
                        <SongList />
                    </div>
                </div>
            </div>
        );
    };

    export default App;
    ```

## Extracting more data from Redux
1. If the `state` has more than one properties, we can put the property that we want in `mapStateToProps`. Therefore, when we use `connect` component to link to `Provider`, we can access the property.
1. In the exercise, we have another state `favoriteTitle` and would like to put text `'Favorite!'` if the song title matches the title in `favoriteTitle` in the `state`.
    ```js
    // src/component/SongList.js
    class SongList extends React.Component {
        renderList() {
            return this.props.songs.map((song) => {
                <div className="item" key={song.title}>
                    <div className="right floated content">
                        <div className="ui button primary">Select</div>
                    </div>
                    <div className="content">
                        {this.props.favoriteTitle === song.title ? 
                            `${song.title} 'Favorite!' :
                            ${song.title}`}
                    </div>
                </div>
            });
        }

        render (
            return(
                <div className="ui divided list">{this.renderList()}</div>
            );
        )
    }

    const mapStateToProps = (state) => {
        return {
            songs: state.songs, 
            favoriteTitle: state.favoriteTitle // another state to configure in connect
        }
    };

    export default connect(mapStateToProps)(SongList);
    ```

## Calling Action Creators from Components
1. After we use `connect` to link the component with `Provider`, we'd like to update the `state` when the user clicks on a select button. 
1. Note that everytime we update data with `Redux`, we should use an `action creator`. The `connect` component can not only retrieve data from `store` in Redux system but also pass the action creator into the component, `SongList`, it connects.
1. We import action creator `selectSong` from `actions` directory and pass it as the 2nd argument to `connect` as an object. Note that we use destructuring here that the regular syntax for the property can be `{ selectSong: selectSong}`.
1. We then can use `this.props.selectSong` to access the action creator, so we pass this action creator to `onClick` event handler to update the `state` when the user clicks the button. 
1. Note that `mapStateToProps` will rerun every time when the component rerenders to get the latest `state`. Therefore, we can check the current `state` with `console.log()` in the function.
    ```js
    // src/components/SongList.js
    import React, {Component} from 'react';
    import { connect } from 'react-redux';
    import { selectSong } from '../actions';

    class SongList extends Component {
        renderList() {
            return this.props.songs.map((song) => {
                return (
                    <div className="item" key={song.title}>
                        <div className="right floated content">
                            <button
                                className="ui button primary"
                                onClick={() => this.props.selectSong(song)} // fire selectSong(song) action creator to update the state with the "song"
                            >
                                Select
                            </button>
                        </div>
                        <div className="content">{song.title}</div>
                    </div>
                );
            })
        }

        render() {
            console.log(this.props); // access selectSong in props
            return <div className="ui divided list">{this.renderList()}</div>;
        }
    }

    const mapStateToProps = (state) => {
        console.log(state); // every time the component rerenders this mapStateToProps will rerun and update the state from the store object
        return {
            songs: state.songs
        }
    }

    // pass selectSong action creator from actions 
    export default connect(mapStateToProps, { selectSong })(SongList);
    ```

## Redux is Not Magic
1. In the last section, we import `selectSong` action, but pass it to `connect` and get to use the function from `props` sending from the parent component. We can't use the function directly after importing the function in the file. 
1. `Redux` is not magic!
    1. Redux does not automatically detect action creator being called. 
    1. Redux does not automatically detect a function returning an object that is an 'action'.
1. Note that the function we create in `actions` directory isn't wired with Redux directly. Therefore, there's no way Redux can know if we are using an action creator.
1. The action must be passed to udpate `store` of Redux by using `store.dispatch` method. Though we don't see `store.dispatch` in `SongList` component, it is happending when we use `connect` to wire up and pass the function. 
    ```js
    import {selectSong} from '../actions';
    
    const mapStateToProps = (state) => {
        return {songs: state.songs};
    }

    connect(mapStateToProps, { selectSong })(SongList);
    ```

## Functional Components with Connect 
1. In this case, we'd like to create another component `SongDetail` which shows the details of a selected song. Therefore, we need to use `connect` to link `state` and `props` and get the selected song from the state.
1. Besides, we don't need to use any action as there's no option for users to work in this component, so we don't use any action creators in this case. 
    <img src="./images/reduxSongDetailComponent246.png">
1. We update the structure of `App` which is the parent component of `SongList` and `SongDetail`. We can notice the the structure that we have very little configuration on each of the child component after using Redux, and we can configure them directly in the component directly.
    ```js
    // component/App
    import React from 'react';
    import SongList from './SongList';
    import SongDetail from './SongDetail';

    const App = () => {
        return (
            <div className="ui container grid">
                <div className="ui row">
                    <div className="column eight wide">
                        <SongList />
                    </div>
                    <div className="column eight wide">
                        <SongDetail />
                    </div>
                </div>
            </div>
        );
    };

    export default App;
    ```
1. We firstly create a new component in `component` directory.
    ```js
    // component/SongDetail.js
    import React from 'react';
    import {connect} from 'react-redux';

    const SongDetail = (props) => {
        console.log(props);
        return <div>Song Detail</div>;
    }

    const mapStateToProps = (state) => {
        return {song: state.selectedSong};
    }

    export default connect(mapStateToProps)(SongDetail);
    ```

## Conditional Rendering
1. We can change the property name of the `props` object in `mapStateToProps`.
1. We use an `if` statement to check if `song` is not null which means the user has selected an item from the list. 
1. On the other hand, if the `song` state does contain a selected `song`, we can render its information on the screen.
    ```js
    // src/component/SongDetails.js
    const SongDetail = ({ song }) => {
        if (!song) {
            return <div>Select a Song</div>;
        }
        return (
            <div>
                <h3>Details for: </h3>
                <p>
                    Title: {song.title}
                    <br />
                    Duration: {song.duration}
                </p>
            </div>
        );
    }
    ```

## Coding Exercise
1. This app has a main feature to allow users to click either "Increment" or "Decrement" button to increase or decrease the number shown in "**Current Count**".
1. In this exercise, we have to ensure
    1. Create `mapStateToProps` and pass it to `connect` method in an object as the 2nd argument.
    1. "**Action creators**" are passed back to `Provider` through `connect`.
    1. Import "**action creators**" (`increment` and `decrement`) and state (`count`) from `props`.
    1. Use `onClick` event handler to call the action creators with arrow functions. However, we can just simply pass it as a callback since we don't have argument to work on in this case. 
    1. Render the content from `state` to the screen. This is to put `count` in `<span></span>` to render it on screen.
    ```js
    // Action Creators - You don't need to change these
    const increment = () => ({ type: 'increment'});
    const decrement = () => ({ type: 'decrement'});
    
    const Counter = ({increment, decrement, count}) => {
        return (
            <div>
                <button className="increment" onClick={() => increment()}>Increment</button> // use arrow function as callback
                <button className="decrement" onClick={decrement}>Decrement</button> // pass the function as callback directly since we have no argument to work on
                Current Count: <span>{count}</span>
            </div>
        );
    };
    
    const mapStateToProps = (state) => {
        return {count: state.count};
    };
    
    const WrappedCounter = ReactRedux.connect(mapStateToProps, {increment, decrement})(Counter);
    
    // Only change code *before* me!
    // -----------
    
    // reducers for Redux
    const store = Redux.createStore(Redux.combineReducers({
        count: (count = 0, action) => {
            if (action.type === 'increment') {
                return count + 1;
            } else if (action.type === 'decrement') {
                return count - 1;
            } else {
                return count;
            }
        }
    }));

    ReactDOM.render(
        <ReactRedux.Provider store={store}>
            <WrappedCounter />
        </ReactRedux.Provider>, 
        document.querySelector('#root')
    );
    ```



# Async Actions with Redux Thunk
## App Overview and Goals
1. The goals of building this project are
    1. Absolutely understand the purpose of reducers
    1. Absolutely understand making API requests with Redux
    1. Absolutely understand the purpose of `redux-thunk`
1. The app is to render data fetched from a outside API which provides data of "**blog posts**".
    1. Post Title
    1. Body of the post
    1. Author name
1. In this App, we have 2 main components, `PostList` which is a list of posts fetched from the API and `UserHeader` which provides the author name of the post.
1. To fetch data, we will use `axios` to make requests to "**[JSONPlaceholder]**(http://jsonplaceholder.typicode.com/)" API. On the page, we can check the endpoints in "**Resources**" section for the type of data. 
1. We will use `/posts` for the posts and their contents and `/users/` for the authors in this project.
    <img src="./images/blogAppStructure249.png">

## Initial App Setup
1. We install several npm packages to use in this project.
    1. `redux` is the Redux library
    1. `react-redux` provides integration layer between react and redux
    1. `axios` helps us make network requests
    1. `redux-thunk` is the middleware to help us make requests in a redux application
1. We clear up all the boilerplates which are created by `npx create-react-app` by default. 
    ```js
    // src/index.js
    import React from 'react';
    import ReactDOM from 'react-dom';
    import { Provider } from 'react-redux';
    import { createStore } from 'redux';

    import App from './components/App';
    import reducers from './reducers';

    ReactDOM.render(
        <Provider store={createStore(reducers)}>
            <App />
        </Provider>,
        document.querySelector('#root')
    );

    // src/components/App.js
    import React from 'react';

    const App = () => {
        return <div className="ui container">App</div>;
    }

    export default App;
    ```

## Tricking Redux with Dummy Reducers
1. In the current stage, we don't have any reducer yet, so React framework warn there's no reducers given in the case.
1. Therefore, we can provide a temporary, dummy reducer to enable the system during development.
    ```js
    // src/reducers/index.js
    import { combineReducers } from 'redux';

    export default combineReducers({
        replaceMe: () => 'temporary reducer'
    });
    ```

## A Touch More Setup
1. In this case, we create another component `PostList` with class-based component.
1. Besides, we import Semantic UI CSS library with `link` tag in the `index.html`.
    ```js
    // src/component/PostList.js
    import React from 'react';

    class PostList extends React.Component {
        render() {
            return <div>Post List</div>;
        }
    }

    export default PostList;
    ```

## How to Fetch Data in a Redux App
1. We learn how to fetch and store data in Redux. In most of the cases, we will follow the flow again and again
    1. Components are generally responsible for fetching data they need by calling an action creator
        1. Component gets rendered onto the screen
        1. Component's `componentDidMount` lifecycle methods gets called
        1. We call action creator from `componentDidMount`
    1. Action creators are responsible for making API requests. This is where Redux-Thunk comes in to play
        1. Action creator runs code to make an API request
        1. API responds with data
        1. Action creator returns an `action` with the fetched data on the `payload` property
    1. We get fetched data into a component by generating new state in our redux store, then  gettingthat into our component through `mapStateToProps`
        1. Some reducer sees the action, returns the data off the `payload`
        1. Because we generated some new `state` object, redux/react-redux cause our React app to be rerendered

## Wiring Up an Action Creator
1. We create action creator function in `actions` directory in `src` and import it to use in `PostList.js`.
1. We import `{connect}` from `react-redux` library and use it to send the action function `fetchPosts` to the parent component. Then we can access it from `this.props.fetchPosts`. 
1. We can this function in the lifecycle method `componentDidMount` when the component renders.
    ```js
    // src/actions/index.js
    export const fetchPosts = () => {
        return {
            type: 'FETCH_POSTS'
        }
    }

    // src/components/PostList.js
    import { connect } from 'react-redux';
    import { fetchPosts } from '../actions';

    class PostList extends React.Component {
        componentDidMount() {
            this.props.fetchPosts();
        }

        render() {
            return <div>Post List</div>;
        }
    }

    export default connect(null, { fetchPosts })(PostList);
    ```

## Making a Request From an Action Creator
1. We create another folder `apis` to keep the route for making request to json placeholder `jsonPlaceholder.js`.
    ```js
    // src/apis/jsonPlaceholder.js
    import axios from 'axios';
    
    export default axios.create({
        baseURL: `http://jsonplaceholder.typicode.com`
    });
    ```
1. We then import the configured `axios` object to use in the action creator. 
1. However, this is not available that we will get an error prompted that the actions must be plain objects.
1. This is the reason why we need to use `redux-thunk` in the project to make async request for action creator.
    ```js
    // src/actions/index.js
    import jsonPlaceholder from '../apis/jsonPlaceholder';

    // declare async function to make request is invalid for action creator!
    export const fetchPosts = async () => {
        const response = await jsonplaceholder.get('/posts');

        return {
            type: 'FETCH_POSTS',
            payload: response
        }
    }
    ```
    <img src="./images/asyncActionCreatorError256.png">

## Understanding Async Action Creators
1. From the last section, we have an error noticing that the action creator should be a plain object.
1. The main problems the case are
    1. Action creators must return plain JS objects with a type property. However, the object is returned by an async arrow function. Note that this is `async/await` syntax is actually a syntactic sugar. When [`Babel`](https://babeljs.io/repl) package compiles the code to ES5, the function is not actually as we see. 
    1. By the time our action gets to a reducer, we won't have fetched our data.
    ```js
    // compile actions/index.js in babel to become ES5 compatible
    "use strict";
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

    function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

    var fetchPosts = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
            switch (_context.prev = _context.next) {
            case 0:
                _context.next = 2;
                return jsonplaceholder.get('/posts');

            case 2:
                response = _context.sent;
                return _context.abrupt("return", {
                type: 'FETCH_POSTS',
                payload: response
                });

            case 4:
            case "end":
                return _context.stop();
            }
        }
        }, _callee);
    }));

    return function fetchPosts() {
        return _ref.apply(this, arguments);
    };
    }();
    ```

## More on Async Action Creators
1. Though we can turn the async function into using promsie to avoid the error, the function still won't run correctly because by the time the Redux flow executes the data hasn't been fetched from the API. 
    1. Action creator called and a request is sent to the API to fetch data
    1. Action returned 
    1. Action sent to all reducers
    1. Reducers run without data, as at this point the data usually hasn't beed fetched and responded.
1. The main idea is that the reducers run without fetched data, as the API hasn't responded.
1. This is the reason we will use `redux-thunk`.

## Middlewares in Redux
1. There are 2 types of action creators
    1. "**Synchronous**" action creator instantly returns an action with data ready to go.
    1. "**Asynchronous**" action creator takes some amount of time for it to get its data ready to go.
1. `redux-thunk` is a library which provides middleware to help us make requests in a redux application.
1. The Middleware in Redux
    1. Function the gets called with every action we dispatch
    1. Has the ability to STOP, MODIFY, or otherwise mess around with actions
    1. Tons of open source middleware exist
    1. Most popular use of middleware is for dealing with async actions
    1. We are going to use a middleware called `Redux-Thunk` to solve our async issues

## Behind the Scenes of Redux Thunk
1. Normal Rules for Redux application
    1. Action Creator **must** return action objects.
    1. Actions must have a `type` property.
    1. Actions can optionally have a '`payload`'.
1. Rules with Redux Thunk
    1. Action Creators **can** return action **_objects_**.
    1. Action Creators **can** return **_functions_**.
    <img src="./images/howReduxThunkWorkInternnally259.png">
1. When action creator returns an "**object**", redux thunk (as the middleware) will check if the object is a JavaScript `Object` or `Function`. If it's a JavaScript object, it will just pass to reducers to proceed. Otherwise, the middleware will start to handle the function.
1. The function will then be called with `dispatch` and `getState` methods. Therefore, in Redux Thunk, we will have `dispatch` and `getState` as arguments.
    ```js
    // https://github.com/reduxjs/redux-thunk/blob/master/src/index.js
    // redux thunk source code
    function createThunkMiddleware(extraArgument) {
        return ({ dispatch, getState }) => (next) => (action) => {
            if (typeof action === 'function') {
                return action(dispatch, getState, extraArgument);
            }

            return next(action);
        };
    }

    const thunk = createThunkMiddleware();
    thunk.withExtraArgument = createThunkMiddleware;

    export default thunk;
    ```

## Shortened Syntax with Redux Thunk
1. We not only import `thunk` from `redux-thunk` but also `{ applyMiddleWare }` from `redux` to use `thunk` as the middleware. 
    ```js
    // src/index.js
    import React from 'react';
    import ReactDOM from 'react-dom';
    import { Provider } from 'react-redux'; 
    import { createStore, applyMiddleware } from 'redux'; // import applyMiddleware
    import thunk from 'redux-thunk'; // import thunk

    import App from './components/App';
    import reducers from './reducers';

    // use thunk as middleware for action creator
    const store = createStore(reducers, applyMiddleware(thunk));

    ReactDOM.render(
        <Provider store={store}>
            <App />
        </Provider>,
        document.querySelector('#root')
    );
    ```
1. In this case, we haven't handle and update the `state` for the API call, so we don't pass `getState` as argument.
1. We can use arrow function syntax to shorten the function.
1. We don't need to return anything from the function, as the main purpose is to fetch data and pass it to `dispatch` to proceed further in Redux cycle.
1. Note that we can still have regular, synchronous action creators in `actions`.
    ```js
    // src/actions/index.js
    import jsonplaceholder from '../apis/jsonPlaceholder';

    // regular syntax with function statement
    export const fetchPosts = () => {
        return async function (dispatch, getState) {
            const response = await jsonplaceholder.get('/posts');

            dispatch({ type: 'FETCH_POSTS', payload: response });
        }
    };

    // shortened code with arrow function syntax from the code above. They work exactly the same
    export const fetchPosts = () => async dispatch => {
        const response = await jsonPlaceholder.get('/posts');
        dispatch({type: 'FETCH_POSTS', payload: response})
    }

    // we can put regular action creators though using Redux-Thunk
    export const selectPost = () => {
        return {
            type: 'SELECT_POST'
        }
    }
    ```



# Redux Store Design
## Rules of Reducers
1. While we may have multiple reducers to use in the project, we will separate them into different files in `src/reducers` and import them into `src/reducers/index.js` and use in the other components.
1. In this `blog` project, we will have `fetchPosts` as action creators, which create action objects that has `type` and `payload`, then we can use reducers to store the data in `store` from Redux.
    ```js
    // src/reducer/postReducer.js
    export default () => {
        return 123; // this is just to test and return some value from the reducer
    }

    // src/reducer/index.js
    import { combineReducers } from 'redux';
    import postReducer from './postReducer';

    export default combineReducers({
        posts: postReducer
    });
    ```

## Return Values from Reducers
1. Rules of Reducers
    1. **Must return **_ANY_** value besides `undefined`.** 
    1. Produces `state`, or data to be used inside of the app using only previous state and the action (reducers are pure).
    1. Must not return reach `out of itself` to decide what value to return.
    1. Must not mutate its input `state` argument.
1. If we return an `undefined`, React will report an error.
    ```js
    // src/reducer/postReducer.js
    export default () => {
        // return an error if there's no value returned
        return undefined; // return an error because a reducer can't return undefined
    }
    ```

## Argument Values
1. Rules of Reducers
    1. Must return **_ANY_** value besides `undefined`.
    1. **Produces `state`, or data to be used inside of the app using only previous state and the action (reducers are pure).**
    1. Must not return reach `out of itself` to decide what value to return.
    1. Must not mutate its input `state` argument.
1. When the app initiates, it will check if there's `undefined` from each reducer to know if the app is in the initial stage. 
    <img src="./images/reducerBeingCalledFirstTime263.png">
1. In the previous project, `songs`, we have a `selectedSongReducer` which does exactly for the 2nd item.
1. We use a shorthard with ES6 syntax to preset the value for a argument if it's not given, which is being `undefined`. 
    ```js
    const selectedSongReducer = (selectedSong = null, action) => {
        // if we don't preset selectedSong in the function statement with ES6 shorthand, this IF statement should be given to assign value to the argument
        if (selectedSong === undefined) { 
            selectedSong = null;
        }

        if (action.type === 'SONG_SELECTED') {
            return action.payload;
        }

        return selectedSong;
    };

    selectedSongReducer(undefined, {type: 'abcdefg'});
    ```
1. The next time when the reducer is called, the state becomes the returned value from the last time when the reducer ran. 
1. From the code above, we can see that the state was `undefined` in the very early stage and becomes `null` at the 2nd time it runs.

## Pure Reducers
1. Rules of Reducers
    1. Must return **_ANY_** value besides `undefined`.
    1. Produces `state`, or data to be used inside of the app using only previous state and the action (reducers are pure).
    1. **Must not return reach `out of itself` to decide what value to return.**
    1. Must not mutate its input `state` argument.
1. The reducer should only get data from previous `state` and be modified or updated by the action. It should work on DOM manipulation or API request.
1. Therefore, the returned value from the reducer should be purely from the previous `state` and the action. 
    <img src="./images/pureReducer264.png">

## Mutations in JavaScript
1. Rules of Reducers
    1. Must return **_ANY_** value besides `undefined`.
    1. Produces `state`, or data to be used inside of the app using only previous state and the action (reducers are pure).
    1. Must not return reach `out of itself` to decide what value to return.
    1. **Must not mutate its input `state` argument.**
1. The mutation in JavaScript refers to any action that will modify the orignal data of an object, including JavaScript Array. 
1. Similar to use React, we should **NOT** modify the `state` directly. 
1. We can't modify primitive values, such as `String`, `Number`, and `Boolean` variables that is declared with `const`. However, it's very easy to modify `Array` and `Object` in JavaScript.
    ```js
    // mutation in JavaScript
    const colors = ['red', 'green'];
    colors.push('purple');
    console.log(colors); // ['red', 'green', 'purple']

    colors.pop(); 
    console.log(colors); // ['red', 'green']

    colors[0] = 'PINK';
    console.log(colors); // ['PINK', 'green']

    // mutate object in JavaScript
    const profile = {name: 'Alex'};
    profile.name = 'Sam';
    console.log(profile); // {name: 'Sam'}

    profile.age = 30;
    console.log(profile); // {name: 'Sam', age: 30}

    const name = 'Sam';
    console.log(name[0]); 
    ```

## Equality of Arrays and Objects
1. In JavaScript, we can use triple equal sign to compare to values. 
1. When comparing `Array` or `Object`, it will only be the same when the variables are referring to the same `Array` or `Object` in the memory. 
    ```js
    const number = [1,2,3];
    number === number; // true 
    number === [1,2,3]; // false
    ```

## A Misleading Rule
1. Though the rules for Redux reducers say that we **MUST NOT** mutate the `state` object, we actually can modify it upon or request. We can simply notice this when we manipulate the arrays and objects decalred with `const` keyword. 
1. However, there are some corner cases that can cause issues and problems by modifying the `state` directly that's why the lecture and most of the tutorials noticing that **DO NOT** modify the `state`.
1. We can check the [source code](https://github.com/reduxjs/redux/blob/master/src/combineReducers.ts) to understand how does Redux work.
1. Every time we dispatch an action, the following code will execute.
    ```js
    // https://github.com/reduxjs/redux/blob/master/src/combineReducers.ts
    // the last part from redux/src/combineReducers
    // every time we dispatch an action, the following code will execute
    // note that the package is now written in TypeScript. By the time of the lecture, it's still in regular JavaScript

    let hasChanged = false
    const nextState: StateFromReducersMapObject<typeof reducers> = {}
    for (let i = 0; i < finalReducerKeys.length; i++) { // this for loop iterates through all the reducers
      const key = finalReducerKeys[i]
      const reducer = finalReducers[key]
      const previousStateForKey = state[key] // this is the previous state object that will be manipulate with the action object in the reducer
      const nextStateForKey = reducer(previousStateForKey, action) // this is when the reducer really invokes
      if (typeof nextStateForKey === 'undefined') { // throw an error if the value is undefined. This is aligned with item 2 of the rules that the reducer should not return undefined value 
        const errorMessage = getUndefinedStateErrorMessage(key, action)
        throw new Error(errorMessage)
      }
      nextState[key] = nextStateForKey
      // this will modify hasChanged to be either false or true. If nextStateForKey is not equal to previousStateForKey, it returns true, so hasChanged will be changed to true. Otherwise, it will remain the same as false
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey
    }
    hasChanged =
      hasChanged || finalReducerKeys.length !== Object.keys(state).length
    // by checking whether hasChanged is updated, redux will return either nextState or the current, unmodified state
    // if the nextState is returned, React will rerender the component as the state is updated, and this will be noticed to the whole app 
    return hasChanged ? nextState : state 
    ```
1. Therefore, if we bypass Redux and didn't update the `state` within, it won't know if the `state` is updated and cause rerender to the whole app. Thus, we will see the app doesn't rerender when the state is updated by the reducers. 

## Safe State Updates in Reducers
1. There are several ways to manipulate arrays and objects in JavaScript. The main point is to avoid modifying the `state` object directly.
    <img src="./images/safeStateUpdatesReducers268.png">
1. For example, we can use `rest...` syntax to duplicate a new array with additional elements.
    ```js
    // manipulate arrays
    const colors = ['red', 'green']; 
    [...colors, 'blue']; // work as push to add an element as the last one in the array
    ['purple', ...colors]; // work as unshift to add an element as the first one in the array

    colors.filter(color=> color !== 'green'); // return a new array which doesn't have 'green'

    // manipulate objects
    const profile = { name: 'Sam' };
    { ...profile, name: 'Alex' };
    { ...profile, age: 30 };
    { name: 'Alex', ...profile };
    delete profile.name; // modify the object directly
    profile.name = 'Alex'; // modify the object directly

    ```
1. Though we can duplicate an object and assign `undefined` to "remove" the property from the object, the property (key) is still in the object. Therefore, we can use `lodash` library to remove the property from the duplicated obejct. 
1. `_.omit` method takes 2 arguments which is the object to be duplicated and the property that we wants to remove. 
    ```js
    const profile = {name: 'Sam'};
    let obj = { ...profile, age: 30};
    {...profile, age: undefined}; // duplicate with an object with its name property has undefined value
    _.omit(profile, 'age');

    // what _.omit method does is as the followings
    let object = Object.assign({}, profile);
    object == profile // false, which means these 2 objects are not the same one in the memory
    delete object.name // true
    object // {}
    profile // {name: 'Sam'}
    ```

## Switch Statements in Reducers
1. When have multiple `IF` statement to check conditions, we can use `switch` instead and have `default` to return a value when there's no case matched. 
    ```js
    // src/reducers/postReducer.js
    export default (state = [], action) => {
        switch (action.type) {
            case 'FETCH_POSTS':
                return action.payload;
            default:
                return state;
        }
    }
    ```

## Dispatching Correct Values
1. To connect Redux `store` and React `state`, we should declare and import `mapStateToProps` to `connect` from `react-redux`.
1. In this case, we will see 2 `console.log` in the console. First is an "**empty array**", and the 2nd is the response fetched from the API. 
    ```js
    // src/components/PostList.js
    import React from 'react';
    import { connect } from 'react-redux';
    import { fetchPosts } from '../actions';

    class PostList extends React.Component {
        componentDidMount() {
            this.props.fetchPosts();
        }

        render() {
            console.log(this.props.posts); // check the current state from props
            return <div>Post List</div>;
        }
    }

    const mapStateToProps = (state) => { // connect state with props
        return { posts: state.posts };
    }

    export default connect(mapStateToProps, { fetchPosts })(PostList);
    ```
1. From the code below, we can notice that the `state` is returned when the App initiates.
1. In `PostList`, `componentDidMount` fires `this.props.fetchPosts()` and receive the response which is updated to `store` through `dispatch`.
1. Note that the method has been connected to the `props` of the component and `state`.
1. As in the first there's no data fetched from the endpoint yet, it will return the default value which is the empty array from `postReducer`.
1. The 2nd time when the method is called, `state` is updated from the reducer with `action.payload` that is created from the action object.
    ```js
    // src/reducers/postReducers.js
    export default (state = [], action) => {
        switch (action.type) {
            case 'FETCH_POSTS':
                return action.payload;
            default:
                return state;
        }
    }
    ```
1. However, we can update the action creator to be more specific on the data that we want to manipulate.
1. With `response` from the `axios` request, we will have other properties and meta-data such as `headers` and `request`. 
    ```js
    // src/actions/index.js
    import jsonPlaceholder from '../apis/jsonPlaceholder';

    export const fetchPosts = () => async dispatch => {
        const response = await jsonPlaceholder.get('/posts');
        dispatch({ type: 'FETCH_POSTS', payload: response.data }); // update payload property with only the data that we want to use rather than the whole obejct
    }
    ```

## List Building
1. Since we got the fetched data and passed through `props`, we can use another method in the component to render the list.
1. However, we haven't finished the component because we need `UserHeader` in each of the item as the avatar image for each user. 
1. We can check [posts](http://jsonplaceholder.typicode.com/posts) structure from json placeholder API.
1. Note that each post fetched from the hundred posts has an `userId` which can be aligned with the `user` endpoint with their data. Besides all the posts are created by only 10 users from the dataset. It means that the hundred posts are made from 10 users.
    ```js
    /* http://jsonplaceholder.typicode.com/posts
    {
        "userId": 1,
        "id": 1,
        "title": "sunt aut facere repellat provident occaecati excepturi optio reprehenderit",
        "body": "quia et suscipit\nsuscipit recusandae consequuntur expedita et cum\nreprehenderit molestiae ut ut quas totam\nnostrum rerum est autem sunt rem eveniet architecto"
    }
    */
    import React from 'react';
    import { connect } from 'react-redux';
    import { fetchPosts } from '../actions';

    class PostList extends React.Component {
        componentDidMount() {
            this.props.fetchPosts();
        }

        renderList() {
            return this.props.posts.map(post => {
                return (
                    <div className="item" key={post.id}> // note that we need key attribute for each item in the list
                        <i className="large middle aligned icon user" />
                        <div className="content">
                            <div className="description">
                                <h2>{post.title}</h2>
                                <p>{post.body}</p>
                            </div>
                        </div>
                    </div>
                );
            });
        }

        render() {
            console.log(this.props.posts);
            return (
                <div className="ui relaxed divided list">{this.renderList()}</div>
            );
        }
    }

    const mapStateToProps = (state) => {
        return { posts: state.posts };
    }

    export default connect(mapStateToProps, { fetchPosts })(PostList);
    ```

## Displaying Users
1. There are 2 ways we can aligned the data in each post to the user who creates the post. 
1. Fetch to posts and users all at the same time. It means that every time when we fetch posts, we will fetch all users. However, this has a downside that when the app becomes bigger, we can't use the same solution for the problem. For example, we have millions of articles and users on [medium.com](https://medium.com/). We can't fetch all users and posts to a user when they visit the website.
1. The other way to work around
    1. Fetch posts from the API and wait for the response.
    1. We then show the posts in `PostList` component.
    1. Each element in `PostList` shows `UserHeader`.
    1. `UserHeader` is given ID of user to show. This is given through `props` from `PostList` to `UserHeader` component.
    1. Each `UserHeader` attempts to fetch its user. We will have new action creator to allow `UserHeader` component to fetch user data from from the given `userId`.
    1. We then have multiple user fetching calls to the endpoint.
    1. Each `UserHeader` shows its own user that is fetched individually.
    <img src="./images/flowFetchingUser273.png">

## Fetching Singular Records
1. We create a new action creator `fetchUser` that we will use to fetch each user from the endpoint according to the data from the posts. Note that we request the list of posts from the endpoint, so we name `fetchPosts` with plural.
1. After fetch each user for the posts, we will store them with another reducer `usersReducer`.
1. Note that the data structure respond by json placeholder is different that if we fetch only a single user, the endpoint will return an object. However, if we don't give the specific user to request, the endponit will return an array of objects. 
    ```js
    // src/actions/index.js
    import jsonPlaceholder from '../apis/jsonPlaceholder';

    export const fetchUser = (id) => async dispatch => {
        const response = await jsonPlaceholder.get(`/users/${id}`);
        dispatch({ type: 'FETCH_USER', payload: response.data });
    }
    ```
    <img src="./images/fetchSingularRecords274.png">

## Displaying the User Header
1. In `PostList`, we need to add `UserHeader` to each of the posts that will be rendered in the list.
    ```js
    // src/component/PostList.js
    renderList() {
        return this.props.posts.map(post => {
            return (
                <div className="item" key={post.id}>
                    <i className="large middle aligned icon user" />
                    <div className="content">
                        <div className="description">
                            <h2>{post.title}</h2>
                            <p>{post.body}</p>
                        </div>
                        <UserHeader userId={post.userId} /> // pass userId for each user of the post
                    </div>
                </div>
            );
        });
    }
    ```
1. We create a new component `UserHeader` in component directory. 
    ```js
    // src/component/UserHeader
    import React from 'react';
    import { connect } from 'react-redux';
    import { fetchUser } from '../actions';

    class UserHeader extends React.Component {
        componentDidMount() {
            this.props.fetchUser(this.props.userId);
        }

        render() {
            return (
                <div>User Header</div>
            );
        }
    }

    export default connect(null, { fetchUser })(UserHeader);
    ```

## Finding Relevant Users
1. We use `connect` from `react-redux` package to connect it with Redux to use the action creator.
1. We use `componentDidMount` to run the action creator when the component initiates.
1. We use `filter` array method to get the first user object from `state` that matches the given user id from props.
    1. `this.props.userId` is passing from `PostList`.
    1. `this.props.users` is the `state` which is an array that is updated by reducer.
1. If we can't find the user from the `state`, we will return a `null` (though this is not exactly correct and just used in this case).
    ```js
    // src/component/UserHeader.js
    import React from 'react';
    import { connect } from 'react-redux';
    import { fetchUser } from '../actions';

    class UserHeader extends React.Component {
        componentDidMount() {
            this.props.fetchUser(this.props.userId);
        }

        render() {
            const user = this.props.users.find((user) => user.id === this.props.userId);

            if (!user) {
                return null;
            }

            return (
                <div className="header">{user.name}</div>
            );
        }
    }

    const mapStateToProps = (state) => {
        return {user: state.users}
    }

    export default connect(mapStateToProps, { fetchUser })(UserHeader);
    ```

## Extracting Logic to MapStateToProps
1. Note that we actually want only a single user from the `users` array in the state rather than the whole array. Though there no problem in this case, this cause issues in other projects. There are 2 ways to solve the issue.
    1. We can modify the `props` sending from `PostList` to `UserHeader` component. 
    1. We can modify `mapStateToProps` in the component directly. 
1. `mapStateToProps` can take 2 argument which is the `state` that stores by Redux `store` and `ownProps` that is the `props` which will be passed to the component (`UserHeader` in this case). 
    1. `state` is the `store` object from Redux.
    1. `ownProps` is the `props` object that that this component receives from its parent. 
1. Note that we can change the property name in `props` to `user` (plural to single), as we now only takes the specific user from the `state` rather than the whole array.
    ```js
    // src/component/UserHeader.js
    import React from 'react';
    import { connect } from 'react-redux';
    import { fetchUser } from '../actions';

    class UserHeader extends React.Component {
        componentDidMount() {
            this.props.fetchUser(this.props.userId);
        }

        render() {
            const { user } = this.props; // use destructure assignment to create a variable user

            if (!user) {
                return null;
            }

            return (
                <div className="header">{user.name}</div>
            );
        }
    }

    const mapStateToProps = (state, ownProps) => { // first argument is the store object from Redux, and the 2nd is the props that this component will receive
        return { user: state.users.find(user => user.id === ownProps.userId) };
    }

    export default connect(mapStateToProps, { fetchUser })(UserHeader);
    ```

## That's the Issue
1. The problem in this case is that we have a hundred posts rendered on the page, while each of the post have an user who creates the post. 
1. However, by checking in "**Network**" > "**XHR**" in developer console, we can notice that we have requested to the endpoint for the same users multiple times. 
    <img src="./images/fetchingSameUserMultiTimes278.png">

## Memoizing Functions
1. We can use `_.memoize` method from lodash library, which provides a feature to wrap and return a function with closure in it to check if an argument has been used to execute the function and store the output from the argument. So the next time when the same function is called, it will return the output directly without executing the function. 
    ```js
    // needs lodash library
    // https://lodash.com/docs/4.17.15#memoize

    function getUser(id) {
        fetch(id);
        return 'Made a request';
    }

    const memoizedGetUser = _.memoize(getUser);
    memoizedGetUser(1); // check XHR tab in network in developer console. It made a request to id 1
    memoizedGetUser(1); // it DOES NOT make a request to id 1

    /* the case from the lecture wouldn't be obvious, I have the following function */
    function print(text) {
        console.log(text);
        return text;
    }

    const memoizedPrint = _.memoize(print);
    memoizedPrint('hello'); // console.log is executed 
    memoizedPrint('hello'); // console.log IS NOT executed 
    ```

## Memoization Issues
1. We can't use `_.memoize` method on the action creators directly. As using `redux-thunk` and async request, the action creator returns an async function rather than the object directly. 
1. Therefore, every time the action creator function executes, `_.memoize` a function rather than the result, so either we use `_.memoize` on the action creator or the async function won't work.
    ```js
    // both of the followings won't work
    // fetchUser still keeps sending requests to the endpoint for every single post
    export const fetchUser = _.memoize(function (id) { // wrap the outter function 
        return async function (dispatch) {
            const response = await jsonPlaceholder.get(`/users/${id}`);
            dispatch({ type: 'FETCH_USER', payload: response.data });
        };
    });

    export const fetchUser = function (id) {
        return _.memoize(async function (dispatch) { // wrap the async function
            const response = await jsonPlaceholder.get(`/users/${id}`);
            dispatch({ type: 'FETCH_USER', payload: response.data });
        });
    };
    ```

## One Time Memoization
1. The solution is to use `_.memoize` to remember the response outside of the action creator, so `_.memoize` will only remember the response one time rather than multiple times when the action creator is called.
1. In convention, we can name the memoized function starting with an underscore, so other developers wouldn't accidentally call this function.
1. Since the action creator has no `await` keyword in it, we can take `async` off to execute it as regular function.
1. Note that we should turn the function that `_.memoize` handles as `async` function and pass both `id` and `dispatch` to it.
1. However, this solution has a problem that if the user has update his/her data during the time, we can't use the same action creator to fetch the data, as it will be halt by `_.memoize` if the users has been fetched. 
    ```js
    // src/actions/index.js
    import _ from 'loadsh';
    import jsonPlaceholder from '../apis/jsonPlaceholder';

    export const fetchUser = (id) => dispatch => _fetchUser(id, dispatch);
    const _fetchUser = _.memoize(async (id, dispatch) => {
        const response = await jsonPlaceholder.get(`/users/${id}`);
        dispatch({ type: 'FETCH_USER', payload: response.data });
    });
    ```

## Alternate Overfecthing Solution
1. Another way to work around is to create another action creator `fetchPostsAndUsers`
    1. Call `fetchPosts`
    1. Get list of `posts` 
    1. Find all unique `userId`'s from list of posts
    1. Iterate over unique `userId`'s
    1. Call `fetchUser` with each `userid`
1. Though we can combine all the functions into a single action creator, we may have other use cases such as requesting data of a single user. Therefore, we'd still keep `fetchPosts` and `fetchUser` separated and use another action creator to combine them.
1. We need to refactor the `fetchUser` back to its previous state
    ```js
    // src/actions/index.js
    export const fetchUser = (id) => async dispatch => {
        const response = await jsonPlaceholder.get(`/users/${id}`);
        dispatch({ type: 'FETCH_USER', payload: response.data });
    };
    ```

## Action Creators in Action Creators
1. In this case, as we will only call the combine action creator `fetchPostsAndUsers` which has both `fetchPosts` and `fetchUser` in it, we must to ensure the function is passed to `dispatch` by Redux Thunk to update `store` in Redux.
1. Note that `fetchPosts()` actually returns an async function. When this function passed by `dispatch` to Redux Thunk, it will be executed, so the `dispatch({})` inside can eventually update the `store` object. 
1. Besides, since `fetchPosts` is an async function, we should use `await` keyword to ensure it's finished, so we can execute the function further (the function is also `async`).
    ```js
    // src/actions/index.js
    import _ from 'lodash';
    import jsonPlaceholder from '../apis/jsonPlaceholder';

    export const fetchPostsAndUsers = () => async dispatch => {
        console.log('About to fetch posts'); // print in console before the data is fetched
        await dispatch(fetchPosts()); // fetching data
        console.log('Fetched posts'); // print in console after the data is fetched and updated to Redux
    }

    export const fetchPosts = () => async dispatch => {
        const response = await jsonPlaceholder.get('/posts');
        dispatch({ type: 'FETCH_POSTS', payload: response.data })
    }

    export const fetchUser = (id) => async dispatch => {
        const response = await jsonPlaceholder.get(`/users/${id}`);
        dispatch({ type: 'FETCH_USER', payload: response.data });
    };
    ```

## Finding Unique User Ids
1. After the `posts` are fetched and updated the `state`, we'd like to work on the data returned from the endpoint. 
1. The 2nd function called by Redux Thunk that returned by the action creator can have another argument, `getState`, which is a method on `store` object that can get all the data of Redux `store`.
1. Therefore, we can get the updated list with `getState` from the update `store` object. 
1. We then can use `_.map` which is lodash method that is similar to `Array.map` while it returns the values from the given `key` of the object as an array. 
1. After getting all the `userId` in an array, we can use `_.uniq` from lodash to filter out the array with unique elements. Note that we can also easily use `.map` and `.reduce` array methods to do the same tricks.
    ```js
    // src/actions/index.js
    export const fetchPostsAndUsers = () => async (dispatch, getState) => { // use getState to get all the data from store object
        await dispatch(fetchPosts()); // ensure fetched data is called by redux thunk and update store object
        const userIds = _.uniq(_.map(getState().posts, 'userId'));
        userIds.forEach(id => dispatch(fetchUser(id)));
    }

    const userIds = getState().posts.map(post => post.userId).reduce((arr, id) => {
        if (!arr.includes(id)){
            arr.push(id);
        }
        return arr;
    }, []);
    ```

## Quick Refactor with Chain
1. This is an optional solution. 
1. We can use [`_.chain`](https://lodash.com/docs/4.17.15#chain) method from lodash to concatenate several methods to work directly. Note that we must use `.value()` to close the chained object.
1. According to lodash, `.chain` creates a lodash wrapper instance that wraps `value` with explicit method chain sequences enabled. The result of such sequences must be unwrapped with `_#value`.
    ```js
    export const fetchPostsAndUsers = () => async (dispatch, getState) => {
        await dispatch(fetchPosts());
        // const userIds = _.uniq(_.map(getState().posts, 'userId'));
        // userIds.forEach(id => dispatch(fetchUser(id)));

        _.chain(getState.posts)
            .map('userId')
            .uniq()
            .forEach(id => dispatch(fetchUser(id)))
            .value();
    }
    ```

## App Wrapup
1. Using **Redux Thunk**
    1. In root `index.js` file (`src/index.js`), we import `thunk` from `redux-thunk`.
    1. We then use `createStore` from Redux to wire it up with redux-thunk.
    1. By wiring up, all the actions will pass through the middleware `thunk` and been sent to the reducers.
    ```js
    // src/index.js
    import { createStore, applyMiddleware} from 'redux';
    import thunk from 'redux-thunk';

    const store = createStore(reducers, applyMiddleware(thunk));
    ```
1. Configure **Action Creators**
    1. Besides, wiring up the middle change the behavior of action creators that it can not only return JavaScript objects but functions. 
    1. The returned function can be called automatically with `dispatch` and `getState` arguments.
    1. This feature allows the app to run async functions and wait for the response. Note that the syntax of the action creator is a **function that returns another function**.
    ```js
    // action creators
    function (){
        return async function(dispatch, getState){
            const response = await apiCall();
            dispatch({type: 'AN_ACTION', payload: response.data});
        }
    }

    () => async (dispatch, getState) => {
        const response = await apiCall();
        dispatch({type: 'AN_ACTION', payload: response.data});
    }
    ```
1. Creating **Reducers**
    1. The first argument in the reducer is the `state`, and we can give it a default value when the app initiates. For example, it can be an empty `array` or `object`, `0` as initial number, or empty string before it gets any value. 
    1. Note that the initiate value **MUST NOT** be `undefined` or Redux will return an error. 
    1. When expanding arrays, we can use spread assignment to duplicate a new array.
    1. We **MUST NOT** modify the `state` object directly. 
    1. As action creator would have similar syntax, rather than using `IF` and `ELSE IF` statement, we can use `switch` for different `cases` and use `default` as `ELSE` when there's nothing will be changed.
    ```js
    // reducers
    export default (state = [], action) => {
        switch (action.type) {
            case 'AN_ACTION':
                return [...state, action.payload];
            default:
                return state;
        }
    }
    ```



# Navigation with React Router
## App Outline
1. This app is going to look really complicated, but at its core it is going to be straightforward to build.
1. Our focus is going to be on React/Redux, not any complicated backend pieces.
1. This app is a clone of [twich.tw](https://www.twitch.tv/) and has 3 main components
    1. Real Time Messaging Protocol (RTMP) Server
    1. Web server that knows which streams are currently broadcasting
    1. Viewer's Browser
1. Users can use "Open Broadcaster Software" (OBS) which is used to record works on computers or do livestreaming. 
1. Then the user can connect to a Real Time Messaging Protocol (RTMP) Server.
1. The RTMP server can then broadcast the video feed to multiple different users.
1. Besides, multiple streamers (video feeders) can connect and feed videos to the RTMP server at the same time.
    <img src="./images/twitchCloneAppStructure287.png">
1. Besides the RTMP server, we need another server to provide the list of streaming videos that are available or connected to RTMP server. Note that RTMP server only serves a purpose to allow connection between streamers and viewers.
    <img src="./images/twitchCloneAppOutline287.png">

## Mockups in Details
1. This app has a significat difference between Twitch or other streaming platform that it allows every user create unlimited channels/streams that they can stream to. On Twitch, and usually other streaming platforms, every user will have one stream/channel they can stream to. In the other words, an user can create multiple stream and stream multiple vidoes with the same account at the same time.
1. User is not logged in
    1. User can view a list of all streams/channels
    1. User can view video for a single stream
1. User is logged in 
    1. User can create a new stream/channel
    1. User can **edit** a stream/channel they have created
    1. User can **delete** a stream/channel they have created
1. Therefore, on the index page which has the list of streaming videos on RTMP server will have 2 more buttons for the streamer after they log in.

## App Challenges
1. We create a directory `stream` and, inside `stream`, we create the react app, `client`.
1. App Challenges
    1. Need to be able to navigate around to separate pages in our app
    1. Need to allow a user to login/logout
    1. Need to handle "**forms**" in Redux
    1. Need to master "**CRUD operations**" in React/Redux
    1. Errors will likely occur! Need good error handling

## Inital Setup
1. We firstly remove all the default file from React app and create `index.js` in `src` and `App.js` in `components` as usual.
    ```js
    // src/index.js
    import React from 'react';
    import ReactDOM from 'react-dom';
    import App from './components/App';

    ReactDOM.render(<App />, document.querySelector('#root'));

    // src/components/App.js
    import React from 'react';

    const App = () => {
        return <div>App</div>
    }
    export default App;
    ```

## Introducing React Router
1. We will use another npm package `react-router-dom` which is the the React router we will use in the app. Note that the name of package has `dom`. 
1. There are other similar named packages that we should be aware of what we have installed.
    1. `react-router` is the core navigation library that we don't install this manully
    1. `react-router-dom` is the navigation for dom-based apps (which is used in this project)
    1. `react-router-native` is the navigation for react-native apps 
    1. `react-router-redux` binds between Redux and React Router (which is not necessary)
1. To use `react-router-dom`, we import 2 methods with destructive assignment and get `BrowserRouter` and `Route`.
    1. `BrowserRouter` is a component used to wrap the routes we want to create
    1. `Route` can indicate the path that we want to render certani components to create a page when the user visits the route.
1. Note that we should use `<div>` tags to wrap `Route` tags in `BrowserRouter`.
    ```js
    // src/components/App.js
    // PageOne and PageTwo are mock functions only to show what does react-router-dom do
    import React from 'react';
    import { BrowserRouter, Route } from 'react-router-dom';

    const PageOne = () => {
        return <div>PageOne</div>;
    }
    const PageTwo = () => {
        return (
            <div>
                PageTwo
                <button>Click Me!</button>
            </div>
        );
    }

    const App = () => {
        return (
            <div>
                <BrowserRouter>
                    <div> // Routes should be wrapped with div tags in BrowserRouter
                        <Route path="/" exact component={PageOne} />
                        <Route path="/pagetwo" component={PageTwo} />
                    </div>
                </BrowserRouter>
            </div>
        );
    }

    export default App;
    ```

## How React Router Works
1. React Router doesn't interact with the domain of the URL path. This library only helps us to work on the route at a domain.
    ```js
    // React Router only works with the path in the route which doesn't include the host and port
    window.location.pathname
    ```
1. When using `BrowserRouter` object, it will internally create `history` object. This `history` object will track on the path that the user visits.
    <img src="./images/reactRouterStructure292.png">

## How Paths Get Matched
1. All the `Route` component in `BrowserRouter` has a `path` property. 
    1. At the root path, which is `/`, the component includes an `exact` property.
    1. The `component` property indicates that which component should be rendered when a user visits the path.
1. We can have multiple components in the same route. For example, we can put different components at the root path.
1. The `exact` property is to ensure the component in the parent path doesn't go further into its child path. For example, the component we pass to root path doesn't have `exact`, it will show in the other paths as well because all the other route is under the root path `/`. Besides, the property has a value as default to be `true` when it is given.
1. The keyword changes the behavior of how does React Router evaluates the path extracted from the search bar. 
    1. By default React Router will check if the path contains certain path. For example, when we visit `/pagetwo`, the path contains both `/` and `/pagetwo`.
    1. When using `exact`, React Router will check if the path is exactly the same as the configured path, such as `/`, so it only shows when the user is on a certin path.
    ```js
    const App = () => {
        return (
            <div>
                <BrowserRouter>
                    <div>
                        <Route path="/" exact={true} component={PageOne} /> // 2 PageOne component will be shown at the root path. This component will only show when user visits the root path
                        <Route path="/" component={PageOne} /> // if we don't have exact in the root path, it will show in its child path which is /pagetwo as well
                        <Route path="/pagetwo" component={PageTwo} />
                    </div>
                </BrowserRouter>
            </div>
        );
    }
    ```
    <img src="./images/howReactRouteWorks293">

## How to "Not" Navigate with React Router
1. In regular HTML, we can use an anchor tag `<a>` to navigate in the app. However, this is not ideal to manipulate with React Router
    ```js
    const PageOne = () => {
        return <div>
            <a href="/pagetwo">Navigate to Page Two</a>
        </div>;
    }
    const PageTwo = () => {
        return (
            <div>
                PageTwo
                <button>Click Me!</button>
                <a href="/">Navigate to Page One</a>
            </div>
        );
    }
    ```
1. Using anchor tag is not a good approach as every time a user access a certain path, browser receives `index.html` file, "**dumps old HTML file it was showing**" (including all of your React/Redux state data). Since JavaScript will be removed, all the cache and fetched data or user inserted contents will all be wiped out. 

## Navigating with React Router
1. In the browser, we can check at the "Network" tab that every time we change the route, the browser will request to the server for all the frontend resources, HTML, CSS, and JavaScript. This is redundant that we don't need to reload the page, fetch, and request all the files every time we change the route. Besides, all the data stored in JavaScript and memory will be cleared and wiped out.
1. The way to work around is to use `Link` object from `react-router-dom` to replace anchor tag and use `to` as the property rather than `href`.
1. Note that if we inspect the elements of the page on browser, we will find the `Link` components are actually anchor tags.
    ```js
    import { Link } from 'react-router-dom';
    <Link to='/'>Navigate to Page One</Link>
    ```
1. When using `Link` object
    1. User wants to navigate to another page in the app
    1. user clicks a `Link` tag
    1. React Router prevents the browser from navigating to the new page and fetching new `index.html` file.
    1. URL still changes
    1. `History` sees updated URL, takes URL and sends it to `BrowserRouter`
    1. `BrowserRouter` communicates the URL to Route components

## Different Router Types
1. Note that `BrowserRoueter` is actually browser side route control system which is not integrated directly with server side code. 
1. There are 3 types of React Router we can use 
    1. `BrowserRouter` which uses everything after the TLD (.com, .net) or port as the `path`
    1. `HashRouter` which uses everything after a pound sign `#` as the `path`
    1. `MemoryRouter` which doesn't use the URL to track navigation
1. If we use `HashRouter`, the route will have a `/#` in between the domain and the path. Every time the user naviagtes between the paths, it only changes the path behind the pound sign.
    ```js
    import React from 'react';
    import { HashRouter, Route, Link } from 'react-router-dom';

    const App = () => {
        return (
            <div>
                <HashRouter>
                    <div>
                        <Route path="/" exact component={PageOne}>
                        <Route path="/pagetwo" component={PageTwo}>
                    </div>
                </HashRouter>
            </div>
        );
    }
    ``` 
1. If we use `MemoryRouter`, the URL on the search bar will not change when the user navigates between the paths. 
    ```js
    import React from 'react';
    import { MemoryRouter, Route, Link } from 'react-router-dom';

    const App = () => {
        return (
            <div>
                <MemoryRouter>
                    <div>
                        <Route path="/" exact component={PageOne}>
                        <Route path="/pagetwo" component={PageTwo}>
                    </div>
                </MemoryRouter>
            </div>
        );
    }
    ```
1. In traditional web app service, when a user sends request with a URL via browser to a backend server, the server will check if the route is valid and return an aligned HTML file to the request. 
1. In this scenario, if the user provides a route that doesn't exist on the server, it will return a **404** error as the resource is "**not found**".
1. On the React Development Server, which is the server shows when we run `npm start` and can be accessed through `localhost:3000`, Create-React-App Dev Server will 
    1. Check if there's anything special on the route given by the user
    1. Check `dev` resources and `public` directory. For example, in a regular React App directory, we can access the favicon and JSON file in the public folder with the filename dierctly
    1. If there's nothing configured for the route, React will server up the `index.html` in `public` folder
1. This feature prevent to let the user see a `404` error when the route doesn't exist.
1. In the typical and traditional situation, a server can only return the file (index.html) if the route exists and is configured on the server side. Therefore, it can be very challenging to set up `BrowserRouter` when integrating frontend and backend code. However, modern server framework and cloud hosting services provides more direct and smart integration to deploy React App on the service.
1. Therefore, we can use either `HashRouter` or `MemoryRouter` when integrating with different types of server or backend code.

## Component Scaffolding
1. We have 6 different pages in this project
    1. Index Page - StreamList
    1. Show Stream - StreamShow
    1. Index Page - StreamShow
    1. Create Stream - StreamCreate
    1. Edit Stream - StreamEdit
    1. Delete Stream - StreamDelete
1. For each of the components, we should have specific path for each of them
    1. `/` - StreamList
    1. `stream/new` - StreamCreate
    1. `/streams/edit` - StreamEdit
    1. `/streams/delete` - StreamDelete
    1. `/streams/show` - StreamShow

## Wiring Up Routes
1. As we build up the components, we configure `App.js` by setting up the routes and import the components. 
1. We use `BrowserRouter` in this case. 
    ```js
    import React from 'react';
    import { BrowserRouter, Route, Link } from 'react-router-dom';
    import StreamCreate from './streams/StreamCreate';
    import StreamEdit from './streams/StreamEdit';
    import StreamDelete from './streams/StreamDelete';
    import StreamList from './streams/StreamList';
    import StreamShow from './streams/StreamShow';

    const App = () => {
        return (
            <div>
                <BrowserRouter>
                    <div>
                        <Route path="/" exact component={StreamList} />
                        <Route path="/streams/new" exact component={StreamCreate} />
                        <Route path="/streams/edit" exact component={StreamEdit} />
                        <Route path="/streams/delete" exact component={StreamDelete} />
                        <Route path="/streams/show" exact component={StreamShow} />
                    </div>
                </BrowserRouter>
            </div>
        );
    }

    export default App;
    ```

## Always Visible Components
1. We will build up the header component which is the navigation bar that always floats on the top for users to choose different functinos and login/out. We can see from the following structure that `Header` will always be visible to users. 
1. We can put the component out of `BrowserRouter`, so it will be visible from all the routes with the other components.
    <img src="./images/structureStreamApp300.png">    

## Connecting the Header
1. We will use `Semantic UI` for the styling in the this project, and we create `Header`component that will be used and show in every route in the app. 
1. However, the current set up is not finished yet, and we will get an error message indicating that we are using `Link` out of a `Router`.
    ```js
    // src/components/Header.js
    import React from 'react';
    import { Link } from 'react-router-dom';

    const Header = () => {
        return (
            <div className="ui secondary pointing menu">
                <Link to="/" className="item">
                    Streamer
                </Link>
                <div className="right menu">
                    <Link to="/" className="item">
                        All Streams
                    </Link>
                </div>
            </div>
        );
    }

    export default Header;

    // src/components/App.js
    const App = () => {
        return (
            <div>
                <Header />
                <BrowserRouter>
                    <div>
                        <Route path="/" exact component={StreamList} />
                        <Route path="/streams/new" exact component={StreamCreate} />
                        <Route path="/streams/edit" exact component={StreamEdit} />
                        <Route path="/streams/delete" exact component={StreamDelete} />
                        <Route path="/streams/show" exact component={StreamShow} />
                    </div>
                </BrowserRouter>
            </div>
        );
    }
    ```
    <img src="./images/errorToUseLinkOutOfRouter301.png">

## Links Inside Routers
1. To solve the issues from the last section, we can change the structure and move`Header` component in to `BrwoserRouter` to be right above other components. Besides, since `Header` is not controlled with `Route`, it will show in every route. 
    ```js
    // src/components/App.js
    const App = () => {
        return (
            <div>
                <BrowserRouter>
                    <div>
                        <Header />
                        <Route path="/" exact component={StreamList} />
                        <Route path="/streams/new" exact component={StreamCreate} />
                        <Route path="/streams/edit" exact component={StreamEdit} />
                        <Route path="/streams/delete" exact component={StreamDelete} />
                        <Route path="/streams/show" exact component={StreamShow} />
                    </div>
                </BrowserRouter>
            </div>
        );
    }
    ```
    <img src="./images/linksInsideRoute302.png">



# Handling Authenitcation with React
## OAuth-Based Authentication
1. We will create a new component to allow users to login to the app with Google OAuth.
1. Email/Password Authentication
    1. We store a record in a database with the user's email and password
    1. When the user tries to login, we compare email/pw with whats stored in DB
    1. A user is 'logged in' when they enter the correct email/pw    
1. OAuth Authentication
    1. User authenticates wit houtside service provider (Google, LinkedIn, Facebook)
    1. User authorizes our app to access their information
    1. Outside provider tells us about the user
    1. We are trusting the outside provider to correctly handle identification of a user
    1. OAuth can be used for 
        1. user identification in our app 
        1. our app making action on behalf of user
1. In this case, we are using OAuth to identify the user without using it to manipulate on Google on user's behalf.
1. To setup OAuth, we can either do it on "**Servers**" or "**JS Browser Apps**".
    1. OAuth for Servers
        1. Results in a `token` that a server can use to make requests on behalf of the user
        1. Usually used when we have an app that needs to access user data "**when they are not logged in**"
        1. Difficult to setup because we need to store a lot of info about the user
    1. OAuth for JS Browser Apps
        1. Results in a `token` that a browser app can use to make requests on behalf of the user
        1. Usually used when we have an app that only needs to access user data "**while they are logged in**"
        1. Very easy to set up thanks to Google's JS lib to automate flow

## OAuth for Servers vs Browser Apps
1. The main difference between server-side and browser-side OAuth is that by using server-side OAuth, the App can access to user data even when the user is not actively logged in. However, we don't need the feature in this case. 
1. The flow starts when the user clicks '**Login with Google**' button.
    1. User clicks 'Login with Google' button
    1. We use google's JS lib to initiate OAuth process
    1. Google's JS library makes auth request to Google
    1. Google displays confirmation screen to user in popup window
    1. User accepts
    1. Popup window closes
    1. Google's JS lib invokes a callback in our React/Redux App
    1. Callback provided with '**authorization**' token and profile info for user
1. Note that the callback should also listen to the user action that if the user has logged out from Google.
    <img src="./images/google_browser_oauth306.png">

## Creating OAuth Credentials
1. Steps for setting up OAuth
    1. Create a new project at [`console.developers.google.com/`](https://console.developers.google.com/)
    1. Set up an OAuth confirmation screen
    1. Generate an OAuth Client ID
    1. Install Google's API library, initialize it with the OAuth Client ID
    1. Make sure the lib gets called any time the user clicks on the 'Login with Google' button

## Wiring Up the Google API Library
1. We put the CDN file in the `index.html` in `public` directory with Google's JS lib. 
    ```html
    <script src="https://apis.google.com/js/api.js"></script>
    ```
1. After importing Google JS library, we create a new component `GoogleAuth.js` in `components`
    ```js
    // src/components/GoogleAuth.js
    import React from 'react';

    class GoogleAuth extends React.Component {
        render() {
            return <div>Google Auth</div>
        }
    }

    export default GoogleAuth;
    ```
1. We import `GoogleAuth` into `Header.js`
    ```js
    // src/components/Header.js
    import GoogleAuth from './GoogleAuth';

    const Header = () => {
        return (
            <div className="ui secondary pointing menu">
                <Link to="/" className="item">
                    Streamer
                </Link>
                <div className="right menu">
                    <Link to="/" className="item">
                        All Streams
                    </Link>
                    <GoogleAuth />
                </div>
            </div>
        );
    }
    ```
1. By importing Google JS lib, we can use JavaScript to access a function `gapi` to interact with multiple Google Services.
1. Since the Google JS lib is used by many Apps, Google has made the library as small as possible and every time the App would like to run on certain features, the App needs to request additional JS library from Google according to the requirements.
1. In this case, we'd use Google OAuth, so we use `gapi` to load up `client:auth2` library for OAuth process. After we get the extra JS code, we can see the `gapi` function is updated.
    ```js
    gapi.load('client:auth2');

    gapi(); // gapi is extended with additional code after loading 'auth2'
    ```
1. After understanding how does `gapi` works, we then can start to configure `GoogleAuth.js` component. We start with a lifecycle method `componentDidMount()`. Note that when calling the `gapi.load` method, we need to decalre `gapi` is on the `window` scope or React will return an error that `gapi` is not defined though Google lib has been imported in the global scope.
1. Note that `gapi.load()` makes a request to acquire additional JS code from Google. We can only run the following process after we get the response from the request. Therefore, we pass an arrow function as callback in `window.gapi.load` method.
1. In the callback, we use `window.gapi.client.init` method to start the process with the client ID given in Google Developer Console. Besides, we can request in the "**scope**" that what user's information that the App would like to use.
    ```js
    // src/components/GoogleAuth.js
    import React from 'react';

    class GoogleAuth extends React.Component {
        componentDidMount() {
            window.gapi.load('client:auth2', () => { // a callback function runs after gapi is extended with auth2
                window.gapi.client.init({
                    clientId: 'your client id given in creditials in Google developer console', // given by Google credentials in Google Developer Console
                    scope: 'email' // request to check user's email
                });
            });
        }

        render() {
            return <div>Google Auth</div>
        }
    }

    export default GoogleAuth;
    ```

## Sending a User Into the OAuth Flow
1. We can check [Google sign-in JavaScript client reference](https://developers.google.com/identity/sign-in/web/reference). We can also find the document by searching for "gapi documentation".
1. We mainly use [Authentication](https://developers.google.com/identity/sign-in/web/reference#authentication) section in this case.
1. There are several methods we can refer from the library, such as checking user's login state and initiate OAuth flow.
    ```js
    // after importing and loading auth2 extended library
    const auth = gapi.auth2.getAuthInstance() // get 'GoogleAuth' (which is auth in this case) object by calling gapi.auth2.init()
    auth // we can check this 'auth' object 
    auth.signIn() // starts the OAuth flow for the user to sign in
    auth.isSignedIn.get() // check if the user signs in 
    ```

## Rendering Authentication Status
1. In the Auth component
    1. Get a reference to the `auth` object  after it is initialized
    1. Figure out if the user is currently signed in 
    1. Print their authentication status on the screen
1. `window.gapi.client.init` is an async function that it initates and extend the imported Google JS library. As it's a `Promise` object, we can use `.then` method to chain on it and proceed further function after the `auth` object is initiated.
1. We have a state `isSignedIn` initates as `null` to check if the stats is updated. If it's `null`, it means we don't know whether the user signs in or not. 
    ```js
    // src/components/GoogleAuth.js
    import React from 'react';

    class GoogleAuth extends React.Component {
        state = { isSignedIn: null }; // check if state is updated

        componentDidMount() {
            window.gapi.load('client:auth2', () => {
                window.gapi.client.init({
                    clientId: 'your client id',
                    scope: 'email'
                }).then(() => {
                    this.auth = window.gapi.auth2.getAuthInstance();
                    this.setState({ isSignedIn: this.auth.isSignedIn.get() });
                });
            });
        }

        renderAuthButton() {
            if (this.state.isSignedIn === null) {
                return <div>I don't know if we are signed in</div>;
            } else if (this.state.isSignedIn) {
                return <div>I am signed in!</div>;
            } else {
                return <div>I am not signed in</div>;
            }
        }

        render() {
            return <div>{this.renderAuthButton()}</div>
        }
    }

    export default GoogleAuth;
    ```

## Updating Auth State
1. This part is to focus on updating the login status when the user login or log out on the fly. 
1. We can use `gapi.auth2.getAuthInstance().isSignedIn` to check whether the user is logged in in the current session.
1. Note if we check the object in the developer console of a browser, we can notice that the object has dunder `__proto__` property which inherits properties from the super class. 
    ```js
    const state = { isSignedIn: null};
    const auth = gapi.auth2.getAuthInstance();
    auth.isSignedIn.get(); // use 'get' method to check login status
    auth.listen(onAuthChange); // use 'listen' method to run a callback function when the login status changes
    function onAuthChange() {
        state.setState({ isSignedIn: state.auth.isSignedIn.get() });
    }
    ```
1. Therefore, we can revise the class component of `GoogleAuth.js`.
    ```js
    // src/components/GoogleAuth.js
    import React from 'react';

    class GoogleAuth extends React.Component {
        state = { isSignedIn: null };

        componentDidMount() {
            window.gapi.load('client:auth2', () => {
                window.gapi.client.init({
                    clientId: 'your client key',
                    scope: 'email'
                }).then(() => {
                    this.auth = window.gapi.auth2.getAuthInstance();
                    this.setState({ isSignedIn: this.auth.isSignedIn.get() }); // update state when app initiates
                    this.auth.isSignedIn.listen(this.onAuthChange); // update state on the fly when the login status changes
                });
            });
        }

        onAuthChange = () => {
            this.setState({ isSignedIn: this.auth.isSignedIn.get() });
        }

        renderAuthButton() {
            if (this.state.isSignedIn === null) {
                return <div>I don't know if we are signed in</div>;
            } else if (this.state.isSignedIn) {
                return <div>I am signed in!</div>;
            } else {
                return <div>I am not signed in</div>;
            }
        }

        render() {
            return <div>{this.renderAuthButton()}</div>
        }
    }

    export default GoogleAuth;
    ```

## Displaying Sign in and Sign Out
1. We update the component to show buttons aligned to the state.
    ```js
    // src/components/GoogleAuth.js
    renderAuthButton() {
        if (this.state.isSignedIn === null) {
            return null;
        } else if (this.state.isSignedIn) {
            return (
                <button className="ui red google button">
                    <i className="google icon" />
                    Sign Out
                </button>
            );
        } else {
            return (
                <button className="ui red google button">
                    <i className="google icon" />
                    Sign In with Google
                </button>
            );
        }
    }
    ```

## On-Demand Sign in and Sign Out
1. We can have more helper function `onSignIn` and `onSignOut` as arrow functions (to prevent incorrect `this` reference) and call the functions when the user clicks on the signin/out button according to the `state`.
    ```js
    // src/components/GoogleAuth.js
    onSignIn = () => {
        this.auth.signIn();
    }

    onSignOut = () => {
        this.auth.signOut();
    }

    renderAuthButton() {
        if (this.state.isSignedIn === null) {
            return null;
        } else if (this.state.isSignedIn) {
            return (
                <button onClick={this.onSignOut} className="ui red google button">
                    <i className="google icon" />
                    Sign Out
                </button>
            );
        } else {
            return (
                <button onClick={this.onSignIn} className="ui red google button">
                    <i className="google icon" />
                    Sign In with Google
                </button>
            );
        }
    }
    ``` 

## Redux Architecture Design
1. We revise the confusing name of methods to allow users to sing in/out in `GoogleAuth.js` component.
    ```js
    // src/components/GoogleAuth.js
    onSignInClick = () => {
        this.auth.signIn();
    }

    onSignOutClick = () => {
        this.auth.signOut();
    }
    ```
1. The following is the theoretical flow which is not optimal in this project but to understand how does OAuth process works.
    1. Starting with `GoogleAuth` component, we initiates with either `onSignInClick` or `onSignOutClick` to access `GAPI Auth2` instance that is generated by `window.gapi.load('client:auth2')`.
    1. When the user successfully signs in/out, `GoogleAuth` component calls `onAuthChange` which calls action creator `signIn` or `signOut` which provides reduers to update `Redux Store`.
    1. Though this process can be very tedious, the auth state is now only available in the component which can't be access from the other parts of the app yet. 
    1. We need to know the auth state across the whole applciation to know how to interact with the user. Thus, we should update this state to Redux Store, so that it can be shared in the app.
    <img src="./images.updateAuthState314.png">
1. In the previous flow, we can manipulate and update auth state in the `GoogleAuth` component only. The other approach is to use action creators to access `gapi`.
    1. When the user click on the button in the component, it triggers the action creator which attempts to **try** to login/out by accessing `GAPI Auth2`.
    1. After the process is done, `GAPI Auth2` can use callback function to run another action creator `changeAuth` to update the state in Redux Store.
    1. Redux Store will be passed to all the components in the app that connects to it. 
    <img src="./images.updateAuthProcessInStreamy314.png">

## Redux Setup
1. We update `index.js` at the root directory with `Redux` and `React-Redux`. Note that we should use npm to install the packages first. 
    1. Create `index.js` in `actions` 
    1. Create `index.js` in `reducers` 
    ```js
    // src/index.js
    import React from 'react';
    import ReactDOM from 'react-dom';
    import { Provider } from 'react-redux';
    import { createStore } from 'redux';

    import App from './components/App';
    import reducers from './reducers';

    const store = createStore(reducers);

    ReactDOM.render(
        <Provider store={store}> // wrap and pass store to the App
            <App />
        </Provider>
        ,
        document.querySelector('#root')
    );
    ```

## Connecting Auth with Action Creators
1. In this section, we will update `actions` with `signIn` and `signOut`.
    ```js
    // src/actions/index.js
    export const signIn = () => {
        return {
            type: 'SIGN_IN'
        };
    };

    export const signOut = () => {
        return {
            type: 'SIGN_OUT'
        };
    };
    ```
1. We then updates `GoogleAuth.js` to wire up Redux Store and the `actions` by using `connect`.
1. The method to update the auth state can be updated to receive the state, which is a boolean value, as argument and decide whether to sign the in or out. 
1. The function may work in this way because the `listen` method of `gapi` pass a boolean value to the callback function of this method. The concept is similar to use `addEventListener` in frontend JavaScript that the callback function will get an `event` argument.
    ```js
    // src/components/GoogleAuth.js
    import { connect } from 'react-redux';
    import { signIn, signOut } from '../actions';

    class GoogleAuth extends React.Component {
        onAuthChange = (isSignedIn) => {
            if (isSignedIn) {
                this.props.signIn();
            } else {
                this.props.signOut();
            }
        }
    }

    export default connect(null, { signIn, signOut })(GoogleAuth);
    ```

## Building the Auth Reducer
1. We will call the action creators and update the auth state according to the `gapi` library.
1. Create another reducer `authReducer.js` in `reducers` directory.
1. Use all capital characters to name the object which is to initiates teh state. All capital naming means that we shouldn't try to moidfy the object in any circumstances. 
1. Use `switch` statement to handle different actions. 
    ```js
    const INITIAL_STATE = {
        isSignedIn: null
    }

    export default (state = INITIAL_STATE, action) => {
        switch (action.type) {
            case 'SIGN_IN':
                return { ...state, isSignedIn: true };
            case 'SIGN_OUT':
                return { ...state, isSignedIn: false };
            default:
                return state;
        }
    };
    ```
1. Import `authReducer` to `index.js` in `reducers` directory.
    ```js
    // src/reducers
    import { combineReducers } from 'redux';
    import authReducer from './authReducer';

    export default combineReducers({
        auth: authReducer // assign as auth key
    });
    ```

## Handling Auth Status Through Redux
1. Since we are using Redux Store to manage the state, we remove the local `state` object and create `mapStateToProps` and pass it to Redux through `connect`. 
1. The `listen` method of `gapi` instance will pass a boolean value which stands for the login state of the user, so the value will either be `true` or `false` to indicate if the user is logged in.
1. We can refer to [documentation](https://developers.google.com/identity/sign-in/web/reference#googleauthissignedinlistenlistener) for further details.
    ```js
    import React from 'react';
    import { connect } from 'react-redux';
    import { signIn, signOut } from '../actions';

    class GoogleAuth extends React.Component {
        // remove the initial local state
        componentDidMount() {
            window.gapi.load('client:auth2', () => {
                window.gapi.client.init({
                    clientId: 'your client key',
                    scope: 'email'
                }).then(() => {
                    this.auth = window.gapi.auth2.getAuthInstance();

                    this.onAuthChange(this.auth.isSignedIn.get()); // call and update the state directly
                    this.auth.isSignedIn.listen(this.onAuthChange); // listen method will pass a boolean argument to indicate the state of login
                });
            });
        }

        onAuthChange = (isSignedIn) => {
            if (isSignedIn) {
                this.props.signIn();
            } else {
                this.props.signOut();
            }
        }

        onSignInClick = () => {
            this.auth.signIn();
        }

        onSignOutClick = () => {
            this.auth.signOut();
        }

        renderAuthButton() {
            if (this.props.isSignedIn === null) {
                return null;
            } else if (this.props.isSignedIn) {
                return (
                    <button onClick={this.onSignOutClick} className="ui red google button">
                        <i className="google icon" />
                        Sign Out
                    </button>
                );
            } else {
                return (
                    <button onClick={this.onSignInClick} className="ui red google button">
                        <i className="google icon" />
                        Sign In with Google
                    </button>
                );
            }
        }

        render() {
            return <div>{this.renderAuthButton()}</div>
        }
    }

    const mapStateToProps = (state) => {
        return { isSignedIn: state.auth.isSignedIn }
    }

    export default connect(
        mapStateToProps,
        { signIn, signOut }
    )(GoogleAuth);
    ```

## Fixed Action Types
1. Since the type of action creators are given in strings with capital letters, it's very easy to have typo and misspelling.
    ```js
    // src/actions/types.js
    export const SIGN_IN = 'SIGN_IN';
    export const SIGN_OUT = 'SIGN_OUT';

    // src/actions/index.js
    import { SIGN_IN, SIGN_OUT } from './types';
    export const signIn = () => {
        return {
            type: SIGN_IN
        };
    };
    export const signOut = () => {
        return {
            type: SIGN_OUT
        };
    };

    // src/reducers/authReducer.js
    import { SIGN_IN, SIGN_OUT } from '../actions/types';

    const INITIAL_STATE = {
        isSignedIn: null
    }

    export default (state = INITIAL_STATE, action) => {
        switch (action.type) {
            case SIGN_IN:
                return { ...state, isSignedIn: true };
            case SIGN_OUT:
                return { ...state, isSignedIn: false };
            default:
                return state;
        }
    };
    ```

## Recording the User's ID
1. With `gapi` instance, we can get the user's Google ID when the user signs in. We can use `.currentUser.get().getId()` method to retrieve user id from the instance. 
    ```js
    gapi.auth2.getAuthInstance().currentUser.get().getId();
    ```
1. Therefore, when the user signs in through `GoogleAuth` component, we can pass the user id through `gapi` instance.
    ```js
    // src/components/GoogleAuth.js
    class GoogleAuth extends React.Component {
        onAuthChange = (isSignedIn) => {
            if (isSignedIn) {
                this.props.signIn(this.auth.currentUser.get().getId()); // retrieve user id from gapi instance
            } else {
                this.props.signOut();
            }
        }
    }
    ``` 
1. We then can update the `signIn` action creator in `actions/index.js`. We pass the `userId` to `payload`.
    ```js
    // src/actions/index.js
    export const signIn = (userId) => {
        return {
            type: SIGN_IN,
            payload: userId
        };
    };
    ```
1. When the action is called to update Redux Stoer with reducers, we can update the state with `payload`. We can have another property `userId` in the state object. 
1. Note that when the user signs out, we should turn `userId` state back to `null`.
    ```js
    // src/reducers/authReducer.js
    const INITIAL_STATE = {
        isSignedIn: null,
        userId: null
    }

    export default (state = INITIAL_STATE, action) => {
        switch (action.type) {
            case SIGN_IN:
                return { ...state, isSignedIn: true, userId: action.payload };
            case SIGN_OUT:
                return { ...state, isSignedIn: false, userId: null };
            default:
                return state;
        }
    };
    ```



# Reducx Dev Tools
## Using Redux Dev Tools to Inspect the Store
1. During developing, we can use [Redux Devtool](https://github.com/zalmoxisus/redux-devtools-extension) to make our life easier. We can visit the github repo and download the extension directly to the local browser.
1. After installing the extension, we should wire it up in the app to allow accessing it. We can check [Advanced store setup](https://github.com/zalmoxisus/redux-devtools-extension#12-advanced-store-setup) for more details.
1. The main features of the devtool is to help us along the useflow
    1. Track on the actions on the left panel
    1. Track on the state changes on the right panel 
1. We can not only track the state and actions along the useflow but also click "jump" on each action to check the state at each action. 
    <img src="./images/reduxDevToolExtension321.png">
1. By using this extension, we can also visit and check other projects in real (such as [Airbnb](https://www.airbnb.com/), though it may not work at the point of visit).
    ```js
    import React from 'react';
    import ReactDOM from 'react-dom';
    import { Provider } from 'react-redux';
    import { createStore, applyMiddleware, compose } from 'redux'; // add applyMiddleware and compose from redux

    import App from './components/App';
    import reducers from './reducers';

    const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose; // wire up redux to browser extension
    const store = createStore(
        reducers,
        composeEnhancers(applyMiddleware()) // use middleware for redux
    );

    ReactDOM.render(
        <Provider store={store}>
            <App />
        </Provider>
        ,
        document.querySelector('#root')
    );
    ```

## Debug Sessions with Redux Dev Tools
1. We can use query string `?debug_session=[some_string]` after `localhost:3000` when using redux devtool extension. This key is to notice the extension that we want to start a debug session.
1. This feature can be very useful that the extension can remember multiple session for different scenarios we create, such as logging in and other action and sepcific useflow, so we can switch and check the states and conditions between different use cases.



# Handling Forms with Redux Form
## Forms with Redux Form
1. In this section, we are going to work on `StreamCreate` component which is for a user to create a stream on the app. 
1. In addition, we can use `redux-form` to work on the project.
1. In regular conditions, we create a component scope `state` which listen and handles all the changes to the input data to the component. 
    <img src="./images/handlingInputsWithoutRedux324.png">
1. By using `redux-form`, we can skip the repetitive process to keep wiring up Redux `store` with `maptStateToProps` and `Action Creator` betwen Redux and the component.
    <img src="./images/handlingInputsWithDOM324.png">

## Useful Redux Form Examples
1. [Wizard From](https://redux-form.com/8.3.0/examples/wizard/) can be a very useful form for different purpose.
1. This is used to collect multiple inputs from a user such as data to create a new account.

## Conencting Redux Form
1. We then add the `redux-form` library into our `index.js` in `reducers`.
1. Note that we may have multiple reducers in the project, we can use `as` syntax to change the variable name when importing variables from the other library.
1. After wiring up the reducer, we can check in Redux DevTool in `State` and `Tree` that we have `form` object which keeps all the information related to the form.
    ```js
    // src/reducers/index.js
    import { combineReducers } from 'redux';
    import { reducer as formReducer } from 'redux-form';
    import authReducer from './authReducer';

    export default combineReducers({
        auth: authReducer,
        form: formReducer
    });
    ```

## Creating Forms
1. At the current stage, we can check at route `/stream/new` for the default setting of creating a stream. 
1. We then update the `StreamCreate` component from a functional component to a class-based component which could help us  organize the helper methods. 
1. When using `redux-form`, we import `Field` and `reduxForm`. 
1. We can notice that these variables have different naming syntax. `Field` is a React component that shows HTML element on the screen.
1. On the other hand, `reduxForm` is a function which works similar to `connect` for `react-redux`, we can use it to wire up the component which can do `mapStateToProps` and action creator.
1. Similar to `connect`, `reduxForm` returns a function which wires up the React component that is passed to it. We pass only one option to configure the function as `form` which is used to indicate what is the form used for. 
1. After wiring up with `reduxForm`, we can check what have been passed to the component by printing `this.props`. We will use the `prop` passed to the component to create the form we need.
1. We then can create a `form` element and pass `Field` component which is imported from `redux-form` library. Note that a `Field` is some type of input which we would like users to fill in. These fields can be text input, checkbox, or any other type of inputs available on HTML.
1. We firstly give `name` attribute to `Field` which is to indicate what will the component be handling. This is similar to `name` attribute for an `input` element.
    ```js
    // src/components/StreamCreate.js
    import React from 'react';
    import { Field, reduxForm } from 'redux-form';

    class StreamCreate extends React.Component {
        render() {
            console.log(this.props); // check props after wiring up
            return (
                <form>
                    <Field name="title" />
                    <Field name="description" />
                </form>
            )
        }
    }

    export default reduxForm({
        form: 'streamCreate' // in convention, this is to name the form for its purpose
    })(StreamCreate);
    ```
1. By using `Field` we have the first part connected by Redux Form library automatically.
    <img src="./images/createForms327.png">

## Automatically Handling Events
1. To show the input type of the screen of the `Field` component, we have to give `component` attribute in it. 
1. Redux form works only on automating the process of wiring up the components, but it doesn't know the DOM and real elements to be shown on the screen. Therefore, we have to give the component to render by ourselves.
1. We can give the render helper function an argument which will be passed by `Field` component.
    <img src="./images/automaticallyHandleEventByField328.png">
1. By checking the argument in developer tools, we can find that `formProps` has property `name` which is given by each `Field` component.
    ```js
    // src/components/streams/StreamCreate.js
    class StreamCreate extends React.Component {
        renderInput(formProps) {
            console.log(formProps);
            return (<input />)
        }

        render() {
            return (
                <form>
                    <Field name="title" component={this.renderInput} />
                    <Field name="description" component={this.renderInput} />
                </form>
            )
        }
    }
    ```
1. Then we can wire up and send the input data back to Redux Form and keep the value in Redux store.
1. If we insert and value to the `input` elements, Redux will be updated with the latest value inserted. 
    ```js
    // src/components/streams/StreamCreate.js
    renderInput(formProps) {
        return (
            <input
                onChange={formProps.input.onChange}
                value={formProps.input.value}
            />
        );
    }
    ```
1. In addition, we can use JSX and JavaScript shorthands to assign the attributes. We firstly destructive assign `input` from `formProps` and use spread assignment to assign all the attributes from `formProps.input` to the element.
    ```js
    // JSX shorthand for the same purpose
    renderInput({input}) { // works exactly the same as code above
        return <input {...input}>
    }
    ```

## Customizing Form Fields
1. We can pass more attributes through `Field` to the `input` elements, such as `label`.
1. In the component in `Field`, we can take the value from the argument and create elements accordingly. In this case, we can reuse the component to create `label`.
1. Besides, we can use Semantic UI CSS library to style the elements. 
    ```js
    // src/components/streams/StreamCreate.js
    class StreamCreate extends React.Component {
        renderInput({ input, label }) {
            return (
                <div className="field">
                    <label>{label}</label>
                    <input {...input} />
                </div>
            );
        }

        render() {
            return (
                <form className="ui form">
                    <Field name="title" component={this.renderInput} label="Enter Title" />
                    <Field name="description" component={this.renderInput} label="Enter Description" />
                </form>
            )
        }
    }
    ```

## Handling Form Submission
1. In general condition, we'd like to have a button for users to click and submit the request to create a stream in the App. In the callback function passing to the `onSubmit` event handler, we will have `event` argument and call its `event.preventDefault()` method to prevent redicting the user.
    ```js
    formDOM.addEventHandler('submit', function(event){
        event.preventDefault();
    })
    ```
    <img src="./images/handleFormSubmit330.png">
1. If we check the `props` that is sending from redux form connection, we can find a method `handleSubmit`. We can call this in the `form` element with `onSubmit` event handler. Note that Redux Form library has been using `event.preventDefault()`, so we don't need to call it again in the callback function.
1. Besides, `handleSubmit` will pass an argument to the callback function it receives which provides the values that the `form` collects.
1. However, we should validate the input from users and prevent having empty string or invalid data when the submit event fires. 
    ```js
    onSubmit(formValues) {
        console.log(formValues); // check object of values that the form element collects
    }

    render() {
        return (
            <form onSubmit={this.props.handleSubmit(this.onSubmit)} className="ui form">
                <Field name="title" component={this.renderInput} label="Enter Title" />
                <Field name="description" component={this.renderInput} label="Enter Description" />
                <button className="ui button primary">Submit</button> // fire submit event in the form
            </form>
        )
    }
    ```
    <img src="./images/printFormArgs330.png">
    
## Validation of Form Inputs
1. We create a validator to check if the user has given valid input for each field we require through the `form` element.
1. The validator will work when the `form` is firstly rendered or when a user interacts with the form such as typing some inputs and submitting the inputs.
1. If the validator function returns an empty JavaScript object `{}`, it means the inputs to the form are valid. Note that the validator is not created as a method in `StreamCreate` class component. 
1. Otherwise, we assign key-value pairs to the object we are going to return with the properties as the name of the field that has error. We then give the error message as the value of the property.
    ```js
    // src/components/streams/StreamCreate.js
    // this is a standalone function variable rather than in the StreamCreate class component
    const validate = (formValues) => { 
        const errors = {}
        if (!formValues.title) {
            // only ran if the user did not enter a title
            errors.title = 'You must enter a title';
        }

        if (!formValues.description) {
            errors.desription = 'You must enter a description'
        }

        return errors
    }
    ```

## Displaying Validation Messages
1. We wire up the validator with Redux Form which is similar to `mapStateToProps` when connecting Redux Store. 
1. Note that the validator function will fire when the component is firstly rendered and every time the user interacts with the `form` element, such as typing inputs or submit.
1. When the component is rendered, Redux form will check if there's any property in the object returned from the validator and map the `name` attribute of the `Field` component and pass an argument if there's an error.
1. In `renderInput` that we creates the view of `Field` components, we can have `meta` in the destructive assignment which has `error` property that carries the error message we set up in the validator.
1. Therefore, we will see the error message directly when we firstly visit the page, as there's nothing in the input, so the validators run and return error message 
    ```js
    class StreamCreate extends React.Component {
        renderInput({ input, label, meta }) { // meta is the argument given to the validator
            console.log(meta); 
            return (
                <div className="field">
                    <label>{label}</label>
                    <input {...input} />
                    <div>{meta.error}</div> // show error message from meta object
                </div>
            );
        }
    }

    const validate = (formValues) => {
        const errors = {}
        if (!formValues.title) {
            errors.title = 'You must enter a title';
        }

        if (!formValues.description) {
            errors.description = 'You must enter a description';
        }

        return errors;
    }

    export default reduxForm({
        form: 'streamCreate', // in convention, this is to name the form for its purpose
        validate // wire up validator to redux form
    })(StreamCreate);
    ```
    <img src="./images/displayingValidationMessages332.png">

## Showing Errors on Touch
1. We can only show the error message to the user when the user "**focus**" on the input which is when clicking the area of the input bar, so we can validate the input value when the user click out the input bar to "**cancel focus**". This provides a friendly and clearer instruction to users.
1. Note that we can cancel auto complete feature (which is auto generate options according to records in the browser for similar fields).
1. Here has a critical difference in JSX and regualr HTML that the attribute name must be in camel case as `autoComplete` in JSX, while its counterpart in HTML is `autocomplete`. Besides, to turn the attribute off, we use `off` rather than `false`. 
    ```html
    <input autoComplete="off"> 
    <!-- JSX with Complete starts with Uppercase C-->
    <input autocomplete="off"> 
    <!-- HTML -->
    ```
1. There are several properties in `meta` object that we can refer, such as `touched` and `active`. Every time the user "**focus**" on the input and "**unfocus**" the element, `renderInput` will be trigerred and rerender the component. If we put `console.log` to print `meta` object, we can see the changing between different state.
    1. `active` is a boolean value which indicates if the user is "focusing" on the element.
    1. `touched` is also a boolean value and will be `false` when the component is firstly rendered. It will become `true` when the user ever "focuses" on the element.
1. In this case, we can check `touched` state from `meta` object to decide whether to show the error message on the screen.
1. We then create an helper method in the component `renderError` to render another component. 
    ```js
    // src/components/streams/StreamCreate.js
    renderError({ error, touched }) {
        if (touched && error) {
            return (
                <div className="ui error message">
                    <div className="header">{error}</div>
                </div>
            );
        }
    }

    renderInput ({ input, label, meta }) {
        return (
            <div className="field">
                <label>{label}</label>
                <input autoComplete="off" {...input} />
                <div>{this.renderError(meta)}</div> // this gives an error as 'this' refers to the wrong object 
            </div>
        );
    }
    ```
1. Note that we will get an error directly by doing some because when we want to refer to another function in the class based method, we have to refer to the correct `this` in the correct lexical scope. The error message shows that we are trying to use a method from `undefined`. 
1. Therefore, we can turn `renderInput` into an arrow function to allow the method refer to the correct `this` from the class instance. 
1. However, after fixing the scope issue, we still can't see the error message when we firstly interact with the `input` elements because Semantic UI hides the error message by default. 
    ```js
    renderInput = ({ input, label, meta }) => { // turn renderInput method as arrow function
        return (
            <div className="field">
                <label>{label}</label>
                <input autoComplete="off" {...input} />
                <div>{this.renderError(meta)}</div> 
            </div>
        );
    }
    ```
1. If we check the "elements" in developer console, we will find the elements listed in the HTML file, while their `display` property is set to `none`. 

## Highlighting Errored Fields
1. To solve the issue from the last section, we can simply add `error` to the class of `form` element.
    ```js
    <form
        onSubmit={this.props.handleSubmit(this.onSubmit)}
        className="ui form error"> // add "error" class for Semantic UI
        <Field name="title" component={this.renderInput} label="Enter Title" />
        <Field name="description" component={this.renderInput} label="Enter Description" />
        <button className="ui button primary">Submit</button>
    </form>
    ```
    <img src="./images/highlightErrorMessageFields334.gif">
1. Besides, we can update a fancy feature to turn the input red by using class `error` from Semantic UI in `renderInput` method. 
    ```js
    // src/components/streams/StreamCreate.js
    renderInput = ({ input, label, meta }) => {
        const className = `field ${meta.error && meta.touched ? 'error' : ''}`
        return (
            <div className={className}>
                <label>{label}</label>
                <input autoComplete="off" {...input} />
                <div>{this.renderError(meta)}</div> {/* show error message from meta object*/}
            </div>
        );
    }
    ```



# REST-based React Apps 
## Creating Streams 
1. After we finish the form to create the title and description of a new streaming input, we need connect the React app to the API server that a new stream is available for viewing.
1. The list of available streams will be then sent back to the React app for users to select which stream that the user wants to watch.
    <img src="./images/creatingStream335.png">

## REST-ful Conventions
1. We will use JSON Server with REST-ful conventions. This is a conventional design pattern which makes developers working easier with each others.
    <img src="./images/restfulConvention336.png">

## Setting Up an API Server
1. We then create another direcotry in `streams` project as `api` and initiate another npm project with `npm init -y`.
1. After installing JSON server with `npm install --save json-server`, we create `db.json` file in the folder to serve as the database for the API server.
    ```json
    // db.json
    {
        "streams": []
    }
    ```
1. In `package.json`, we remove the default `test` script, and have `"start": "json-server -p 3001 -w db.json".
1. JSON server follows the conventions of REST-ful API, so we can use CRUD commands with the conventional endpoint for `streams`. 
    <img src="./images/restfulConvention336.png">

## Creating Streams Through Action Creators
1. Since we are going to make request to server, we need `axios` and `redux-thunk` to serve on the purpose.
1. We can create an additional folder to store the axios instance with the `baseURL`.
1. Create `apis` folder in `src` with a file `streams.js`
    ```js
    // src/apis/streams.js
    import axios from 'axios';

    export default axios.create({
        baseURL: 'http://localhost:3001'
    });
    ```
1. We then import the instance to `index.js` in `actions`.
    ```js
    // src/actions/index.js
    import streams from '../apis/streams'; // import axios instance
    import { SIGN_IN, SIGN_OUT } from './types';

    export const signIn = (userId) => {
        return {
            type: SIGN_IN,
            payload: userId
        };
    };

    export const signOut = () => {
        return {
            type: SIGN_OUT
        };
    };

    export const createStream = (formValues) => async dispatch => {
        streams.post('/streams', formValues);
    };
    ```
1. After configuring all the stuffs above, we'd like to import them to use in `StreamCreate` component.
1. However, since we have wired the component up with `reduxForm`, we should another syntax to connect with `react-redux`.
    ```js
    // src/components/streams/StreamCreate.js
    import { connect } from 'react-redux';
    import { createStream } from '../../actions';
    ```

## Creating a Stream with REST Conventions
1. To wire up the component with `react-redux`, we can use `connect` to wrap the component to export or declare the current wired component (with `reduxForm`) as a variable and 
    ```js
    // src/components/streams/StreamCreate.js
    // wrap directly
    export default connect(null, {createStream})(reduxForm({
        form: 'streamCreate',
        validate
    })(StreamCreate))

    // decalre variable and wrap with connect 
    const formWrapped = reduxForm({
        form: 'streamCreate', // in convention, this is to name the form for its purpose
        validate
    })(StreamCreate);

    export default connect(null, { createStream })(formWrapped);
    ```
1. We then go back to root `index.js` and use `redux-thunk`
    ```js
    // index.js
    import React from 'react';
    import ReactDOM from 'react-dom';
    import { Provider } from 'react-redux';
    import { createStore, applyMiddleware, compose } from 'redux';
    import reduxThunk from 'redux-thunk'; // import redux thunk 

    import App from './components/App';
    import reducers from './reducers';

    const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;
    const store = createStore(
        reducers,
        composeEnhancers(applyMiddleware(reduxThunk)) // use redux thunk as middleware
    );

    ReactDOM.render(
        <Provider store={store}>
            <App />
        </Provider>
        ,
        document.querySelector('#root')
    );
    ```
1. Note that we should declare `onSubmit` method as "**arrow function**" to prevent refernce scope error for `this` in the component. 
1. After creating a new stream on the page, we can check `db.json` that there's a new records created in the JSON file.

## Dispatching Actions After Stream Creation
1. After submitting the form to the local database, we can check on the "Network" tab and preview the response from the json server. We should handle the response after getting response from the server.
1. For example, we can create a new Stream with "Other Stream" as the title and "Here's some stream" as the description.
    ```json
    {
        "title": "Other Stream",
        "description": "Here's some stream",
        "id": 2
    }
    ```
1. In `index.js` in `actions` directory, we can use `dispatch` to handle the response from the POST request.
1. Note that the JSON replied from the database is stored in the `.data` property of the response. 
    ```js
    // src/actions/types.js
    export const CREATE_STREAM = 'CREATE_STREAM';

    // src/actions/index.js
    import { SIGN_IN, SIGN_OUT, CREATE_STREAM } from './types';
    export const createStream = (formValues) => async dispatch => {
        const response = await streams.post('/streams', formValues);

        dispatch({ type: CREATE_STREAM, payload: response.data }); // the data of response is stored in .data property
    };
    ```

## Bulk Action Creators
1. The REST API we set up will respond data accordingly. According to the chart, as we have known what are the response from each action. Therefore, if we follow the REST API in convention, we can create the action creators for all the operations. 
    <img src="./images/responseFromRestAPI341.png">
1. When we build up the action creators, we should be very careful with the typos which can cause errors. 
    ```js
    // src/actions/types.js
    export const SIGN_IN = 'SIGN_IN';
    export const SIGN_OUT = 'SIGN_OUT';
    export const CREATE_STREAM = 'CREATE_STREAM';
    export const FETCH_STREAMS = 'FETCH_STREAMS'; // multiple
    export const FETCH_STREAM = 'FETCH_STREAM'; // single
    export const DELETE_STREAM = 'DELETE_STREAM';
    export const EDIT_STREAM = 'EDIT_STREAM';
    
    // src/actions/index.js
    import streams from '../apis/streams';
    import {
        SIGN_IN,
        SIGN_OUT,
        CREATE_STREAM,
        FETCH_STREAMS,
        FETCH_STREAM,
        DELETE_STREAM,
        EDIT_STREAM
    } from './types';

    export const signIn = (userId) => {
        return {
            type: SIGN_IN,
            payload: userId
        };
    };

    export const signOut = () => {
        return {
            type: SIGN_OUT
        };
    };

    export const createStream = (formValues) => async dispatch => {
        const response = await streams.post('/streams', formValues);

        dispatch({ type: CREATE_STREAM, payload: response.data });
    };

    export const fetchStreams = () => async dispatch => {
        const response = await streams.get('/streams');

        dispatch({ type: FETCH_STREAMS, payload: response.data });
    };

    export const fetchStream = (id) => async dispatch => {
        const response = await streams.get(`/streams/${id}`);

        dispatch({ type: FETCH_STREAM, payload: response.dat });
    }

    export const editStream = (id, formValues) => async dispatch => {
        const response = await streams.put(`/streams/${id}`, formValues);

        dispatch({ type: EDIT_STREAM, payload: response.data });
    }

    export const deleteStream = (id) => async dispatch => {
        await streams.delete(`/streams/${id}`);

        dispatch({ type: DELETE_STREAM, payload: id });
    }
    ```

## Object-Based Reducers
1. Since we have built up all the action creators, we can also build all the reducers for the project.
1. To handle a list of items, we can have the structure as an array of objects.
    ```js
    let array = [
        {
            id: 1,
            title,
            description
        },
        {
            id: 2,
            title,
            description
        },
        ...
    ]
    ```
1. On the other hand, we can use an object as a collection of records.
    ```js
    let object = {
        1: {
            id,
            title,
            description
        },
        2: {
            id,
            title,
            description
        },
        ...
    }
    ```
1. The reason to use an object rather than an array is that it's easier and more efficient to edit items in the collection.
    <img src="./images/objectBasedReducer342.png">
1. If we use an array to keep the list of items, we would have the following structure.
    ```js
    // sample code
    // collection in array
    const streamReducer = (state = [], action) => {
        switch (action.type) {
            case EDIT_STREAM:
                return state.map(stream => {
                    if (stream.id === action.payload.id) {
                        return action.payload;
                    } else {
                        return stream;
                    }
                });
            default:
                return state;
        }
    };

    // collection in object
    const streamReducer = (state = {}, action) => {
        switch (action.type) {
            case EDIT_STREAM:
                const newState = { ...state };
                newState[action.payload.id] = action.payload;
                return newState;
            default:
                return state;
        }
    }
    ```

## Key Interpolation Syntax
1. Though the regular object approach still needs multiple lines to assign new response data, we can sue "**Key Interpoloation**" from JavaScript to turn the operations into a single line. 
1. The syntax is to take the value from a variable and create a new key on the object. This will prevents JavaScript to create the key using the name of the variable and use its value instead.
1. Note that if the object has had the key from the data of variable, it will be updated to the new value given. Otherwise, a new property will be added to the object. 
    ```js
    const streamReducer = (state = {}, action) => {
        switch (action.type) {
            case EDIT_STREAM:
                // const newState = { ...state };
                // newState[action.payload.id] = action.payload;
                // return newState;
                return { ...state, [action.payload.id]: action.payload };
            default:
                return state;
        }
    }
    ```

## Handling Fetching, Creating, and Updating
1. In `reducers`, we can create another file `streamReduer.js` to handle each action on the REST API. 
    ```js
    // src/components/reducers/streamReducer.js
    import {
        FETCH_STREAM,
        FETCH_STREAMS,
        CREATE_STREAM,
        DELETE_STREAM,
        EDIT_STREAM
    } from '../actions/types';

    export default (state = {}, action) => {
        switch (action.type) {
            case FETCH_STREAM:
                return { ...state, [action.payload.id]: action.payload };
            case CREATE_STREAM:
                return { ...state, [action.payload.id]: action.payload };
            case EDIT_STREAM:
                return { ...state, [action.payload.id]: action.payload };
            default:
                return state;
        }
    }
    ```

## Deleting Properties with Omit
1. We install `lodash` package to use its `_.omit()` method to remove a property from an object. This method will duplicate the object and remove the given key from the 2nd argument. Besides, it doesn't manipulate on the original object directly.
    ```js
    // src/components/reducers/streamReducer.js
    import _ from 'lodash';

    import {
        FETCH_STREAM,
        FETCH_STREAMS,
        CREATE_STREAM,
        DELETE_STREAM,
        EDIT_STREAM
    } from '../actions/types';

    export default (state = {}, action) => {
        switch (action.type) {
            case FETCH_STREAM:
                return { ...state, [action.payload.id]: action.payload };
            case CREATE_STREAM:
                return { ...state, [action.payload.id]: action.payload };
            case EDIT_STREAM:
                return { ...state, [action.payload.id]: action.payload };
            case DELETE_STREAM:
                return _.omit(state, action.payload); // the payload has been the id already from DELETE action creator
            default:
                return state;
        }
    }
    ```
1. However, we can also proceed the methdo without using `lodash`.
    ```js
    let animals = {
        cat: 'meow',
        dog: 'bark'
    }
    let delAnimal = 'cat';
    let animals2 = Object.assign({}, animals);
    delete animals2[delAnimal];
    let animals3 = {...animals};
    delete animals3[delAnimal];

    console.log(animals); // {cat: "meow", dog: "bark"}
    console.log(animals2); // {dog: "bark"}
    console.log(animals3); // {dog: "bark"}
    ```

## Merging Lists of Records
1. As we will receive an array of objects from the endpoint, can use `_.mapKeys(array, key)` to turn the array into an object which use the given key of each object in the array as the key.
    <img src="./images/mapKeyslodash346.png">
    ```js
    // sammple code
    const colors = [
        {hue: 'green'},
        {hue: 'yellow'},
        {hue: 'blue'}
    ];

    _.mapKeys(colors, 'hue');
    // {"green":{"hue":"green"},"yellow":{"hue":"yellow"},"blue":{"hue":"blue"}}

    // use reduce array method without lodash library
    colors.reduce((obj, color)=>{
        obj[color['hue']] = color;
        return obj;
    }, {});
    ```
1. We update the final reducer `FETCH_STREAMS` which handles the response as an array. 
    ```js
    // src/components/reducers/streamReducer.js
    import _ from 'lodash';

    import {
        FETCH_STREAM,
        FETCH_STREAMS,
        CREATE_STREAM,
        DELETE_STREAM,
        EDIT_STREAM
    } from '../actions/types';

    export default (state = {}, action) => {
        switch (action.type) {
            case FETCH_STREAMS:
                return { ...state, ..._.mapKeys(action.payload, 'id') };
            case FETCH_STREAM:
                return { ...state, [action.payload.id]: action.payload };
            case CREATE_STREAM:
                return { ...state, [action.payload.id]: action.payload };
            case EDIT_STREAM:
                return { ...state, [action.payload.id]: action.payload };
            case DELETE_STREAM:
                return _.omit(state, action.payload); // the payload has been the id already from DELETE action creator
            default:
                return state;
        }
    }
    // src/components/reducers/index.js
    import { combineReducers } from 'redux';
    import { reducer as formReducer } from 'redux-form';
    import authReducer from './authReducer';
    import streamReducer from './streamReducer';

    export default combineReducers({
        auth: authReducer,
        form: formReducer,
        streams: streamReducer
    });
    ```
1. After updating the reducers, we can get back to the root route and check on Redux DevTools for the `state`.

## Fetching a List of All Streams
1. After building all the required action creators and reducers, we can wire them up with the view components. 
1. We can use `connet` from `react-redux` to wire up and get the `props`.
1. We change `StreamList` from function based to class-component as to use `componentDidMount` method to run `fetchStreams` method only when the component is firstly rendered. 
1. After wiring up, we can check `state` from `Redux DevTools`. Note that we should have the JSON DB running on port 3031. In this case, we have had 2 instances stored in the database when we work on `StreamCreate` component.
    ```js
    // src/components/streams/StreamList.js
    import React from 'react';
    import { connect } from 'react-redux';
    import { fetchStreams } from '../../actions';

    class StreamList extends React.Component {
        componentDidMount() {
            this.props.fetchStreams();
        }

        render() {
            return <div>StreamList</div>
        }
    }

    export default connect(null, { fetchStreams })(StreamList);
    ```
    <img src="./images/fetchAllStreams347.png">

## Rendering All Streams
1. With `mapStateToProps`, we can pass the `state` stored in Redux and pass to the component as `props`. 
1. As the collection is an object, we can use `Object.values` function to create an array of values of the object. 
1. We then create another method `renderList` to create the list of components. 
    ```js
    // src/components/streams/StreamList.js
    import React from 'react';
    import { connect } from 'react-redux';
    import { fetchStreams } from '../../actions';

    class StreamList extends React.Component {
        componentDidMount() {
            this.props.fetchStreams();
        }

        renderList() {
            return this.props.streams.map(stream => {
                return (
                    <div className="item" key={stream.id}>
                        <i className="large middle aligned icon camera" />
                        <div className="content">
                            {stream.title}
                            <div className="description">{stream.description}</div>
                        </div>
                    </div>
                );
            });
        }

        render() {
            return (
                <div>
                    <h2>Streams</h2>
                    <div className="ui celled list">
                        {this.renderList()}
                    </div>
                </div>
            );
        }
    }

    const mapStateToProps = (state) => {
        return { streams: Object.values(state.streams) };
    }

    export default connect(mapStateToProps, { fetchStreams })(StreamList);
    ```

## Associating Streams with Users
1. As each stream is creaetd by different user, we should add another property on the stream object to indicate which user creates the instance.
1. Note that we have stored the `userId` in the `auth` object in Redux when we authenticate the user during login process.
1. We can update `index.js` in `actions` and pass `userId` when creating a stream object. 
1. Note that the async function not only takes `dispatch` but has `getState` which is a function that returns the current `states` stored in Redux.
1. We then can use destructive assignment to create a new object to create and save a new stream. 
1. When we navigate back to the root route, we can check each stream object if it has the same `userId`, so it will render buttons to either "**Edit**" or "**Delete**" the stream if it is created by the user. 
    ```js
    // src/actions/index.js
    export const createStream = (formValues) => async (dispatch, getState) => {
        const { userId } = getState().auth;
        const response = await streams.post('/streams', { ...formValues, userId });

        dispatch({ type: CREATE_STREAM, payload: response.data });
    };
    ```

## Conditionally Showing Edit and Delete
1. After adding `userId` to create the stream object in action creator, we can pass it to the view component with `maptStateToProps`. In this case, we have the property name as `currentUserId`.
1. To prevent complexity in `renderList` method, we create another helper method `renderAdmin` which is to create the buttons for the user to either "**edit**" or "**delete**" as an admin.
1. Note that we use `right floated content` class from `Semantic UI` library. We should put the element on the top of the block to let it "**float**" to the right.
1. After setting up the elements, we can try to login/out to check if the elements show correctly. The buttons should only show when the stream object belongs to the user. 
    ```js
    // src/components/streams/StreamList.js
    import React from 'react';
    import { connect } from 'react-redux';
    import { fetchStreams } from '../../actions';

    class StreamList extends React.Component {
        componentDidMount() {
            this.props.fetchStreams();
        }

        renderAdmin(stream) {
            if (stream.userId === this.props.currentUserId) {
                return (
                    <div className="right floated content">
                        <button className="ui button primary">
                            Edit
                        </button>
                        <button className="ui button negative">
                            Delete
                        </button>
                    </div>
                );
            }
        }

        renderList() {
            return this.props.streams.map(stream => {
                return (
                    <div className="item" key={stream.id}>
                        {this.renderAdmin(stream)} // render this component on the top to let it "float" to the right on the same line
                        <i className="large middle aligned icon camera" />
                        <div className="content">
                            {stream.title}
                            <div className="description">{stream.description}</div>
                        </div>
                    </div>
                );
            });
        }

        render() {
            return (
                <div>
                    <h2>Streams</h2>
                    <div className="ui celled list">
                        {this.renderList()}
                    </div>
                </div>
            );
        }
    }

    const mapStateToProps = (state) => {
        return {
            streams: Object.values(state.streams),
            currentUserId: state.auth.userId // add in the userId
        };
    }

    export default connect(mapStateToProps, { fetchStreams })(StreamList);
    ```

## Linking to Stream Creation
1. On the list of streams page, we can have a button to direct the user to create page to create a new stream. 
1. We can decide whether to render the `create` button by checking if a user has signed in.
1. To redirect the user, we use `Link` component from `react-router-dom`.
    ```js
    // src/components/streams/StreamList.js 
    import React from 'react';
    import { connect } from 'react-redux';
    import { Link } from 'react-router-dom';
    import { fetchStreams } from '../../actions';

    class StreamList extends React.Component {
        componentDidMount() {
            this.props.fetchStreams();
        }

        renderAdmin(stream) {
            if (stream.userId === this.props.currentUserId) {
                return (
                    <div className="right floated content">
                        <button className="ui button primary">
                            Edit
                        </button>
                        <button className="ui button negative">
                            Delete
                        </button>
                    </div>
                );
            }
        }

        renderList() {
            return this.props.streams.map(stream => {
                return (
                    <div className="item" key={stream.id}>
                        {this.renderAdmin(stream)}
                        <i className="large middle aligned icon camera" />
                        <div className="content">
                            {stream.title}
                            <div className="description">{stream.description}</div>
                        </div>
                    </div>
                );
            });
        }

        renderCreate() {
            if (this.props.isSignedIn) {
                return (
                    <div style={{ textAlign: 'right' }}>
                        <Link to="/streams/new" className="ui button primary">
                            Create Stream
                        </Link>
                    </div>
                )
            }
        }

        render() {
            return (
                <div>
                    <h2>Streams</h2>
                    <div className="ui celled list">{this.renderList()}</div>
                    {this.renderCreate()}
                </div>
            );
        }
    }

    const mapStateToProps = (state) => {
        return {
            streams: Object.values(state.streams),
            currentUserId: state.auth.userId,
            isSignedIn: state.auth.isSignedIn
        };
    }

    export default connect(mapStateToProps, { fetchStreams })(StreamList);
    ```

## When to Navigate Users
1. When the user creates a new stream, we should redirect the user back to the list of streams, and the latest stream should be listed as well.
1. In this project, we have been using "**Intentional Navigation**" which is an event handler that only works when the user clicks a `Link` component.
1. On the other hand, we can use "**Programmatic Navigation**" which is to run code to forcibly navigate the user through the app.
1. We shall only redirect the user when the app has got the response from the server and decide whether to redirect the user or show error message from the response.
1. Therefore, the programmatic navigation should work when the action creator got the response from the request. We can work on further operations at `src/actions/index.js`.

## History Reference
1. The `BrowserRouter` we use to navigate between routes creates a `history` object which keeps track of the address bar in the browser.
    <img src="./images/historyReference353.png">
1. The `history` object can not only watch and trace on the address but "**change**" the route. The programmatic navigation can be challenging because it's created by `BrowserRouter`.
1. When a component is created, `history` is passed as a property from `BrowserRouter` to the component.
1. So if we want to call it in the action creator, we have to pass it from the component to the action creator.
    <img src="./images/browserRouterWithHistoryObject353.png">
1. The other way to work around is to create `history` object ourselves.

## Creating a Browser History Object
1. We create `history.js` in `src` directory and import `createHistory` from `history/createBrowserHistory`. This `history` library is installed along with `react-router-dom`, so we don't need to install this library specifically. Therefore, it's relatively easy to trigger the navigation from a component. However, we are trying to trigger the navigation within an `action creator` which only navigates the user after an async event is handled.
1. However, as the library has some issue, we should import `createBrowserHistory` directory from `history` package.
1. Besides, in `App.js` in `src/`, we use `Router` rather than `BrowserRouter` to work with self-created `history` object.
    ```js
    // src/history.js
    import { createBrowserHistory } from 'history';
    export default createBrowserHistory();

    // src/components/App.js
    import React from 'react';
    import { Router, Route } from 'react-router-dom'; // change from BrowserRouter to Router
    import StreamCreate from './streams/StreamCreate';
    import StreamEdit from './streams/StreamEdit';
    import StreamDelete from './streams/StreamDelete';
    import StreamList from './streams/StreamList';
    import StreamShow from './streams/StreamShow';
    import Header from './Header';
    import history from '../history';

    const App = () => {
        return (
            <div>
                <Router history={history}> // pass history object
                    <div>
                        <Header />
                        <Route path="/" exact component={StreamList} />
                        <Route path="/streams/new" exact component={StreamCreate} />
                        <Route path="/streams/edit" exact component={StreamEdit} />
                        <Route path="/streams/delete" exact component={StreamDelete} />
                        <Route path="/streams/show" exact component={StreamShow} />
                    </div>
                </Router>
            </div>
        );
    }

    export default App;
    ```

## Implementing Programmatic Navigation

## Manually Changing API Records

## URL-Based Selection

## Wildcard Navigation

## More on Route Params

## Selecting Records from State

## Component Isolation with React Router

## Fetching a Stream for Edit Stream

## Real Code Reuse

## Refactoring Stream Creation

## Setting Initial Values

## Avoiding Changes to Properties

## Edit Form Submission

## PUT vs PATCH Requests



# Using React Portals 

# Implementing Streaming Video

# The Context System with React 

# Replacing Redux with Context

# Working with Older Versions of React

# Ajax Requets with React 

# Modeling Application State

# Managing App State with Redux

# Intermediate Redux: Middleware

# React Router + Redux Form v6

# Bonus Topics

# React Router + Redux Form v4

# Extras

