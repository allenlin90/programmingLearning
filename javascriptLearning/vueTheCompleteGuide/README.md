Start learning on 2021/04/19
Finished on 

Course Link [https://www.udemy.com/course/vuejs-2-the-complete-guide/](https://www.udemy.com/course/vuejs-2-the-complete-guide/)
---
1. [Basics and Core Concepts - DOM Interaction with Vue](#Basics-and-Core-Concepts---DOM-Interaction-with-Vue)
    1. [Creating and Connecting Vue App Instance](#Creating-and-Connecting-Vue-App-Instance)
    1. [Interpolation and Data Binding](#Interpolation-and-Data-Binding)
    1. [Binding Attributes with the "v-bind" Directive](#binding-attributes-with-the-v-bind-directive)
    1. [Understanding "methods" in Vue Apps](Understanding-methods-in-Vue-Apps)
    1. [Working with Data inside of a Vue App](#Working-with-Data-inside-of-a-Vue-App)
    1. [Outputting Raw HTML Content with v-html](#Outputting-Raw-HTML-Content-with-v-html)
    1. [A First Summary](#A-First-Summary)
    1. [Understanding the Event Binding](#Understanding-the-Event-Binding)
    1. [Events and Methods](#Events-and-Methods)
    1. [Working with Event Arguments](#Working-with-Event-Arguments)
    1. [Using the Native Event Object](#Using-the-Native-Event-Object)
    1. [Exploring Event Modifiers](#Exploring-Event-Modifiers)
    1. [Locking Content with v-once](#Locking-Content-with-v-once)
    1. [Data Binding + Event Binding = Two-way Binding](#data-binding--event-binding--two-way-binding)
    1. [Methods used for Data Bindings: How it works](#methods-used-for-data-bindings-how-it-works)
    1. [Introducing Computed Properties](#Introducing-Computed-Properties)
    1. [Working with Watchers](#Working-with-Watchers)
    1. [Methods vs Computed Properties vs Watchers](#Methods-vs-Computed-Properties-vs-Watchers)
    1. [v-bind and v-on Shorthands](#v-bind-and-v-on-Shorthands)
    1. [Dynamic Styling with Inline Styles](#Dynamic-Styling-with-Inline-Styles)
    1. [Adding CSS Classes Dynamically](#Adding-CSS-Classes-Dynamically)
    1. [Classes & Computed Properties](#classes--computed-properties)
    1. [Dynamic Classes: Array Syntax](#dynamic-classes-array-syntax)
1. [Redenering Conditional Content & Lists](#Redenering-Conditional-Content--Lists)
    1. [Understanding the Problem](#Understanding-the-Problem)
    1. [Rendering Content Conditionally](#Rendering-Content-Conditionally)
    1. [v-if, v-else and v-else-if](#v-if,-v-else-and-v-else-if)
    1. [Using v-show Instead of v-if](#Using-v-show-Instead-of-v-if)
    1. [Rendering Lists of Data](#Rendering-Lists-of-Data)
    1. [Diving Deeper Into v-for](#Diving-Deeper-Into-v-for)
    1. [Removing List Items](#Removing-List-Items)
    1. [Lists & Keys](#Lists--Keys)
1. [Coure Project: The Monster Slayer Game](#Coure-Project-The-Monster-Slayer-Game)
    1. [Project Setup & First Methods](#Project-Setup--First-Methods)
    1. [Updating the Health Bars](#Updating-the-Health-Bars)
    1. [Adding a "Special Attack"](#adding-a-special-attack)
    1. [Adding a "Heal" Functionality](#Adding-a-Heal-Functionality)
    1. [Adding a "Game Over" Screen](#Adding-a-Game-Over-Screen)
    1. [Finshing the Core Functionality](#Finshing-the-Core-Functionality)
    1. [Adding a Battle Log](#Adding-a-Battle-Log)
1. [Vue: Behind the Scenes](#Vue-Behind-the-Scenes)
    1. [An Introduction to Vue's Reactivity](#An-Introduction-to-Vue's-Reactivity)
    1. [Vue Reactivity: A Deep Dive](#Vue-Reactivity-A-Deep-Dive)
    1. [One App vs Multiple Apps](#One-App-vs-Multiple-Apps)
    1. [Understanding Templates](#Understanding-Templates)
    1. [Working with Refs](#Working-with-Refs)
    1. [How Vue Updates the DOM](#How-Vue-Updates-the-DOM)
    1. [Vue App Lifecycle - Theory](#Vue-App-Lifecycle---Theory)
    1. [Vue App Lifecycle - Practice](#Vue-App-Lifecycle---Practice)
1. [Introducing Components](#Introducing-Components)
    1. [Understanding the Problem](#Understanding-the-Problem)
    1. [Introducing Components](#Introducing-Components)
    1. [The Why: Building Complex User Interfaces With Components](#The-Why-Building-Complex-User-Interfaces-With-Components)
1. [Moving to a Better Development SEtup & Workflow with the Vue CLI](#Moving-to-a-Better-Development-SEtup--Workflow-with-the-Vue-CLI)
    1. [Why We Need A Development Server](#Why-We-Need-A-Development-Server)
    1. [WHy We Want A Better Developer Experience](#WHy-We-Want-A-Better-Developer-Experience)
    1. [Installing & Using the Vue CLI](#Installing--Using-the-Vue-CLI)
    1. [Inspecting the Created Project](#Inspecting-the-Created-Project)
    1. [Inspecting the Vue Code & ".vue" Files](#inspecting-the-vue-code--vue-files)
    1. [Adding the "Vetur" Extension to VS Code](#adding-the-vetur-extension-to-vs-code)
    1. [More on ".vue" Files](#more-on-vue-files)
    1. [A New Vue Project](#A-New-Vue-Project)
    1. [Creating a Basic Vue App](#Creating-a-Basic-Vue-App)
    1. [Adding a Component](#Adding-a-Component)
    1. [Adding Styling](#Adding-Styling)
1. [Component Communication](#Component-Communication)
    1. [Introducing "Props" (Parent => Child Communication)](#introducing-props-parent--child-communication)
    1. [Prop Behavior & Changing Props](#Prop-Behavior--Changing-Props)
    1. [Validating Props](#Validating-Props)
    1. [Working with Dynamic Props Values](#Working-with-Dynamic-Props-Values)
    1. [Emitting Custom Events (Child => Parent Communication)](#Eemitting-custom-events-child--parent-communication)
    1. [Defining & Validating Custom Events](#Defining--Validating-Custom-Events)
    1. [Prop / Event Fallthrough & Binding All Props](#Prop--Event-Fallthrough--Binding-All-Props)
    1. [Demo: Adding Components & Connecting Them](#Demo-Adding-Components--Connecting-Them)
    1. [Demo: Adding More Component Communication](#Demo-Adding-More-Component-Communication)
    1. [A Potential Problem](#A-Potential-Problem)
    1. [Provide + Inject To The Rescue](#Provide--Inject-To-The-Rescue)
    1. [Provide + Inject for Functions / Methods](#Provide--Inject-for-Functions--Methods)
    1. [Provide + Inject vs Props & Custom Events](#Provide--Inject-vs-Props--Custom-Events)
1. [Diving Deeper Into Components](#Diving-Deeper-Into-Components)
    1. [Project Setup](#Project-Setup)
    1. [Global vs Local Components](#Global-vs-Local-Components)
    1. [Scoped Styles](#Scoped-Styles)
    1. [Introducing Slots](#Introducing-Slots)
    1. [Named Slots](#Named-Slots)
    1. [Slot Styles & Compilation](#Slot-Styles--Compilation)
    1. [More on Slots](#More-on-Slots)
    1. [Scoped Slots](#Scoped-Slots)
    1. [Dynamic Components](#Dynamic-Components)
    1. [Keeping Dynamic Components Alive](#Keeping-Dynamic-Components-Alive)
    1. [Applying What We Know & A Problem](#Applying-What-We-Know--A-Problem)
    1. [Teleporting Elements](#Teleporting-Elements)
    1. [Working with Fragments](#Working-with-Fragments)
    1. [The Vue Style Guide](#The-Vue-Style-Guide)
    1. [Moving to a Different Folder Structure](#Moving-to-a-Different-Folder-Structure)
1. [Course Projct: The Learning Resources App](#Course-Projct-The-Learning-Resources-App)
    1. [Setup & First Steps](#Setup--First-Steps)
    1. [First Components & Props](#First-Components--Props)
    1. [Styling and More Components](#Styling-and-More-Components)
    1. [Header & BaseCard Components](#Header--BaseCard-Components)
    1. [Adding a Base Button](#Adding-a-Base-Button)
    1. [Dynamic Components & Attribute Fallthrough](#Dynamic-Components--Attribute-Fallthrough)
    1. [Adding & Styling Tabs](#Adding--Styling-Tabs)
    1. [Adding a Form](#Adding-a-Form)
    1. [Fetching User Input](#Fetching-User-Input)
    1. [Adding a Modal Dialog](#Adding-a-Modal-Dialog)
    1. [Deleting Items](#Deleting-Items)
    1. [Adding "Teleport"](#Adding-Teleport)
1. [Form](#Form)
    1. [v-model & Inputs](#v-model--Inputs)
    1. [Working with v-model Modifiers and Numbers](#Working-with-v-model-Modifiers-and-Numbers)
    1. [v-model and Dropdowns](#v-model-and-Dropdowns)
    1. [Using v-model with Checkboxes & Radiobuttons](#Using-v-model-with-Checkboxes--Radiobuttons)
    1. [Adding Basic Form Validation](#Adding-Basic-Form-Validation)
    1. [Building a Custom Control Component](#Building-a-Custom-Control-Component)
    1. [Using v-model on Custom Components](#Using-v-model-on-Custom-Components)
1. [Sending Http Requests](#Sending-Http-Requests)
    1. [Starting App & Why we need a Backend](#Starting-App--Why-we-need-a-Backend)
    1. [Adding a Backend](#Adding-a-Backend)
    1. [How to (Not) Send Http Requests](#How-to-Not-Send-Http-Requests)
    1. [Sending a POST Request to Store Data](#Sending-a-POST-Request-to-Store-Data)
    1. [Getting Data (GET Request) & Transforming Response Data](#Getting-Data-GET-Request--Transforming-Response-Data)
    1. [Loading Data When a Component Mounts](#Loading-Data-When-a-Component-Mounts)
    1. [Showing a "Loading..." Message](#Showing-a-Loading...-Message)
    1. [Handling the "No Data" State](#Handling-the-No-Data-State)
    1. [Handling Technical / Browser-side Errors](#Handling-Technical--Browser-side-Errors)
    1. [Handling Error Responses](#Handling-Error-Responses)
1. [Routing: Building "Multi-Page" Single Page Application](#Routing-Building-Multi-Page-Single-Page-Application)
    1. [What & Why?](#What--Why?)
    1. [Routing Setup](#Routing-Setup)
    1. [Registering & Rendering Routes](#Registering--Rendering-Routes)
    1. [Navigating with router-link](#Navigating-with-router-link)
    1. [Styling Active Links](#Styling-Active-Links)
    1. [Programmatic Navigation](#Programmatic-Navigation)
    1. [Passing Data with Route Params (Dynamic Segments)](#Passing-Data-with-Route-Params-Dynamic-Segments)
    1. [Navigation & Dynamic Paths](#Navigation--Dynamic-Paths)
    1. [A Vue Bug](#A-Vue-Bug)
    1. [Updating Params Data with Watchers](#Updating-Params-Data-with-Watchers)
    1. [Passing Params as Props](#Passing-Params-as-Props)
    1. [Redirecting & "Catch All" Routes](#Redirecting--Catch-All-Routes)
    1. [Using Nested Routes](#Using-Nested-Routes)
    1. [More Fun with Named Routes & Location Objects](#More-Fun-with-Named-Routes--Location-Objects)
    1. [Using Query Params](#Using-Query-Params)
    1. [Rendering Multiple Routers with Named Router Views](#Rendering-Multiple-Routers-with-Named-Router-Views)
    1. [Controlling Scroll Behavior](#Controlling-Scroll-Behavior)
    1. [Introducing Navigation Guards](#Introducing-Navigation-Guards)
    1. [Diving Deeper Into Navigation Guards](#Diving-Deeper-Into-Navigation-Guards)
    1. [The Global "afterEach" Guard](#The-Global-afterEach-Guard)
    1. [Beyond Entering: Route Leave Guards](#Beyond-Entering-Route-Leave-Guards)
    1. [Utilizing Route Metadata](#Utilizing-Route-Metadata)
    1. [Organizing Route Files](#Organizing-Route-Files)
1. [Animations & Transitions](#Animations--Transitions)
    1. [Animation Basics & CSS Transitions](#Animation-Basics--CSS-Transitions)
    1. [Understanding CSS Animations](#Understanding-CSS-Animations)
    1. [Why is "Just CSS" Not Enough?](#Why-is-Just-CSS-Not-Enough?)
    1. [Playing CSS Animations with Vue's Help](#Playing-CSS-Animations-with-Vue's-Help)
    1. [Using the Transition Component](#Using-the-Transition-Component)
    1. [CSS Animations with the Transition Component](#CSS-Animations-with-the-Transition-Component)
    1. [Using Custom CSS Class Names](#Using-Custom-CSS-Class-Names)
    1. [Example: Animating a Modal](#Example-Animating-a-Modal)
    1. [Transitioning Between Multiple Elements](#Transitioning-Between-Multiple-Elements)
    1. [Using Transition Events](#Using-Transition-Events)
    1. [Building JavaScript Transitions (instead of CSS)](#Building-JavaScript-Transitions-instead-of-CSS)
    1. [Disabling CSS Transitions](#Disabling-CSS-Transitions)
    1. [Getting Started with Animated Lists](#Getting-Started-with-Animated-Lists)
    1. [Animating Lists with "transition-group"](#Animating-Lists-with-transition-group)
    1. [Animate List Item Movement](#Animate-List-Item-Movement)
    1. [Animate Route Changes](#Animate-Route-Changes)
1. [Vuex](#Vuex)
    1. [What & Why?](#What-and-Why-vuex?)
    1. [Creating & Using a Store](#Creating--Using-a-Store)
    1. [Connecting Components to State](#Connecting-Components-to-State)
    1. [Introducing Mutations - A Better Way of Changing Data](#Introducing-Mutations---A-Better-Way-of-Changing-Data)
    1. [Passing Data to Mutations with Payloads](#Passing-Data-to-Mutations-with-Payloads)
    1. [Introducing Getters - A Better Way Of Getting Data](#Introducing-Getters---A-Better-Way-Of-Getting-Data)
    1. [Running Async Code with Actions](#Running-Async-Code-with-Actions)
    1. [Understanding the Action "Context"](#Understanding-the-Action-Context)
    1. [Using Mapper Helpers](#Using-Mapper-Helpers)
    1. [Organizing your Store with Modules](#Organizing-your-Store-with-Modules)
    1. [Understanding Local Module State](#Understanding-Local-Module-State)
    1. [Namespacing Modules](#Namespacing-Modules)
    1. [Structuring Vuex Code & Files](#Structuring-Vuex-Code--Files)
1. [Main Project: "Find a Coach" Web App](#Main-Project-Find-a-Coach-Web-App)
    1. [Planning the Project / Web App](#Planning-the-Project--Web-App)
    1. [Planning the Data Requirements](#Planning-the-Data-Requirements)
    1. [Planning the Layout / Components](#Planning-the-Layout--Components)
    1. [Registering Routes](#Registering-Routes)
    1. [Adding Route Page Components](#Adding-Route-Page-Components)
    1. [Working on the Main Layout & Styling](#Working-on-the-Main-Layout--Styling)
    1. [Wiring Up Pages](#Wiring-Up-Pages)
    1. [Adding Vuex and Coach Data](#Adding-Vuex-and-Coach-Data)
    1. [Working on the Coaches List and List Items](#Working-on-the-Coaches-List-and-List-Items)
    1. [Adding a Couple of Base Components (Base Card, Base Button, Base Badge)](#Adding-a-Couple-of-Base-Components-Base-Card,-Base-Button,-Base-Badge)
    1. [Building the Coach Detail Component](#Building-the-Coach-Detail-Component)
    1. [Filtering Coaches](#Filtering-Coaches)
    1. [Registering as a Coach: The Form](#Registering-as-a-Coach-The-Form)
    1. [Adding Coaches to Vuex](#Adding-Coaches-to-Vuex)
    1. [Adding Form Validation](#Adding-Form-Validation)
    1. [Working on the Contact Form](#Working-on-the-Contact-Form)
    1. [Storing Requests (Messages) with Vuex](#Storing-Requests-Messages-with-Vuex)
    1. [Outputting Incoming Requests (Messages)](#Outputting-Incoming-Requests-Messages)
    1. [Filtering Requests for teh Active Coach](#Filtering-Requests-for-teh-Active-Coach)
    1. [Sending a PUT Http Request to Store Coach Data](#Sending-a-PUT-Http-Request-to-Store-Coach-Data)
    1. [Fetching Coach Data (GET Http Request)](#Fetching-Coach-Data-GET-Http-Request)
    1. [Rendering a Loading Spinner](#Rendering-a-Loading-Spinner)
    1. [Adding Http Error Handling](#Adding-Http-Error-Handling)
    1. [Sending Coaching Requests Http Requests](#Sending-Coaching-Requests-Http-Requests)
    1. [Caching Http Response Data](#Caching-Http-Response-Data)
    1. [Adding Route Transitions](#Adding-Route-Transitions)
    1. [The "Not Found" Page & Summary](#The-Not-Found-Page--Summary)
1. [Vue & Authentication](#Vue--Authentication)
    1. [How Authentication Works in Vue Apps (or any SPA)](#How-Authentication-Works-in-Vue-Apps-or-any-SPA)
    1. [Locking / Protecting Backend Resources](#Locking--Protecting-Backend-Resources)
    1. [Adding an Authentication Page (Login & Signup)](#Adding-an-Authentication-Page-Login--Signup)
    1. [Preparing Vuex](#Preparing-Vuex)
    1. [Adding a "Signup" Action & Flow](#Adding-a-Signup-Action--Flow)
    1. [Better UX: Loading Spinner & Error Handling](#Better-UX-Loading-Spinner--Error-Handling)
    1. [Adding a "Login" Action & Flow](#Adding-a-Login-Action--Flow)
    1. [Attaching the Token to Outgoing Requests](#Attaching-the-Token-to-Outgoing-Requests)
    1. [Updating the UI Based on Auth State](#Updating-the-UI-Based-on-Auth-State)
    1. [Adding a "Logout" Action & Flow](#Adding-a-Logout-Action--Flow)
    1. [Authentication & Routing (incl. Navigation Guards)](#Authentication--Routing-incl.-Navigation-Guards)
    1. [Adding "Auto Login"](#Adding-Auto-Login)
    1. [Adding "Auto Logout"](#Adding-Auto-Logout)
1. [Optimizing & Deploying Vue Apps](#Optimizing--Deploying-Vue-Apps)
    1. [What To Deploy?](#What-To-Deploy?)
    1. [Optimization: Using Asynchronous Components](#Optimization-Using-Asynchronous-Components)
    1. [Building the Project For Production](#Building-the-Project-For-Production)
    1. [Deploying a Vue App](#Deploying-a-Vue-App)
1. [The Composition API - Replacing the Options API](#The-Composition-API---Replacing-the-Options-API)
    1. [Which Problem Does the Composition API Solve?](#Which-Problem-Does-the-Composition-API-Solve?)
    1. [Replacing "data" with "refs"](#Replacing-data-with-refs)
    1. [Building "reactive" Objects](#Building-reactive-Objects)
    1. [Reactivity: A Deep Dive](#Reactivity-A-Deep-Dive)
    1. [Replacing "methods" with regular Functions](#Replacing-methods-with-regular-Functions)
    1. [Replacing "Computed Properties" with the "computed" Function](#Replacing-Computed-Properties-with-the-computed-Function)
    1. [Two-Way-Binding and the Composition API](#Two-Way-Binding-and-the-Composition-API)
    1. [Working with Watchers](#Working-with-Watchers)
    1. [A First Summary](#A-First-Summary)
    1. [How to Use Templates Refs](#How-to-Use-Templates-Refs)
    1. [Components, Props, & The Composition API](#Components,-Props,--The-Composition-API)
    1. [Emitting Custom Events](#Emitting-Custom-Events)
    1. [Working with Provide / Inject](#Working-with-Provide--Inject)
    1. [Lifecycle Hooks in the Composition API](#Lifecycle-Hooks-in-the-Composition-API)
    1. [Migrating from Options API to Composition API - an Example Project](#Migrating-from-Options-API-to-Composition-API---an-Example-Project)
    1. [Migrating a First Component](#Migrating-a-First-Component)
    1. [Migrating a Big Component](#Migrating-a-Big-Component)
    1. [Migrating the Remaining Components](#Migrating-the-Remaining-Components)
    1. [Routing, Params & The Composition API](#Routing,-Params--The-Composition-API)
    1. [The Route & Router Objects and the Composition API](#The-Route--Router-Objects-and-the-Composition-API)
    1. [Using Vuex with the Composition API](#Using-Vuex-with-the-Composition-API)
1. [Reusing Funcitonality: Mixins & Custom Composition Functions](#Reusing-Funcitonality-Mixins--Custom-Composition-Functions)
    1. [Reusability Concepts](#Reusability-Concepts)
    1. [Using Mixins](#Using-Mixins)
    1. [Understanding Mixin Merging](#Understanding-Mixin-Merging)
    1. [Global Mixins](#Global-Mixins)
    1. [Disadvantages of Mixins](#Disadvantages-of-Mixins)
    1. [Custom Hooks / Composables & The Composition API](#Custom-Hooks--Composables--The-Composition-API)
    1. [More Custom Composition Functions](#More-Custom-Composition-Functions)
    1. [Why Hookks / Composables Beat Mixins](#Why-Hookks--Composables-Beat-Mixins)
    1. [Example: Creating a "Search" Hook](#Example-Creating-a-Search-Hook)
    1. [Custom Hooks Gotchas](#Custom-Hooks-Gotchas)
    1. [More Thoughts on Custom Hooks / Composables](#More-Thoughts-on-Custom-Hooks--Composables)
    1. [Example: A Custom "Sort" Hook](#Example-A-Custom-Sort-Hook)
---

# Basics and Core Concepts - DOM Interaction with Vue
## Creating and Connecting Vue App Instance
1. Starter HTML
    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Vue Basics</title>
        <link
        href="https://fonts.googleapis.com/css2?family=Jost:wght@400;700&display=swap"
        rel="stylesheet"
        />
        <link rel="stylesheet" href="styles.css" />
        <script src="https://unpkg.com/vue@next" defer></script>
        <script src="app.js" defer></script>
    </head>
    <body>
        <header>
        <h1>Vue Course Goals</h1>
        </header>
        <section id="user-goal">
        <h2>My Course Goal</h2>
        <p></p>
        </section>
    </body>
    </html>
    ```
1. To use Vue, we need to specify in HTML that which element will be handled by Vue. 
1. To initiate Vue, we should create a `Vue App` in the JS code, and it requires an JavaScript object which as `data` method as a must property.
1. The `data` method should always return another JavaScript object which may have arbitrarily named keys. 
1. We then can use `app.mount()` selector to manipulate the HTML element on the page.
    ```js
    // Vue framework should be imported
    const app = Vue.createApp({
        data() { // must return an object
            return { // key/value pair can be named arbitrarily
                courseGoal: 'Finish the course and learn Vue!'
            };
        }
    });

    app.mount('#user-goal');
    ```

## Interpolation and Data Binding
1. We can put the placeholder in HTML which should match to the property that we want to return its value in `data` method.
1. Note that we can have multiple placeholder in the component, and all of them will show the same value. 
    1. HTML 
        ```html
        <section id="user-goal">
            <h2>My Course Goal</h2>
            <p>{{ courseGoal }}</p> <!-- placeholder for Vue selector to identify-->
            <p>{{ goalList }}</p>
        </section>
        ```
    1. JavaScript
        ```js
        const app = Vue.createApp({
            data() { // must return an object
                return { // key/value pair can be named arbitrarily
                    courseGoal: 'Finish the course and learn Vue!',
                    goalList: ['task 1', 'task 2']
                };
            }
        });

        app.mount('#user-goal');
        ```
1. If we use the placeholder somewhere else that isn't selected by Vue selector, it will be regular string in HTML.
1. The Vue component can not only show text but also other primitive values or JavaScript array or object, which will be stringified as JSON to be shown as string.
    <img src="images/14-placeholder_vue_component.png">

## Binding Attributes with the "v-bind" Directive
1. Though we can use double curly braces as placeholder for Vue component to import values, it doesn't work with attributes on HTML tags such as `href` of an anchor tag.
1. We then can use `v-bind` on the attribute to indicate that the HTML attribute should work with Vue. Note that the placeholder for the attribute doesn't require double curly braces.
    ```html
    <section id="user-goal">
        <h2>My Course Goal</h2>
        <p>{{ courseGoal }}</p>
        <p>Learn more <a v-bind:href="vueLink">about Vue</a>.</p>
    </section>
    ```

## Understanding "methods" in Vue Apps
1. To execute function as the event handler on a HTML element, we need to firstly set up the `methods` in the Vue app. 
1. Besides `data`, we can pass another property `methods` which holds the callback functions to handle events on HTML elements.
1. Note that the methods we want to call by Vue app should be declared in `methods` property only. Both `data` and `methods` are reserved properties for a Vue app.
    ```js
    const app = Vue.createApp({
        data() { 
            return { 
                courseGoal: 'Finish the course and learn Vue!',
                vueLink: 'https://vuejs.org/'
            };
        },
        methods: {
            outputGoal() {
                const randomNumber = Math.random();
                if (randomNumber < 0.5) {
                    return 'Learn Vue!';
                } else {
                    return 'Master Vue!';
                }
            }
        }
    });
    ```
1. The placeholder with double curly braces in HTML can take not only variables from Vue but also JavaScript expressions. Note that it doesn't take complicated structure such as an IF/ELSE statement, but it works with ternary operator.
    ```html
    <section id="user-goal">
        <h2>My Course Goal</h2>
        <p>{{ outputGoal() }}</p>
        <p>{{ 1 + 1 }}</p>
        <p>{{ (1 + 1) > 1 ? true : false }}</p>
        <p>Learn more <a v-bind:href="vueLink">about Vue</a>.</p>
    </section>
    ```

## Working with Data inside of a Vue App
1. Vue provides a shorthand that we can access the properties and methods on the Vue app object directly by `this` (which is not intuitive for regular Javascript objects!). 
1. The feature just turn all the properties which `data` method can return and methods in `methods` globally accessible with `this`.
    ```js
    const app = Vue.createApp({
        data() { // must return an object
            return { // key/value pair can be named arbitrarily
                courseGoalA: 'Finish the course and learn Vue!',
                courseGoalB: 'Master Vue and build amazing apps!',
                vueLink: 'https://vuejs.org/'
            };
        },
        methods: {
            outputGoal() {
                const randomNumber = Math.random();
                if (randomNumber < 0.5) {
                    return this.courseGoalA;
                } else {
                    return this.courseGoalB;
                }
            }
        }
    });

    app.mount('#user-goal');
    ```

## Outputting Raw HTML Content with v-html
1. Regular interpolation (double curly braces) can only handle the value as text (similar to `innerText` property on a HTML DOM).
    ```js
    const app = Vue.createApp({
        data() {
            return {
                courseGoalA: 'Finish the course and learn Vue!',
                courseGoalB: '<h2>Master Vue and build amazing apps!</h2>',
                vueLink: 'https://vuejs.org/'
            };
        },
        methods: {
            outputGoal() {
                const randomNumber = Math.random();
                if (randomNumber < 0.5) {
                    return this.courseGoalA;
                } else {
                    return this.courseGoalB;
                }
            }
        }
    });
    ```
1. For the case, we can use `v-html` as an attribute on the HTML element that we want to inject raw HTML tags as using `innerHTML`. The syntax is similar to `v-bind` which works with regular HTML attributes.
    ```html
    <section id="user-goal">
        <h2>My Course Goal</h2>
        <p v-html="outputGoal"></p>
        <p>Learn more <a v-bind:href="vueLink">about Vue</a>.</p>
    </section>
    ```
1. However, it's not recommended to have this method as default because it may be vulnerable to XXS attacks.

## A First Summary
1. If we use `app = Vue.createApp()` and select a specific HTML element by `app.mount()`, Vue can work on the selected HTML element and its child, while won't affect other HTML elements on the page. 
1. To manipulate the elements, we can use "**interpolation**" (double curly braces) and `v-html` and `v-bind` on HTML attributes. 

## Understanding the Event Binding
1. To add event listener on Vue component, we can use `v-on` and follow with a column and the event, such as `v-on:click`, on the HTML element.
1. We then can add Javascript expression or give the event handler function for the element.
1. However, `v-on` takes either expression or function and can't execution as a code block. For example, if we try to put `console.log('Hello World')` to execute direclty, browser will return an error.
    ```html
    <!-- HTML -->
    <section id="events">
        <h2>Events in Action</h2>
        <button v-on:click="increase">Add</button>
        <button v-on:click="counter-->Reduce</button>
        <p>Result: {{ counter }}</p>
    </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                counter: 0,
            };
        },
        methods: {
            increase() {
                this.counter++;
            }
        }
    });

    app.mount('#events');
    ```

## Events and Methods
1. Though we can give expressions and logic at `v-on` in HTML element, it's not a good practice, as we should separate the purpose of each type of file.
1. Therefore, we can create a function in the JavaScript. This function should be a method in the Vue component. 
1. Besides, we can either pass the method or call the method in `v-on` directly. Either approach will work, as Vue can handle the conditions.
    ```html
    <!-- HTML -->
    <section id="events">
        <h2>Events in Action</h2>
        <!-- either assign method execute it will work as long as it's a method in the Vue component -->
        <button v-on:click="add()">Add</button>
        <button v-on:click="reduce">Reduce</button>button>
        <p>Result: {{ counter }}</p>
    </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                counter: 0,
            };
        },
        methods: {
            add() {
                this.counter += 1;
            },
            reduce() {
                this.counter -= 1;
            }
        }
    });

    app.mount('#events');
    ```

## Working with Event Arguments
1. Since `v-on` can either take an expression or assign a method, we can pass an argument(s) to the method. 
1. Therefore, we can make our method dynamic and change the ouptut or feature on the Vue component very fast.
    ```html
    <!-- HTML -->
    <section id="events">
        <h2>Events in Action</h2>
        <!-- Pass arguments to methods -->
        <button v-on:click="add(5)">Add</button>
        <button v-on:click="reduce(5)">Reduce</button>
        <p>Result: {{ counter }}</p>
    </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
            counter: 0,
            };
        },
        methods: { // both methods take arguments
            add(num) {
            this.counter += num;
            },
            reduce(num) {
            this.counter -= num;
            }
        }
    });

    app.mount('#events');
    ```

## Using the Native Event Object
1. In regular cases, browser will provide an `event` argument to the callback function of the event handler. 
1. If we don't pass any argument to the event handler callback function it takes `event` argument by default. Therefore, we can use it as regular JavaScript to check the properties in the event object. 
1. In this case, we can track on the value that the user gives to an `input` tag by checking the `input` event. 
    ```html
    <!-- HTML -->
    <section id="events">
        <h2>Events in Action</h2>
        <input type="text" v-on:input="setName">
        <p>Your Name : {{ name }}</p>
    </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                name: '',
            };
        },
        methods: {
            setName(event) {
                this.name = event.target.value;
            },
        }
    });

    app.mount('#events');
    ```
1. Besides, only the part that is handled by Vue is changed in the HTML document. This feature is similar to vanilla JavaScript to manipulate DOM. 
1. In addition, we can still pass an argument(s) to the event handler but keep the event object. Vue provides a reserved variable `$event` that we can pass to the function for `v-on` as well. 
    ```html
    <!-- HTML -->
    <input type="text" v-on:input="setName($event, 'Another Name')">
    ```
    ```js
    // JavaScript
    const app = Vue.creatApp({
        data() {
            return {
                name: '',
            },
        },
        methods: {
            setName(event, secondName) {
                return event.target.value + ' ' + secondName;
            } 
        }
    })
    ```

## Exploring Event Modifiers
1. In regular `form` element, the browser will return when the user submits the form as it send a HTTP request to server.
1. However, we'd like to prevent the default feature and stop browser from reloading the page.
1. We can use regular way in JavaScript to use `event.preventDefault()` in the callback funciton to prevent the browser reloads the page. 
    ```html
    <!-- HTML -->
    <section id="events">
        <h2>Events in Action</h2>
        <form v-on:submit="submitForm" action="">
        <input type="text" name="" id="">
        <button type="submit">Sign Up</button>
        </form>
    </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        methods: {
            submitForm(event) {
                event.preventDefault();
            }
        }
    })
    ```
1. On the other hand, we can use Vue feature to modify the event on HTML directly. In this case, we can simply modify Vue event handler with `v-on:submit.prevent`.
    ```html
    <!-- HTML -->
    <section id="events">
        <h2>Events in Action</h2>
        <form v-on:submit.prevent="submitForm" action="">
        <input type="text" name="" id="">
        <button type="submit">Sign Up</button>
        </form>
    </section>
    ```
1. Besides `.prevent`, we can do `click.right` for click event to change default from left click on a mouse to right click, so the function will only be trigerred when the user right clicks on the element.
    ```html
    <!-- HTML -->
    <section id="events">
        <h2>Events in Action</h2>
        <button v-on:click="add(5)">Add</button>
        <button v-on:click.right="reduce(5)">Reduce</button>
        <p>Result: {{ counter }}</p>
    </section>
    ```
1. In this case, we'd like to manipulate the input to the `p` tag below only when the user hits <kbd>enter</kbd>. Note that we can use `v-on` to apply multiple event handler on the same element. 
    ```html
    <!-- HTML -->
    <section id="events">
        <input 
            type="text" name="" id=""
            v-on:input="setName($event, 'Last Name')" 
            v-on:keyup.enter="confirmInput">
        <p>Your Name : {{ confirmedName }}</p>
    </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                name: '',
                confirmedName: '',
            }
        },
        methods: {
            setName(event, secondName) {
                this.name = event.target.value + ' ' + secondName
            }, 
            confirmInput() {
                this.confirmedName = this.name;
            }
        }
    })
    ```
1. We may refer to [event modifier](https://vuejs.org/v2/guide/events.html#Event-Modifiers) from Vue officail document.

## Locking Content with v-once
1. In some scenarios, we'd like the Vue controled element to render interpolation at once when the app initiates. 
1. We can give `v-once` to indicate that the interpolation in the element will only happen when the element is firstly rendered. This is similar to the lifecycle method in React to prevent the element being re-rendered when the value or state changes.
    ```html
    <!-- HTML -->
    <section id="events">
        <h2>Events in Action</h2>
        <button v-on:click="add($event, 5)">Add</button>
        <button v-on:click="reduce($event, 5)">Reduce</button>
        <p v-once>Starting Counter: {{ counter }}</p>
        <p>Result: {{ counter }}</p>
    </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                counter: 10,
            }
        },
        methods: {
            add(event, num = 1) {
                return counter += num;
            }

            reduce(event, num = 1) {
                return counter -= num;
            }
        }
    })
    ```

## Data Binding + Event Binding = Two-way Binding
1. If we'd like to reset the data when the user clicks a button on the page, we can use regular JavaScript with DOM selector to handle the event.
1. We can use `v-bind` to bind the attribute with Vue interpolation. In this case, we bind the `value` attribute of the `input` tag with `name` interpolation of Vue. Therefore, when the user clicks on the "reset" button, not only the content in the `p` tag below will be removed but also the data in the `input` tag.
    ```html
    <!-- HTML -->
    <section id="events">
        <h2>Events in Action</h2>
        <button v-on:click="add(10)">Add 10</button>
        <button v-on:click="reduce(5)">Subtract 5</button>
        <p>Result: {{ counter }}</p>
        <button v-on:click="resetInput">Reset Input</button>
        <!-- bind value -->
        <input type="text" v-bind:value="name" v-on:input="setName($event, 'lastName')">
        <!-- use v-model for two-way binding -->
        <input type="text" v-model="name">
        <p>Your Name: {{ name }}</p>
    </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                name: '',
            }
        }, 
        methods: {
            setName(event, lastName){
                this.name = event.target.value;
            },
            resetInput(){
                this.name = '';
            }
        }
    });

    app.mount('#events');
    ```
1. On the other hand, we can use [`v-model`](https://vuejs.org/v2/guide/forms.html#Basic-Usage) which is a syntax sugar to use on `input`, `textarea`, and `select`. In this case, we don't event need to setup methods on the element to realize render the data. 
    ```html
    <!-- HTML -->
    <section id="events">
        <input type="text" v-model="input">
        <p>Your Name: {{ input }}</p>
    </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                input: '',
            }
        }
    });
    
    app.mount('#events');
    ```

## Methods used for Data Bindings: How it works
1. When we execute any method of a Vue component, all the elements that has `v-model` or use `v-bind` will be rerendered, and the methods will be executed again to get the lastest value. This is similar to React framework that the whole component will be re-rendered and updated. 
1. However, this feature wouldn't be useful in some scenario and we don't want this always happens. In the following setup, we can notice that every time we click "add" or "reduce" button, `outputFullName` will be executed.
1. Note that Vue will update the whole component rather than only the specific item in the component. 
    ```html
    <!-- HTML -->
    <section id="events">
        <h2>Events in Action</h2>
        <button v-on:click="add(10)">Add 10</button>
        <button v-on:click="reduce(5)">Subtract 5</button>
        <p>Result: {{ counter }}</p>
        <button v-on:click="resetInput">Reset Input</button>        
        <input type="text" v-model="name">
        <p>Your Name: {{ outputFullname("Last Name) }}</p>
    </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                counter = 0,
                name: '',
            }
        },
        methods: {
            outputFullName(lastName) {
                console.log('Run outputFullName');
                if (this.name === '') {
                    return '';
                } else {
                    return this.name + ' ' + lastName;
                }
            },
            add(num) {
                return this.counter += num;
            },
            reduce(num) {
                return this.counter -= num;
            }
        }
    });

    app.mount('#events');
    ```

## Introducing Computed Properties
1. In the other case, we can use `computed` (another reserved property) which works similar to `methods`. The main difference between them is that `methods` will be re-rendered when there's any thing changes on the page. On the other hand, `computed` only changes when any of its dependency is modified.
1. To use methods in `computed`, we just put the method name in the interpolation in HTML **WITHOUT** parenthesis. Vue will call the method instead.
1. With this approach, the `fullname` method in the following case won't be trigereed every time when other dependency is modified. 
    ```html
    <!-- HTML -->
    <section id="events">
        <h2>Events in Action</h2>
        <button v-on:click="add(10)">Add 10</button>
        <button v-on:click="reduce(5)">Subtract 5</button>
        <p>Result: {{ counter }}</p>
        <button v-on:click="resetInput">Reset Input</button>
        <input type="text" v-model="name">
        <p>Your Name: {{ fullname }}</p>
    </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                name: '',
            }
        },
        computed: {
            fullname() {
                if (this.name === '') {
                    return '';
                }
                return this.name + ' ' + 'last name';
            }
        },
        method: {
            outputFullname() {
                if (this.name === '') {
                    return '';
                }
                return this.name + ' ' + 'last name';
            }
        }
    })
    ```

## Working with Watchers
1. Though "**watchers**" is similar to `computed` or `methods` in Vue, it's binding with the properties in data and don't return the value to use directly. `watch` is the reserved keyword as `computed`, `data`, and `methods` in Vue.
1. `watch` is bound to the properties in `data` returned and will listen to the change of it. 
    1. The methods created in `watch` should be exactly the same as the property name in `data`. 
    1. We don't return any value as it directly manipulate the value of the property in `data`. 
    1. Methods in `watch` can take 2 arguments (new value after change and old value before change). If only one argument is given, it represents the new value. 
1. `computed` as mentioned in the [last section](#Introducing-Computed-Properties) that it listens to the properties given to the methods when it's called. 
1. Though `watch` and `computed` work in similar behavior, `watch` is more suitable to track on single property in `data` and giving constraints. On the other hand, `computed` is good at tracking on multiple dependencies (multiple properties from `data`) and computed for the result. 
    ```html
    <!-- HTML -->
    <section id="events">
        <h2>Events in Action</h2>
        <button v-on:click="resetInput">Reset Input</button>
        <input type="text" v-model="name">
        <input type="text" v-model="lastName">
        <p>Your Name: {{ fullname }}</p>
    </section>
    ```
    ```js
    // JavaScript 
    const app = Vue.createApp({
        data() {
            return {
                name: '',
                lastName: '',
                fullname: '' // this should be taken off if fullname in computed is declared
            }
        },
        watch: { // following methods works exactly the same as fullname method in computed
            name(value){
                if (value === '') {
                    this.fullName = '';
                } else {
                    this.fullName = value + ' ' + this.lastName;
                }
            },
            lastName(value) {
                if (value === '') {
                    this.fullName = '';
                } else {
                    this.fullName = this.name + ' ' + value;
                }
            }
        },
        computed: {
            fullname() {
                if (this.name === '') {
                    return '';
                }
                return this.name + ' ' + this.lastName;
            }
        },
    })
    ```
1. In short summary, methods in `watch` and properties in `data` should have exactly the same name to bound the data, while both of them will get conflict if it's declared in `computed` or `methods`. For example, we can set `setTimeout` to reset the counter when the number is over 50 after 2 seconds. 
    ```html
    <!-- HTML -->
    <section id="events">
        <h2>Events in Action</h2>
        <button v-on:click="add()">Add</button>
        <button v-on:click="reduce()">Subtract</button>
        <p>Result: {{ counter }}</p>
    </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                counter: 0
            };
        },
        watch: {
            counter(value) {
            if (value > 50) {
                setTimeout(() => {
                        this.counter = 0;
                    }, 2000);
                }
            }
        }, 
        methods: {
            add(event, num = 1) {
                this.counter += num;
            },
            reduce(event, num = 1) {
                this.counter -= num;
            }
        }
    });

    app.mount('#events');    
    ```

## Methods vs Computed Properties vs Watchers
1. `methods`
    1. Use with **event** binding OR **data** binding.
    1. Data binding: Method is executed for every "re-render" cycle of the component.
    1. Use for events or data that really needs to be re-evaluated all the time.
1. `computed`
    1. Use with **data** binding.
    1. Computed properties are only re-evaluated if one of their "**used values**" changed.
    1. Use for data that depends on other data.
1. `watch`
    1. Not used directly in template.
    1. Allows you to run any code in reaction to some changed data (e.g. send Http request etc.)
    1. Use for any non-data update you want to make.

## v-bind and v-on Shorthands
1. In Vue, we can use a shorthand to indicate `v-on` attribute in HTML as an `@` sign. Note that we can still put modifiers on the event handler, such as `.right` to listen to right click for "click" event. 
    ```html
    <!-- HTML -->
    <button v-on:click="add(5)">Add</button>
    <button @click.right="reduce(5)">Subtract</button>
    ```
1. For `v-bind`, we can simply use a column `:` to replace the attribute.
    ```html
    <!-- HTML -->
    <a v-bind:href="variable">A Link</a>
    <a :href="variable">A Link</a>
    ```

## Assignmetns 3: Time to practice: Reactivity
1. HTML source code
    ```html
    <body>
    <header>
        <h1>Reactivity in Action</h1>
    </header>
    <section id="assignment">
        <button>Add 5</button>
        <button>Add 1</button>
        <!-- 1) Connect the buttons and calculate a value (a number) -->
        <!-- Show "Not there yet" until you reach a result of exactly 37 -->
        <!-- Show "Too much!" if the result is greater than 37 -->
        <p>Result: RESULT</p>
        <!-- 2) Watch for changes in "result" and reset the value to 0 after 5 seconds -->
    </section>
    </body>
    ```
1. First approach by using only methods. Note that we must call the method in interpolation.
    ```html
    <!-- HTML -->
    <section id="assignment">
        <button @click="add(5)">Add 5</button>
        <button @click="add(1)">Add 1</button>
        <p>Result: {{ result() }}</p>
        <!-- the method must be called -->
    </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                number: 0,
                text: '',
            }
        },
        methods: {
            add(num = 1) {
                this.number += num;
            },
            result() {
                if (this.number > 37) {
                    this.text = 'Too much';
                    setTimeout(() => {
                        this.number = 0;
                    }, 1500);
                } else {
                    this.text = 'Not there yet';
                }
                return this.text;
            }
        }
    });

    app.mount('#assignment');
    ```
1. Second approach that uses all `methods`, `computed`, and `watch`. Note that as `result` is a computed method, it is consumed as a variable by Vue, so we can't call it in the interpolation.
    ```html
    <!-- HTML -->
    <section id="assignment">
        <button @click="add(5)">Add 5</button>
        <button @click="add(1)">Add 1</button>
        <p>Result: {{ result }}</p>
        <!-- the method can't be called -->
    </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                number: 0,
                text: 'Not there yet',
            }
        },
        watch: {
            number(value) {
                if (value > 37) {
                    this.text = 'Too much';
                } else {
                    this.text = 'Not there yet';
                }
            }
        },
        computed: {
            result() {
                if (this.number > 37) {
                    setTimeout(() => {
                        this.number = 0;
                    }, 1500);
                }
                return this.text
            }
        },
        methods: {
            add(num = 1) {
                this.number += num;
            }
        }
    });

    app.mount('#assignment');
    ```
1. Third approach uses only `methods` and `computed`.
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                number: 0,
                text: 'Not there yet',
            }
        },
        computed: {
            result() {
                if (this.number > 37) {
                    this.text = 'Too much';
                    setTimeout(() => {
                        this.number = 0;
                    }, 1500);
                } else {
                    this.text = 'Not there yet';
                }
                return this.text
            }
        },
        methods: {
            add(num = 1) {
                this.number += num;
            }
        }
    });

    app.mount('#assignment');
    ```
1. Solution from the lecture. A watcher can also "watch" on the methods in `computed`. 
    ```html
    <!-- HTML -->
    <section id="assignment">
        <button @click="add(5)">Add 5</button>
        <button @click="add(1)">Add 1</button>
        <p>Result: {{ result }}</p>
        <!-- the method can't be called -->
    </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                number: 0,
            }
        },
        watch: {
            result() {
                setTimeout(() => {
                    this.number = 0;
                }, 1500);
            }
        },
        computed: {
            result() {
                if (this.number > 37) {
                    return 'Too much';
                } else if (this.number === 37) {
                    return this.number;
                } else {
                    return 'Not there yet';
                }
            }
        },
        methods: {
            add(num = 1) {
                this.number += num;
            }
        }
    });

    app.mount('#assignment');
    ```

## Dynamic Styling with Inline Styles
1. We can use `v-bind` or its shorthand column `:` to select `style` attribute of a HTML tag. Besides, passing a regular CSS property such as `border-color` we can use curly braces to wrap it and use "**camelCase**" on the property.
1. We then can refer to the `data` for the Vue component and use tenary statement to check what value to return for the style. Note that we can pass the data variable directly in the curly braces.
1. Though we can use `methods` to manulate the style with JavaScript DOM, as we can get the `event` object and change the property with DOM selector `event.target.style.borderColor`. 
    1. However, the first click will only turn the color to red by inline style as the "**state**" just changes, and the component is re-rendered.
    1. Since the "state" has changed and won't change by the 2nd click, the `method` can work on the DOM manipulate and turn the `border-color` into the other given color. 
    ```html
    <!-- HTML -->
    <body>
        <header>
            <h1>Vue Dynamic Styling</h1>
        </header>
        <section id="styling">
            <div class="demo" 
                :style="{borderColor: boxASelected ? 'red' : '#ccc'}" 
                @click="boxSelected($event, 'A')">
            </div>
            <div class="demo" @click="boxSelected('B')"></div>
            <div class="demo" @click="boxSelected('C')"></div>
        </section>
    </body>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                boxASelected: false,
                boxBSelected: false,
                boxCSelected: false,
            };
        },
        methods: {
            boxSelected(event, box) {
                if (box === 'A') {
                    this.boxASelected = true;
                    event.target.style.borderColor = 'blue';
                } else if (box === 'B') {
                    this.boxBSelected = true;
                } else if (box === 'B') {
                    this.boxCSelected = true;
                }
            }
        }
    });

    app.mount('#styling');
    ```

## Adding CSS Classes Dynamically
1. In a Vue component, we can use both `v-bind:class` and a regular "**class**" attribute in HTML tag. Therefore, we can keep both dynamic and static classes in the same element. 
1. With bound attribute, we can use Vue interpolation to check whether th apply the class to the element. 
1. A bound class can take a JavaScript object which has the name of the class as the property and a boolean value to indicate whether to apply the class or not.
    ```html
    <!-- HTML -->
    <div :class="{active: true}">
    ```
1. Besides, to toggle the properties, we can give an initial value and set it as the reversed value by an exclamation mark `!`. 
    ```html
    <!-- HTML -->
    <section id="styling">
        <div class="demo" :class="{active: boxASelected}" @click="boxSelected('A')">
        </div>
        <div class="demo" :class="{active: boxBSelected}" @click="boxSelected('B')"></div>
        <div class="demo" :class="{active: boxCSelected}" @click="boxSelected('C')"></div>
  </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                boxASelected: false,
                boxBSelected: false,
                boxCSelected: false,
            };
        },
        methods: {
            boxSelected(box) { // toggle the property
                if (box === 'A') {
                    this.boxASelected = !this.boxASelected;
                } else if (box === 'B') {
                    this.boxBSelected = !this.boxBSelected;
                } else if (box === 'C') {
                    this.boxCSelected = !this.boxCSelected;
                }
            }
        }
    });

    app.mount('#styling');
    ```

## Classes & Computed Properties
1. Since we can pass an object to bound `class`, we can use `computed` to return an object.
    ```html
    <!-- HTML -->
    <section id="styling">
    <div class="demo" :class="boxAClasses" @click="boxSelected('A')">
    </div>
    <div class="demo" :class="{active: boxBSelected}" @click="boxSelected('B')"></div>
    <div class="demo" :class="{active: boxCSelected}" @click="boxSelected('C')"></div>
  </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                boxASelected: false,
            }
        },
        computed: {
            boxAClasses() {
                return {
                    active: this.boxASelected
                }
            }
        },
        methods: {
            boxSelected(box) {
                if (box === 'A') {
                    this.boxAselected = !this.boxAselected;
                }
            }
        }
    });
    ```
    ```css
    /* CSS */
    .active {
        border-color: red;
        background-color: salmon;
    }
    ```

## Dynamic Classes: Array Syntax
1. Besides passing an object, we can also pass an array of classes (in `string` or `object`). Therefore, we can have only a bound class attribute in the HTML tag.
    ```html
    <!-- HTML -->
    <section id="styling">
        <div :class="['demo', boxAClasses]" @click="boxSelected('A')">
        </div>
        <div :class="['demo', {active: boxBSelected}]" @click="boxSelected('B')"></div>
        <div class="demo" :class="{active: boxCSelected}" @click="boxSelected('C')"></div>
  </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data(){
            return {
                boxASelected: false;
                boxBSelected: false;
                boxCSelected: false;
            }
        },
        computed: {
            boxAClasses() {
                return {
                    active: boxASelected
                }
            },
            boxBClasses() {
                return {
                    active: boxBSelected
                }
            },
            boxCClasses() {
                return {
                    active: boxCSelected
                }
            }
        },
        methods: {
            boxSelected(box) {
                if (box === 'A') { 
                    this.boxASelected = !this.boxASelected
                }
                else if (box === 'B') { 
                    this.boxBSelected = !this.boxBSelected
                }
                else if (box === 'C') { 
                    this.boxCSelected = !this.boxCSelected
                }
            }
        }
    });

    app.mount('#styling');
    ```

## Assignment 4: Time to practice: Dynamic Styling
1. HTML source code 
    ```html
    <!DOCTYPE html>
    <html lang="en">
        <head>
            <meta charset="UTF-8" />
            <meta name="viewport" content="width=device-width, initial-scale=1.0" />
            <title>Vue Basics</title>
            <link
            href="https://fonts.googleapis.com/css2?family=Jost:wght@400;700&display=swap"
            rel="stylesheet"
            />
            <link rel="stylesheet" href="styles.css" />
            <script src="https://unpkg.com/vue@next" defer></script>
            <script src="app.js" defer></script>
        </head>
    <body>
        <header>
            <h1>Vue Styling</h1>
        </header>
        <section id="assignment">
            <!-- 1) Fetch the user input and use it as a CSS class -->
            <!-- The entered class should be added to the below paragraph -->
            <input type="text" />
            <!-- (available classes: "user1", "user2) -->
            <p>
                Style me!
            </p>
            <button>Toggle Paragraph</button>
            <!-- 2) Use the "visible" and "hidden" classes to show/ hide the above paragraph -->
            <!-- Clicking the button should toggle between the two options -->

            <!-- 3) Add dynamic inline styling to the below paragraph and let the user enter a background-color -->
            <input type="text" />
            <p>Style me inline!</p>
        </section>
    </body>
    </html>
    ```
1. Approaches for task 1
    1. use only `watch` and `v-model` in HTML
        ```html
        <!-- HTML -->
        <section id="assignment">
            <input type="text" v-model="user" />
            <p :class="userClass">
            Style me!
            </p>
        </section>
        ```
        ```js
        // JavaScript
        const app = Vue.createApp({
            data() {
                return {
                    user: '',
                    userClass: null
                }
            },
            watch: {
                user(value) {
                    if (value === 'user1') {
                        this.userClass = { user1: true };
                    } else if (value === 'user2') {
                        this.userClass = { user2: true };
                    } else {
                        this.userClass = null;
                    }
                }
            }
        });

        app.mount('#assignment');
        ```
    1. use only `methods` and `v-on` in HTML
        ```html
        <!-- HTML -->
        <section id="assignment">
            <input type="text" v-on:input="userInput" />
            <p :class="userClass">
            Style me!
            </p>
        </section>
        ```
        ```js
        // JavaScript
        const app = Vue.createApp({
            data() {
                return {
                    user: '',
                    userClass: null
                }
            },
            methods: {
                userInput(event) {
                    this.user = event.target.value;
                    if (this.user === 'user1') {
                        this.userClass = { user1: true };
                    } else if (this.user === 'user2') {
                        this.userClass = { user2: true };
                    } else {
                        this.userClass = null;
                    }
                }
            }
        });

        app.mount('#assignment');
        ```
    1. use only `computed` and `v-model`
        ```html
        <!-- HTML -->
        <section id="assignment">
            <input type="text" v-model="user" />
            <p :class="userClass">
            Style me!
            </p>
        </section>
        ```
        ```js
        // JavaScript
        const app = Vue.createApp({
            data() {
                return {
                    user: '',
                }
            }
            computed: {
                userClass() {
                    if (this.user === 'user1') {
                        return { user1: true }
                    } else if (this.user === 'user2') {
                        return { user2: true }
                    } else {
                        return null
                    }
                }
            }
        });

        app.mount('#assignment');
        ```
1. Approaches for task 2
    1. Use `computed` and `methods`
        ```html
        <!-- HTML -->
        <section id="assignment">
            <p :class="[toggle]">
            Style me!
            </p>
            <button @click="toggleParagraph">Toggle Paragraph</button>
        </section>
        ```
        ```js
        // JavaScript
        const app = Vue.createApp({
            data() {
                return {
                    show: true,
                }
            },
            computed: {
                toggle() {
                    return {
                        visible: this.show,
                        hidden: !this.show
                    }
                }
            },
            methods: {
                toggleParagraph() {
                    this.show = !this.show;
                }
            }
        });

        app.mount('#assignment');
        ```
    1. Use only `methods`
        ```html
        <!-- HTML -->
        <section id="assignment">
            <p :class="[toggle()]">
            Style me!
            </p>
            <button @click="toggleParagraph">Toggle Paragraph</button>
        </section>
        ```
        ```js
        // JavaScript
        const app = Vue.createApp({
            data() {
                return {
                    show: true,
                }
            },
            methods: {
                toggleParagraph() {
                    this.show = !this.show;
                },
                toggle() {
                    return {
                        visible: this.show,
                        hidden: !this.show
                    }
                }
            }
        });

        app.mount('#assignment');
        ```
    1. Use `watch` and `methods`
        ```html
        <section id="assignment">
            <p :class="[userClass, visibleClass]">
            Style me!
            </p>
            <button @click="toggleParagraph">Toggle Paragraph</button>
        </section>
        ```
        ```js
        // JavaScript
        const app = Vue.createApp({
            data() {
                return {
                    user: '',
                    show: true,
                    visibleClass: null
                }
            },
            watch: {
                show(value) {
                    this.visibleClass = {
                        visible: value,
                        hidden: !value
                    }
                }
            },
            methods: {
                toggleParagraph() {
                    this.show = !this.show;
                }
            }
        });

        app.mount('#assignment');
        ```
1. Approaches for task 3
    1. Use only `v-model` and inline styling in HTML
        ```html
        <!-- HTML -->
        <section id="assignment">
            <input type="text" v-model="color" />
            <p :style="{'color': color}">Style me inline!</p>
        </section>
        ```
        ```js
        // JavaScript
        const app = Vue.createApp({
            data() {
                return {
                    color: '',
                }
            }
        });

        app.mount('#assignment');
        ```
    1. Use only `computed` and `v-model`
        ```html
        <!-- HTML -->
        <section id="assignment">
            <input type="text" v-model="color" />
            <p :style="textColor">Style me inline!</p>
        </section>
        ```
        ```js
        // JavaScript
        const app = Vue.createApp({
            data() {
                return {
                    color: '',
                }
            },
            computed: {
                textColor() {
                    if (this.color) {
                        return {
                            color: this.color
                        }
                    }
                }
            }
        });

        app.mount('#assignment');
        ```
    1. Use `watch` and `v-model`
        ```html
        <!-- HTML -->
        <section id="assignment">
            <input type="text" v-model="color" />
            <p :style="textColor">Style me inline!</p>
        </section>
        ```
        ```js
        // JavaScript
        const app = Vue.createApp({
            data() {
                return {
                    color: '',
                    textColor: null
                }
            },
            watch: {
                color(color) {
                    if (color) {
                        this.textColor = {
                            color
                        }
                    }
                }
            }
        });

        app.mount('#assignment');
        ```
    1. Use `v-on` and `methods`
        ```html
        <!-- HTML -->
        <section id="assignment">
            <input type="text" v-on:input="changeColor" />
            <p :style="textColor">Style me inline!</p>
        </section>
        ```
        ```js
        // JavaScript
        const app = Vue.createApp({
            data() {
                return {
                    textColor: null
                }
            },
            methods: {
                changeColor(event) {
                    if (event.target.value) {
                        this.textColor = {
                            color: event.target.value
                        }
                    }
                }
            }
        });

        app.mount('#assignment');
        ```
1. Solutions from the lecture
    1. Task 1
        ```html
        <!-- HTML -->
        <section id="assignment">
            <input type="text" v-model="inputClass">
            <p :class="inputClass">Style me!</p>
        <section>
        ```
        ```js
        // JavaScript
        const app = Vue.createApp({
            data() {
                return {
                    inputClass: ''
                }
            }
        });

        app.mount('#assignment');
        ```
    1. Task 2
        ```html
        <!-- HTML -->
        <section id="assignment">
            <input type="text" v-model="inputClass">
            <p :class="inputClass">Style me!</p>
            <button @click="toggleParagraphVisibility">Toggle Paragraph</
        <section>
        ```
        ```js
        // JavaScript
        const app = Vue.createApp({
            data() {
                return {
                    inputClass: '',
                    paragraphIsVisible: true
                }
            },
            computed: {
                paraClasses() {
                    return {
                        user1: this.inputClass === 'user1',
                        user2: this.inputClass === 'user2',
                        visible: this.paragraphIsVisible,
                        hidden: !this.paragraphIsVisible,
                    }
                }
            }
        });

        app.mount('#assignment');
        ```
    1. Task 3
        ```html
        <!-- HTML -->
        <section id="assignment">
            <input type="text" v-model="inputBackgroundColor" />
            <p :style="{backgroundColor: inputBackgroundColor}">Style me inline!</p>
        </section>
        ```
        ```js
        // JavaScript
        const app = Vue.createApp({
            data() {
                return {
                    inputBackgroundColor: '',
                }
            }
        });

        app.mount('#assignment');
        ```



# Redenering Conditional Content & Lists
## Understanding the Problem
1. In this case, we will show the `p` indicating that there's no goal.
1. We'd like to allow users to give new values with `input` tag. The new values shoule be added as `li` elements in the list `ul`.
    ```html
    <!-- HTML -->
    <body>
    <header>
      <h1>Vue Course Goals</h1>
    </header>
    <section id="user-goals">
      <h2>My course goals</h2>
      <input type="text" />
      <button>Add Goal</button>
      <p>No goals have been added yet - please start adding some!</p>
      <!-- show p tag above when there's nothing in the list -->
      <ul>
        <li>Goal</li>
      </ul>
    </section>
  </body>
    ```

## Rendering Content Conditionally
1. We can use `v-model` to bind the data of Vue component to collect the value from user input, and declare a method to add the input value to store in the array.
1. We can use `v-if` in the `p` tag to check whether there's any item in the array and only shows when the array is empty. 
    ```html
    <!-- HTML -->
    <section id="user-goals">
        <h2>My course goals</h2>
        <input type="text" v-model="enteredGoalValue" />
        <button @click="addGoal">Add Goal</button>
        <p v-if="goals.length === 0">No goals have been added yet - please start adding some!</p>
        <ul>
            <li>Goal</li>
        </ul>
  </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
            enteredGoalValue: '',
            goals: []
            };
        },
        methods: {
            addGoal() {
                this.goals.push(this.enteredGoalValue);
            }
        }
    });

    app.mount('#user-goals');

    ```

## v-if, v-else and v-else-if
1. We can use not only `v-if` to control the elements but also `v-else-if` and `v-else` as regular logical statements. However, `v-else-if` and `v-else` should come right after in the element that "adjacent" to the element with `v-if` (not child or parent).
    ```html
    <!-- HTML -->
    <section id="user-goals">
        <h2>My course goals</h2>
        <input type="text" v-model="enteredGoalValue" />
        <button @click="addGoal">Add Goal</button>
        <p v-if="goals.length === 0">No goals have been added yet - please start adding some!</p>
        <ul v-else>
            <li>Goal</li>
        </ul>
  </section>
    ```

## Using v-show Instead of v-if
1. Besides `v-if`, we can use `v-show` which takes an expression to check whether to show a HTML element. 
1. The main difference between `v-if` and `v-show` controlled elements is that `v-if` do "remove" the element from the page, while `v-show` just apply `display: none` property to the the element, so the element is still on the page but not visible.
1. Therefore, in some cases that an element is toggled very often, we can use `v-show` rather than `v-if` to improve App performance.

## Rendering Lists of Data
1. To render items in an JavaScript `array`, we can use `v-for` on the element.
1. The syntax for `v-for` is similar to call the properties of JavaScript objects which use `in`, (though `of` keyword also works, it is recommended to use `in`).
1. We then can use the variable to create dynamic items in the list according to the array data in the `state`. 
1. Note that Vue doesn't re-render the whole item but cache the data and only change the elements according to the data. 
1. For example, the number of items in the list is aligned to the number of items in the JavaScript array it bound to. When any item is added or removed from the array, only the HTML element aligned to the data will be modified rather than the whole list.
    ```html
    <!-- HTML -->
    <section id="user-goals">
        <h2>My course goals</h2>
        <input type="text" v-model="enteredGoalValue" />
        <button @click="addGoal">Add Goal</button>
        <p v-if="goals.length === 0">No goals have been added yet - please start adding some!</p>
        <ul v-else>
            <li v-for="goal in goals">{{ goal }}</li>
        </ul>
    </section>
    ```

## Diving Deeper Into v-for
1. We can not only declare a variable for the item in the array but also the index of the item.
1. The syntax is to wrap the variables in the parenthesis and give a 2nd argument as `(var, index) in array`
    ```html
    <!-- HTML -->
    <section id="user-goals">
        <h2>My course goals</h2>
        <input type="text" v-model="enteredGoalValue" />
        <button @click="addGoal">Add Goal</button>
        <p v-if="goals.length === 0">No goals have been added yet - please start adding some!</p>
        <ul v-else>
            <li v-for="(goal, index) in goals">{{ index }} - {{ goal }}</li>
        </ul>
    </section>
    ```
1. Besides arrays, we can use `v-for` to loop through a JavaScript `object`.
    ```html
    <!-- HTML -->
    <ul>
        <li v-for="(value, key, index) in {name: 'Max', age: 31}">{{ index + 1 }} - {{ key }}: {{ value }}</li>
    </ul>
    ```
1. In addition, we can simply create a number list with `v-for` by giving a variable and a nubmer
    ```html
    <!-- HTML -->
    <ul>
        <li v-for="num in 10">{{ num }}</li>
    </ul>
    ```

## Removing List Items
1. With the power of `v-for`, we can use it with `methods` to "**remove**" items from the list. In this case, we can use [`.splice`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice) array method to remove an element from the array at a given position (index).
1. Note that the variable `index` we pass to the method is only accessible if the method is in the same element as the element using `v-for`.
    ```html
    <!-- HTML -->
    <section id="user-goals">
        <h2>My course goals</h2>
        <input type="text" v-model="enteredGoalValue" />
        <button @click="addGoal">Add Goal</button>
        <p v-if="goals.length === 0">No goals have been added yet - please start adding some!</p>
        <ul v-else>
            <li v-for="(goal, index) in goals" @click="removeGoal(index)">{{ goal }} - {{ index }}</li>
        </ul>
    </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                enteredGoalValue: '',
                goals: []
            };
        },
        methods: {
            addGoal() {
                this.goals.push(this.enteredGoalValue);
            },
            removeGoal(index) {
                this.goals.splice(index, 1);
            }
        }
    });

    app.mount('#user-goals');
    ```

## Lists & Keys
1. If we have another element nested in another element and both use event handler for `click` event, we can use the shorthand in Vue to stop propagation.
1. In the previous example, we have the item in the list to be removed when the user clicks on the element. However, if we now give an `input` tag to collect other data, it will be closed when the user clicks on the nested `input` tag. Therefore, we need to stop propagation for the case.  
    ```html
    <!-- HTML -->
    <section id="user-goals">
        <h2>My course goals</h2>
        <input type="text" v-model="enteredGoalValue" />
        <button @click="addGoal">Add Goal</button>
        <p v-if="goals.length === 0">No goals have been added yet - please start adding some!</p>
        <ul v-else>
            <li v-for="(goal, index) in goals" @click="removeGoal(index)">
                <p>{{ goal }} - {{ index }}</p>
                <input type="text" name="" id="" @click.stop>
                <!-- shorthand to stop propagation -->
            </li>
        </ul>
    </section>
    ```
1. However, Vue has a bug on the event that the input values will be passed on in the nested elements.
1. The issue comes from the optimization mechanism of Vue. It doesn't remove the first element when we delete it but keeps it and remove the 2nd one and move the contents of the 2nd one to the first one.
1. Only the dynamic content, which is declare in `p` tag as `{{ goal }} - {{ index }}` in the example above, will be updated. 
    <img src="images/46-bugs_in_vue_list.gif">
1. Thus, if we work another way around to have input in the 2nd item in the list, the value will be removed when the 1st element is deleted. 
    <img src="images/46-bugs_in_vue_list_2.gif">
1. Vue has a solution which is similar to React that it gives an unique "**key**" to the item in the list. Note that the key is not a HTML attribute so as it in React app. Besdies, it needs to use `v-bind` or the shorthand column `:` to bind the data.
1. In real practice, it's better to use the "**id**" of the item, which is NOT the index because the index is dynamic when the items are added or removed from the array. Besides, the content itself could be too long as an unique identifier. However, we can simply use the content `goal` as the unqiue identifier in this case.
    ```html
    <!-- HTML -->
    <section id="user-goals">
        <h2>My course goals</h2>
        <input type="text" v-model="enteredGoalValue" />
        <button @click="addGoal">Add Goal</button>
        <p v-if="goals.length === 0">No goals have been added yet - please start adding some!</p>
        <ul v-else>
            <li v-for="(goal, index) in goals" :key="goal" @click="removeGoal(index)">
                <!-- :key bond attribute indicates to Vue that which element is going to be modifed -->
                <p>{{ goal }} - {{ index }}</p>
                <input type="text" name="" id="" @click.stop>
            </li>
        </ul>
    </section>
    ```
## Assignment 5: Time to Practice: Conditional Content & Lists
1. HTML source code
    ```html
    <body>
        <header>
            <h1>Vue Lists and Conditional Content</h1>
        </header>
        <section id="assignment">
            <h2>Assignment</h2>
            <!-- 1) Add code to manage a list of tasks in a Vue app -->
            <!-- When clicking "Add Task" a new task with the entered text should be added -->
            <input type="text">
            <button>Add Task</button>
            <ul>
                <!-- 2) Output the list of tasks here -->
            </ul>
            <!-- 3) When the below button is pressed, the list should be shown or hidden -->
            <!-- BONUS: Also update the button caption -->
            <button>Hide / Show List</button>
        </section>
    </body>
    ```
1. Use `methods` and `watch` in JavaScript with `v-show` and `v-for` in HTML. Delete feature is added when the user clicks on the item in the list, the item will be removed and `tasks` array in `data` will be updated.
    ```html
    <!-- HTML -->
    <section id="assignment">
        <h2>Assignment</h2>
        <input type="text" v-model="task">
        <button @click="addTask">Add Task</button>
        <ul v-show="show">
            <li v-for="(item, index) in tasks" :key="item" @click="removeItem(index)">{{ index + 1}} - {{ item }}</li>
        </ul>
        <button @click="toggleList">{{ btnText }} List</button>
    </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                show: true,
                btnText: 'Hide',
                task: '',
                tasks: []
            }
        },
        watch: {
            show(value) {
                if (value) {
                    this.btnText = 'Hide';
                } else {
                    this.btnText = 'Show';
                }
            }
        },
        methods: {
            addTask() {
                this.tasks.push(this.task);
            },
            toggleList() {
                this.show = !this.show;
            },
            removeItem(index) {
                this.tasks.splice(index, 1);
            }
        }
    });

    app.mount('#assignment');
    ```
1. Solution from the lecture. `computed` and `methods` are used in this case.
    ```html
    <!-- HTML -->
    <section id="assignment">
        <h2>Assignment</h2>
        <input type="text" v-model="task">
        <button @click="addTask">Add Task</button>
        <ul v-show="show">
            <li v-for="(item, index) in tasks" :key="item" >{{ index + 1}} - {{ item }}</li>
        </ul>
        <button @click="toggleList">{{ btnText }} List</button>
    </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                show: true,
                task: '',
                tasks: []
            }
        },
        computed: {
            btnText() {
                if (this.show) {
                    return 'Hide';
                }
                return 'Show';
            }
        },
        methods: {
            addTask() {
                this.tasks.push(this.task);
            },
            toggleList() {
                this.show = !this.show;
            }
        }
    });

    app.mount('#assignment');
    ```

## Summary 
1. **DO NOT** use `v-if` and `v-for` on the same element. Use a wrapper with `v-if` instead.
    <img src="images/47-module_summary.png">



# Coure Project: The Monster Slayer Game
## Project Setup & First Methods
1. The game allows the uesr acts as a player to slay a monster where both entities have certain amount of health (HP). The player can choose to "**attack**", "**special attack**", "**heal**", or "**surrender**". Both the monster and the player can attack and damage random amount of health on each other. 
1. HTML source code
    ```html
    <!DOCTYPE html>
    <html lang="en">

    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Vue Basics</title>
        <link href="https://fonts.googleapis.com/css2?family=Jost:wght@400;700&display=swap" rel="stylesheet" />
        <link rel="stylesheet" href="styles.css" />
        <script src="https://unpkg.com/vue@next" defer></script>
        <script src="app.js" defer></script>
    </head>

    <body>
        <header>
            <h1>Monster Slayer</h1>
        </header>
        <div id="game">
            <section id="monster" class="container">
                <h2>Monster Health</h2>
                <div class="healthbar">
                    <div class="healthbar__value"></div>
                </div>
            </section>
            <section id="player" class="container">
                <h2>Your Health</h2>
                <div class="healthbar">
                    <div class="healthbar__value"></div>
                </div>
            </section>
            <section id="controls">
                <button>ATTACK</button>
                <button>SPECIAL ATTACK</button>
                <button>HEAL</button>
                <button>SURRENDER</button>
            </section>
            <section id="log" class="container">
                <h2>Battle Log</h2>
                <ul></ul>
            </section>
        </div>
    </body>

    </html>
    ```
1. We'd like to calculate a random value when the play attacks on the monster and triggers another method to allow the monster to attack back.
1. We can use `Math.random` and `Math.floor` to calculate an integer between a given range. Since both the player and monster uses the same formula, we can declare it as a function out of the Vue instance.
1. In a Vue instance, as calling `data` in the same object with `this`, we can also call the method in the same instance.
1. Note that we haven't updated the UI in this section yet.
    ```js
    // JavaScript
    function getRandomValue(min, max) { // used by both player and monster
        return Math.floor(Math.random() * (max - min)) + min;
    }

    const app = Vue.createApp({
        data() {
            return {
                playerHealth: 100,
                monsterHealth: 100
            };
        },
        methods: {
            attackMonster() {
                const attackValue = getRandomValue(5, 12);
                this.monsterHealth -= attackValue;
                this.attackPlayer(); // triger the monster to attackwhen it is attacked by the player
            },
            attackPlayer() {
                const attackValue = getRandomValue(8, 15);
                this.playerHealth -= attackValue;
            }
        }
    });

    app.mount('#game');
    ```

## Updating the Health Bars
1. We can use `width` property on the health bar to control the UI. Though we can use inline expression for Vue component direclty, we should follow the principle to have least logical on HTML and use it for only structuring the page.
1. Note that to change a bond HTML attribute for styling, we should pass an object and change the property name to modify in camelCase. 
1. In addition, though we don't use expressions in HTML directly, we can use JavaScript template literals in the expression of Vue component.
    ```html
    <!-- HTML -->
    <div id="game">
        <section id="monster" class="container">
            <h2>Monster Health</h2>
            <div class="healthbar">
                <div class="healthbar__value" :style="monsterBarStyles"></div>
            </div>
        </section>
        <section id="player" class="container">
            <h2>Your Health</h2>
            <div class="healthbar">
                <div class="healthbar__value" :style="playerBarStyles"></div>
            </div>
        </section>
    </div>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                playerHealth: 100,
                monsterHealth: 100
            };
        },
        computed: {
            monsterBarStyles() {
                return { width: `${this.monsterHealth}%` }
            },
            playerBarStyles() {
                return { width: `${this.playerHealth}%` }
            }
        },
        methods: {
            attackMonster() {
                const attackValue = getRandomValue(5, 12);
                this.monsterHealth -= attackValue;
                this.attackPlayer();
            },
            attackPlayer() {
                const attackValue = getRandomValue(8, 15);
                this.playerHealth -= attackValue;
            }
        }
    });
    ```

## Adding a "Special Attack"
1. We allow the player to have a "special attack" every 3 rounds to have a higher damage to the monster. 
1. In HTML, we use `v-bind` on `disabled` HTML attribute to prevent users from abusing special attacks.
    ```html
    <div id="game">
        <section id="controls">
            <button @click="attackMonster">ATTACK</button>
            <button :disabled="mayUseSpecialAttack" @click="specialAttackMonster">SPECIAL ATTACK</button>
            <button>HEAL</button>
            <button>SURRENDER</button>
        </section>
    </div>
    ```
1. We then use `computed` with modular operator to check if the remainder is equal to 3.
    ```js
    // JavaScript
    function getRandomValue(min, max) {
        return Math.floor(Math.random() * (max - min)) + min;
    }

    const app = Vue.createApp({
        data() {
            return {
                playerHealth: 100,
                monsterHealth: 100,
                currentRound: 0
            };
        },
        computed: {
            monsterBarStyles() {
                return { width: `${this.monsterHealth}%` }
            },
            playerBarStyles() {
                return { width: `${this.playerHealth}%` }
            },
            mayUseSpecialAttack() {
                return this.currentRound % 3 !== 0;
            }
        },
        methods: {
            attackMonster() {
                this.currentRound++;
                const attackValue = getRandomValue(5, 12);
                this.monsterHealth -= attackValue;
                this.attackPlayer();
            },
            attackPlayer() {
                const attackValue = getRandomValue(8, 15);
                this.playerHealth -= attackValue;
            },
            specialAttackMonster() {
                this.currentRound++;
                const attackValue = getRandomValue(10, 25);
                this.monsterHealth -= attackValue;
                this.attackPlayer();
            }
        }
    });

    app.mount('#game');
    ```

## Adding a "Heal" Functionality
1. We allow the user to "health" the play by recovering a random amount of health, while in the same round the monster should give another attack to the player.
1. Besides, we should limiat the amount of health of the player to not exceeding `100`.
    ```html
    <!-- HTML -->
    <div id="game">
        <section id="controls">
            <button @click="attackMonster">ATTACK</button>
            <button :disabled="mayUseSpecialAttack" @click="specialAttackMonster">SPECIAL ATTACK</button>
            <button @click="healPlayer">HEAL</button>
            <button>SURRENDER</button>
        </section>
    </div>
    ```
    ```js
    // JavaScript
    function getRandomValue(min, max) {
        return Math.floor(Math.random() * (max - min)) + min;
    }

    const app = Vue.createApp({
        data() {
            return {
                playerHealth: 100,
                monsterHealth: 100,
                currentRound: 0
            };
        },
        computed: {
            monsterBarStyles() {
                return { width: `${this.monsterHealth}%` }
            },
            playerBarStyles() {
                return { width: `${this.playerHealth}%` }
            },
            mayUseSpecialAttack() {
                return this.currentRound % 3 !== 0;
            }
        },
        methods: {
            attackMonster() {
                this.currentRound++;
                const attackValue = getRandomValue(5, 12);
                this.monsterHealth -= attackValue;
                this.attackPlayer();
            },
            attackPlayer() {
                const attackValue = getRandomValue(8, 15);
                this.playerHealth -= attackValue;
            },
            specialAttackMonster() {
                this.currentRound++;
                const attackValue = getRandomValue(10, 25);
                this.monsterHealth -= attackValue;
                this.attackPlayer();
            },
            healPlayer() {
                this.currentRound++;
                const healValue = getRandomValue(8, 20);
                if (this.playerHealth + healValue > 100) {
                    this.playerHealth = 100;
                } else {
                    this.playerHealth += healValue;
                }
                this.attackPlayer();
            }
        }
    });

    app.mount('#game');
    ```

## Adding a "Game Over" Screen
1. We add a new section to show "game over" part when there's a winner of the game. Besides, we can use `v-if` to show this section only when the player or monster wins. 
1. Besides, we use a `watcher` to keep tracking on the `winner` data when it is changed when theres a winner of the game.
    ```html
    <!-- HTML -->
    <div id="game">
        <section class="container" v-if="winner">
            <h2>Game Over!</h2>
            <h3 v-if="winner === 'monster'">You lost!</h3>
            <h3 v-else-if="winner === 'player'">You won!</h3>
            <h3 v-else>It's a draw!</h3>
            <button @click="startGame">Start New Game</button>
        </section>
    </div>
    ```
    ```js
    // JavaScript
    function getRandomValue(min, max) {
        return Math.floor(Math.random() * (max - min)) + min;
    }

    const app = Vue.createApp({
        data() {
            return {
                playerHealth: 100,
                monsterHealth: 100,
                currentRound: 0,
                winner: null,
            };
        },
        watch: {
            playerHealth(value) {
                if (value <= 0 && this.monsterHealth <= 0) {
                    // A draw
                    this.winner = 'draw';
                } else if (value <= 0) {
                    // Player lost
                    this.winner = 'monster';
                }
            },
            monsterHealth(value) {
                if (value <= 0 && this.playerHealth <= 0) {
                    // A draw
                    this.winner = 'draw';
                } else if (value <= 0) {
                    // Monster lost
                    this.winner = 'player';
                }
            }
        },
        computed: {
            monsterBarStyles() {
                if (this.monsterHealth < 0) return { width: `0%` };
                return { width: `${this.monsterHealth}%` }
            },
            playerBarStyles() {
                if (this.playerHealth < 0) return { width: `0%` };
                return { width: `${this.playerHealth}%` }
            },
            mayUseSpecialAttack() {
                return this.currentRound % 3 !== 0;
            }
        },
        methods: {
            startGame() {
                this.playerHealth = 100;
                this.monsterHealth = 100;
                this.currentRound = 0;
                this.winner = null;
            },
            attackMonster() {
                this.currentRound++;
                const attackValue = getRandomValue(5, 12);
                this.monsterHealth -= attackValue;
                this.attackPlayer();
            },
            attackPlayer() {
                const attackValue = getRandomValue(8, 15);
                this.playerHealth -= attackValue;
            },
            specialAttackMonster() {
                this.currentRound++;
                const attackValue = getRandomValue(10, 25);
                this.monsterHealth -= attackValue;
                this.attackPlayer();
            },
            healPlayer() {
                this.currentRound++;
                const healValue = getRandomValue(8, 20);
                if (this.playerHealth + healValue > 100) {
                    this.playerHealth = 100;
                } else {
                    this.playerHealth += healValue;
                }
                this.attackPlayer();
            },
            surrender() {
                this.winner = 'monster';
            }
        }
    });

    app.mount('#game');
    ```

## Finshing the Core Functionality
1. We add the functionality of "surrender" to assign the monster as the winner when the user clicks on it. 
1. As the actions section is adjacent to the "game over" section, we can use `v-else` directly to show one of the section according to the scenario.
    ```html
    <!-- HTML -->
    <div id="game">
        <section class="container" v-if="winner">
            <h2>Game Over!</h2>
            <h3 v-if="winner === 'monster'">You lost!</h3>
            <h3 v-else-if="winner === 'player'">You won!</h3>
            <h3 v-else>It's a draw!</h3>
            <button @click="startGame">Start New Game</button>
        </section>
        <section id="controls" v-else>
            <button @click="attackMonster">ATTACK</button>
            <button :disabled="mayUseSpecialAttack" @click="specialAttackMonster">SPECIAL ATTACK</button>
            <button @click="healPlayer">HEAL</button>
            <button @click="surrender">SURRENDER</button>
        </section>
    </div>
    ```
    ```js
    // JavaScript
    function getRandomValue(min, max) {
        return Math.floor(Math.random() * (max - min)) + min;
    }

    const app = Vue.createApp({
        data() {
            return {
                playerHealth: 100,
                monsterHealth: 100,
                currentRound: 0,
                winner: null,
            };
        },
        watch: {
            playerHealth(value) {
                if (value <= 0 && this.monsterHealth <= 0) {
                    // A draw
                    this.winner = 'draw';
                } else if (value <= 0) {
                    // Player lost
                    this.winner = 'monster';
                }
            },
            monsterHealth(value) {
                if (value <= 0 && this.playerHealth <= 0) {
                    // A draw
                    this.winner = 'draw';
                } else if (value <= 0) {
                    // Monster lost
                    this.winner = 'player';
                }
            }
        },
        computed: {
            monsterBarStyles() {
                if (this.monsterHealth < 0) return { width: `0%` };
                return { width: `${this.monsterHealth}%` }
            },
            playerBarStyles() {
                if (this.playerHealth < 0) return { width: `0%` };
                return { width: `${this.playerHealth}%` }
            },
            mayUseSpecialAttack() {
                return this.currentRound % 3 !== 0;
            }
        },
        methods: {
            startGame() {
                this.playerHealth = 100;
                this.monsterHealth = 100;
                this.currentRound = 0;
                this.winner = null;
            },
            attackMonster() {
                this.currentRound++;
                const attackValue = getRandomValue(5, 12);
                this.monsterHealth -= attackValue;
                this.attackPlayer();
            },
            attackPlayer() {
                const attackValue = getRandomValue(8, 15);
                this.playerHealth -= attackValue;
            },
            specialAttackMonster() {
                this.currentRound++;
                const attackValue = getRandomValue(10, 25);
                this.monsterHealth -= attackValue;
                this.attackPlayer();
            },
            healPlayer() {
                this.currentRound++;
                const healValue = getRandomValue(8, 20);
                if (this.playerHealth + healValue > 100) {
                    this.playerHealth = 100;
                } else {
                    this.playerHealth += healValue;
                }
                this.attackPlayer();
            },
            surrender() {
                this.winner = 'monster';
            }
        }
    });

    app.mount('#game');
    ```

## Adding a Battle Log
1. We create another array in `data` for `logMessages`. This method will be used in the other methodswhen the player and monster perform any of the actions, such as attacking and healing.
1. Besides, we need to reset the array to empty when the game starts or restarts.
1. To add the message, we can use `.unshift` to add the item as the first item in the array. Though we can also use `.splice(0, 0, logMessage)`, `.unshift` works without any argument.
1. In the log list, we can use `v-for` to render the items. In this case, we use some pre-built CSS styling and use tenary operator to check whether it's the player or monster doing certain action and how much value deals on the action.
1. Final HTML code
    ```html
    <!-- HTML -->
    <div id="game">
        <section id="monster" class="container">
            <h2>Monster Health</h2>
            <div class="healthbar">
                <div class="healthbar__value" :style="monsterBarStyles"></div>
            </div>
        </section>
        <section id="player" class="container">
            <h2>Your Health</h2>
            <div class="healthbar">
                <div class="healthbar__value" :style="playerBarStyles"></div>
            </div>
        </section>
        <section class="container" v-if="winner">
            <h2>Game Over!</h2>
            <h3 v-if="winner === 'monster'">You lost!</h3>
            <h3 v-else-if="winner === 'player'">You won!</h3>
            <h3 v-else>It's a draw!</h3>
            <button @click="startGame">Start New Game</button>
        </section>
        <section id="controls" v-else>
            <button @click="attackMonster">ATTACK</button>
            <button :disabled="mayUseSpecialAttack" @click="specialAttackMonster">SPECIAL ATTACK</button>
            <button @click="healPlayer">HEAL</button>
            <button @click="surrender">SURRENDER</button>
        </section>
        <section id="log" class="container">
            <h2>Battle Log</h2>
            <ul>
                <li v-for="(logMessage) in logMessages">
                    <span
                        :class="{'log--player': logMessage.actionBy === 'player', 'log--monster': logMessage.actionBy === 'monster'}">{{
                        logMessage.actionBy === 'player' ? 'Player' : 'Monster' }}</span>
                    <span v-if="logMessage.actionType === 'heal'"> heals himself for <span class="log--heal"> {{
                            logMessage.actionValue }} </span></span>
                    <span v-else>
                        attacks and deals <span class="log--damage">{{ logMessage.actionValue }}</span>
                    </span>
                </li>
            </ul>
        </section>
    </div>
    ```
1. Final JavaScript code
    ```js
    // JavaScript
    function getRandomValue(min, max) {
        return Math.floor(Math.random() * (max - min)) + min;
    }

    const app = Vue.createApp({
        data() {
            return {
                playerHealth: 100,
                monsterHealth: 100,
                currentRound: 0,
                winner: null,
                logMessages: [],
            };
        },
        watch: {
            playerHealth(value) {
                if (value <= 0 && this.monsterHealth <= 0) {
                    // A draw
                    this.winner = 'draw';
                } else if (value <= 0) {
                    // Player lost
                    this.winner = 'monster';
                }
            },
            monsterHealth(value) {
                if (value <= 0 && this.playerHealth <= 0) {
                    // A draw
                    this.winner = 'draw';
                } else if (value <= 0) {
                    // Monster lost
                    this.winner = 'player';
                }
            }
        },
        computed: {
            monsterBarStyles() {
                if (this.monsterHealth < 0) return { width: `0%` };
                return { width: `${this.monsterHealth}%` }
            },
            playerBarStyles() {
                if (this.playerHealth < 0) return { width: `0%` };
                return { width: `${this.playerHealth}%` }
            },
            mayUseSpecialAttack() {
                return this.currentRound % 3 !== 0;
            }
        },
        methods: {
            startGame() {
                this.playerHealth = 100;
                this.monsterHealth = 100;
                this.currentRound = 0;
                this.winner = null;
                this.logMessages = [];
            },
            attackMonster() {
                this.currentRound++;
                const attackValue = getRandomValue(5, 12);
                this.monsterHealth -= attackValue;
                this.addLogMessage('player', 'attack', attackValue);
                this.attackPlayer();
            },
            attackPlayer() {
                const attackValue = getRandomValue(8, 15);
                this.playerHealth -= attackValue;
                this.addLogMessage('monster', 'attack', attackValue);
            },
            specialAttackMonster() {
                this.currentRound++;
                const attackValue = getRandomValue(10, 25);
                this.monsterHealth -= attackValue;
                this.addLogMessage('player', 'attack', attackValue);
                this.attackPlayer();
            },
            healPlayer() {
                this.currentRound++;
                const healValue = getRandomValue(8, 20);
                if (this.playerHealth + healValue > 100) {
                    this.playerHealth = 100;
                } else {
                    this.playerHealth += healValue;
                }
                this.addLogMessage('player', 'heal', healValue);
                this.attackPlayer();
            },
            surrender() {
                this.winner = 'monster';
            },
            addLogMessage(who, what, value) {
                this.logMessages.unshift({
                    actionBy: who,
                    actionType: what,
                    actionValue: value,
                });
            }
        }
    });

    app.mount('#game');
    ```



# Vue: Behind the Scenes
## An Introduction to Vue's Reactivity
1. Vue is set to track on the data if any of its value is changed.
1. This is acheived by using JavaScript [`proxy`](https://javascript.info/proxy).

## Vue Reactivity: A Deep Dive
1. In vanilla JavaScript, though we declare a variable with value from the other variable, the data wouldn't change because JavaScript is not dynamic that it follows the execution context and thus lock the value when it's declared.
    ```js
    let message = 'Hello';
    let longMessage = message + 'World!';
    console.log(longMessage); // Hello World!

    message = 'Hola';
    console.log(longMessage); // Hello World!
    ```
1. If we use a proxy, we can notice that the object is modifed and the `set` method is trigerred. Besides, the `data` object is modifed by the proxy as well. 
    ```js
    const data = {
        message: 'Hello!',
        longMessage: 'Hello! World!'
    };

    const handler = {
        set(target, key, value) {
            if (key === 'message') {
                target.longMessage = value + 'World';
            }
            target.message = value;
        }
    };

    const proxy = new Proxy(data, handler);

    proxy.message = 'Hello!!!';

    console.log(proxy.longMessage); // Hello!!!World
    ```

## One App vs Multiple Apps
1. Each Vue app doesn't connect to each other by default. Therefore, though we can declare multiple Vue apps in the same JavaScript file, the `data` properties of each app can't be acccess from one of the other. 
    ```html
    <section id="app">
        <p>{{ message }}</p>
    </section>
    <section id="app2">
        <!-- THIS WON'T WORK! <p>{{ message }}</p> -->
        <p>{{ favoriteMeal }}</p>
    </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                message: 'Hello World!'
            }
        }
    });
    app.mount('#app');

    const app2 = Vue.createApp({
        data() {
            return {
                favoriteMeal: 'Pizza'
            }
        }
    })
    app2.mount('#app2');
    ```

## Understanding Templates
1. By using `app.mount` method, we have turned the HTML elements as a Vue template.
1. In addition, we can use `template` (which is a reserved keyword as `data`, `watch`, `computed`, and `methods`) to create template. We can use JavaScript template literal to have multiple lines.
1. Though the feature is avaialble, there's no strong reason to use Vue to create templates in this way.
    ```html
    <!-- HTML -->
    <section id="app">
        <!-- empty and will be injected by Vue -->
    </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        template: `
            <h2>How Vue Works</h2>
            <input type="text" @input="saveInput">
            <button @click="setText">Set Text</button>
            <p>{{ message }}</p>
        `,
        data() {
            return {
                currentUserInput: '',
                message: 'Vue is great!',
            }
        },
        methods: {
            saveInput(event) {
                this.currentUserInput = event.target.value;
            },
            setText() {
                this.message = this.currentUserInput;
            },
        }
    });

    app.mount('#app');
    ```

## Working with Refs
1. We can give a Vue specific attribute `ref` on a HTML element, so Vue can directly access the element as a DOM selector. This feature is similar to [React Reference System](https://reactjs.org/docs/refs-and-the-dom.html), which can also select a HTML element or an instance of React component. We can look up example from [React learning note](https://github.com/allenlin90/programmingLearning/tree/master/javascriptLearning/modernReactWithRedux#using-refs-for-dom-access).
1. Note that we don't need to put `v-bind` or `:` as using `key` on list items.
1. It uses a special syntax with `this.$ref.[name_of_ref]`
    ```html
    <!-- HTML -->
    <section id="app">
        <h2>How Vue Works</h2>
        <input type="text" ref="userText"> <!-- give a ref attribute -->
        <button @click="setText">Set Text</button>
        <p>{{ message }}</p>
    </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                currentUserInput: '',
                message: 'Vue is great!',
            };
        },
        methods: {
            saveInput(event) {
                this.currentUserInput = event.target.value;
            },
            setText() {
                // this.message = this.currentUserInput;
                this.message = this.$refs.userText.value;
                // console.log(this.$refs.userText);
            },
        },
    });

    app.mount('#app');
    ```

## How Vue Updates the DOM
1. Vue component has a "**virtual DOM**" which is a copy of the actual DOM which controlled by JavaScript and stored in memory. This approach is hence improving the performance rather manipulating on the DOM objects directly. 
1. Besides, Vue has its own internal optimization to update its virtual DOM. 
    <img src="images/64-vue_virtual_dom.png">

## Vue App Lifecycle - Theory
1. Vue apps runs and renders instances on the screen in a lifecyle. This is similar to React Apps behavior that we can apply some features or functions at certain stage of the App to work on specific task(s). 
1. When the Vue App starts from `createApp({})`, it goes through the following stages
    1. `beforeCreate()` is when "**before**" the App is fully initialized.
    1. `created()` is when "**after**" the App is fully initialized.
    1. "**Compile template**" - Note that we don't see any thing both the stages above. Vue only knows the data properties before rendering the instances. Besdies, the code will be compiled to be rendered on the screen.
    1. `beforeMount()` is right before when the instances are going to be rendered on the screen.
    1. `mounted()` is when Vue has added all the contents to HTML. 
    1. "**Mounted Vue Instance**" - When all Vue instances are mounted, it stays and listens if there's any changes to the `data`. 
    1. "**Data Changed**" - Vue listens to `data` and its instances. When there's any changes, it trigerrs and starts a new lifecycle.
        1. `beforeUpdate()` is similar to `beforeMount()` when the Vue instance gets updated with its `data` on the screen.
        1. `updated()` is similar to `mounted()` when the Vue instance has updated `data` and been rendered on the screen.
    1. "**Instance Unmounted**" - This triggers when a Vue instance is removed from the screen and simiar to other hooks in the lifecycle, it has both `beforeUnmount()` and `unmounted()`.
        1. `beforeUnmount()`
        1. `unmounted()`
        
    <img src="images/65-vue_instance_lifecycle.png">

## Vue App Lifecycle - Practice
1. Vue instance lifecycle is similar to [React component lifecycle](https://reactjs.org/docs/react-component.html#the-component-lifecycle) and [React Lifecycle Diagram](https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/) which deals with the App in certain stage in the lifecycle.
1. Note that we can use the debugger in developer console in any modern browser to check the order of execution and stop at certain line of code. We can check more information at [Chrome DevTools - Debug JavaScript](https://developer.chrome.com/docs/devtools/javascript/)
    ```html
    <!-- HTML -->
    <section id="app">
        <h2>How Vue Works</h2>
        <input type="text" ref="userText">
        <button @click="setText">Set Text</button>
        <p>{{ message }}</p>
    </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                currentUserInput: '',
                message: 'Vue is great!',
            };
        },
        methods: {
            saveInput(event) {
                this.currentUserInput = event.target.value;
            },
            setText() {
                // this.message = this.currentUserInput;
                this.message = this.$refs.userText.value;
                // console.log(this.$refs.userText);
            },
        },
        beforeCreate() {
            console.log('beforeCreate()');
        },
        created() {
            console.log('created()');
        },
        beforeMount() {
            console.log('beforeMount()');
        },
        mounted() {
            console.log('mounted()');
        },
        beforeUpdate() {
            console.log('beforeUpdate()');
        },
        updated() {
            console.log('updated()');
        },
        beforeUnmount() {
            console.log('beforeUnmount()');
        },
        unmounted() {
            console.log('unmounted()');
        }
    });

    app.mount('#app');

    setTimeout(function () {
        app.unmount('#app');
    }, 3000);
    ```



# Introducing Components
## Understanding the Problem
1. If we inspect the HTML, we can notice that there are 2 items in the list which is a contact to a person.
1. HTML source code
    ```html
    <!-- HTML -->
    <body>
        <header>
            <h1>FriendList</h1>
        </header>
        <section id="app">
            <ul>
                <li>
                    <h2>Manuel Lorenz</h2>
                    <button>Show Details</button>
                    <ul>
                        <li><strong>Phone:</strong> 01234 5678 991</li>
                        <li><strong>Email:</strong> manuel@localhost.com</li>
                    </ul>
                </li>
                <li>
                    <h2>Julie Jones</h2>
                    <button>Show Details</button>
                    <ul>
                        <li><strong>Phone:</strong> 09876 543 221</li>
                        <li><strong>Email:</strong> julie@localhost.com</li>
                    </ul>
                </li>
            </ul>
        </section>
    </body>
    ```
1. As we'd like to render the contact data from Vue rather than hardcode the values in HTML, we can use an array in `data` to store the information.
1. In this case, we can use `v-for` and other attributes introduced in the previous sections such as `:key` and `v-if`.
1. After configuring the basic settings, we can use a state to control whether to show or hide the details of a contact.
1. However, since we have one single state to control and toggle the items, all the list will show or hide its own details when any of the contact is clicked.
1. One way to work around is to create multiple states to listen to toggle events that each contact in the list has its own state of show/hide the details.
1. However, this isn't realistic that if the number of items in the array is not fixed, we don't know exactly how many states should we declare.
1. Therefore, we can use Vue component to solve the problem. 
    ```html
    <!-- HTML -->
    <section id="app">
        <ul>
            <li v-for="friend in friends" :key="friend.id">
                <h2>{{ friend.name }}</h2>
                <button @click="toggleDetails">Show Details</button>
                <ul v-if="detailsAreVisible">
                    <li><strong>Phone:</strong> {{ friend.phone }}</li>
                    <li><strong>Email:</strong> {{ friend.email }}</li>
                </ul>
            </li>
        </ul>
    </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                friends: [
                    {
                        id: 'manuel',
                        name: 'Manuael Lorenz',
                        phone: '01234 5678 991',
                        email: 'manuel@localhost.com'
                    },
                    {
                        id: 'julie',
                        name: 'Julie Jones',
                        phone: '+09876 543 221',
                        email: 'julie@localhost.com'
                    },
                ],
                detailsAreVisible: false,
            };
        },
        methods: {
            toggleDetails() {
                this.detailsAreVisible = !this.detailsAreVisible;
            }
        }
    });

    app.mount('#app');
    ```

## Introducing Components
1. To create a Vue component, we can simply use `app.component([compoennt-name])` and give the name to declare as the argument. Note that we may follow the convention to have 2 words naming pattern and use a dash `-` to separate the words. This is to prevent clashing with the default HTML elements such as `div`, `section`, and `header`.
1. The `.component()` method takes 2 arguments.
    1. The name of the component, which we then can use it as a HTML element in a Vue app. 
    1. The configuration to the component which is exactly the same as a regular Vue app.
1. Note that the Vue component only works in the Vue app, and we don't need to `app.mount()` it as the main Vue app. 
1. In the component, we do need to use `template` which is introduced in [previous section](https://github.com/allenlin90/programmingLearning/tree/master/javascriptLearning/vueTheCompleteGuide#understanding-templates).
1. Each componet is individual and not connected. it works as a "**mini**" app in the Vue app.
1. This feature is very similar to use JSX for [React Components](https://github.com/allenlin90/programmingLearning/tree/master/javascriptLearning/modernReactWithRedux#strucuturing-apps-with-class-based-components) in a React App. 
    ```html
    <!-- HTML -->
    <section id="app">
        <ul>
            <!-- use Vue component in a Vue connected app -->
            <friend-contact></friend-contact>
            <friend-contact></friend-contact>
        </ul>
    </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        /*
            Vue App...
        */
    });

    app.component(`friend-contact`, {
        template: `
        <li>
            <h2>{{ friend.name }}</h2>
            <button @click="toggleDetails">Show Details</button>
            <ul v-if="detailsAreVisible">
                <li><strong>Phone:</strong> {{ friend.phone }}</li>
                <li><strong>Email:</strong> {{ friend.email }}</li>
            </ul>
        </li>
        `,
        data() {
            return {
                detailsAreVisible: false,
                friend: {
                    id: 'manuel',
                    name: 'Manuael Lorenz',
                    phone: '01234 5678 991',
                    email: 'manuel@localhost.com'
                }
            }
        },
        methods: {
            toggleDetails() {
                this.detailsAreVisible = !this.detailsAreVisible;
            }
        }
    });

    app.mount('#app'); // this is not required for Vue component
    ```

## The Why: Building Complex User Interfaces With Components
1. This approach is very similar to React Apps that it has a main control over multiple reusable components in the app and connect them with `props` for data and properties to control over the specific features and behaviors of each component. 



# Moving to a Better Development SEtup & Workflow with the Vue CLI
## Why We Need A Development Server
1. If we don't have a demo server, we can't mock up `http` or `https` connnection protocol. We just open the file with `file` protocol.
1. Some (modern JavaScript or Browser feateurs will not work).
1. We'd like to simulate the environment hosting a website in regular server.

## WHy We Want A Better Developer Experience
1. Without a configured local server, we need to reload the page after every change. 
1. We can use other tools such as auto-complete when using frequently used terms or structure.
1. As the Vue app goes bigger, we may separate the JavaScript file into different files. Without the tools, we have to use `script` tag in the main HTML to import all the JavaScript file.
1. For example, we can separate the code for manipulating UIs and calculating the data and properties.
1. In addition, we can use some modern JavaScript features such as module system with import/export.

## Installing & Using the Vue CLI
1. We firstly use `npm` to install `@vue/cli` in the global environment. Note that we may need to use `sudo` in linux or MacOS system, while we can simply use `npm install @vue/cli -g` on windows command prompt directly.
1. After installing the required files, we can use `vue create [project-name]`. Note that we don't have any space to name a project in convention to prevent complexity to access a directory in CLI. This process is similar to use `npx create-react-app [project_name]` to create a React App, which also requires its own package by using [`npm install -g create-react-app`](https://github.com/allenlin90/programmingLearning/tree/master/javascriptLearning/modernReactWithRedux#generating-a-react-project).
1. Note that we can use simply use the default configurations for Vue3 or manually configure some of the setting if it requires.
1. When the project folder is created, we can use `cd` to change directory and run `npm run serve` to start the developing environment that we can go `http://localhost:8080/` to check Vue project control panel. This is similar to use `npm start` after creating a React project that we can access it at `http://localhost:3000/` by default.

## Inspecting the Created Project
1. This section is to introduce the directory and file structure when creating a Vue app.
1. Similar to React App, there's only a single HTML file in `public` folder which has a `<div id="app">` that is similar to `<div id="root">` of a React app by default. 
1. We can also check `package.json` for the npm commands and depenecies used in the project.
1. Note that by creating a project with CLI and so as React app, we can `import` the required dependencies to create the app rather than using CDN in the HTML file.

## Inspecting the Vue Code & ".vue" Files
1. We have a `main.js` and `App.vue` file in `src` directory, which is similar to React that uses `index.js` which is the main control to connect React code to the HTML file. `ReactDOM.render(<App />, document.querySelector('#root'));`
    ```js
    // src/main.js
    import {createApp} from 'vue';
    import App from './App.vue';

    createApp(App).mount('#app');
    ```
1. In `App.vue`, we can notice that there are 3 sections `template`, `script`, and `style`. This is a specific Vue App that Vue CLI allow developers to have the strcuture.
1. In this app structure, we can use a specific Vue build workflow to build the app.
1. The `App.vue` follows Vue specific structure that we can use both "**next-gen**" and "**Vue-specific syntax and features**".
1. We then "**build**" the code by compiling Vue specific code to standard JavaScript which browser understands.
1. While we use `npm run serve` is to have a dynamic compiling process that Vue CLI will keep watching the code and use a optimzed compiling process to render the components in real-time.
    ```html
    <!-- src/App.vue -->
    <template>
        <img alt="Vue logo" src="./assets/logo.png">
        <HelloWorld msg="Welcome to Your Vue.js App"/>
    </template>

    <script>
    import HelloWorld from './components/HelloWorld.vue'

    export default {
        name: 'App',
        components: {
            HelloWorld
        }
    }
    </script>

    <style>
    #app {
        font-family: Avenir, Helvetica, Arial, sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        text-align: center;
        color: #2c3e50;
        margin-top: 60px;
    }
    </style>
    ```

## Adding the "Vetur" Extension to VS Code
1. [Vetur](https://marketplace.visualstudio.com/items?itemName=octref.vetur) is a very useful extension in VS Code that helps developers to work on Vue apps. It is highly recommended to install this extension for better developing environment.

## More on ".vue" Files
1. In the previous section, we can use `template` property in the Vue app to create a pre-built Vue component. We can use `.vue` suffix to create a Vue component in a separate file and use JavaScript module system to "**import**" the component.
    ```js
    // JavaScript
    const app = Vue.createApp({
        template: `
        <div>
            Hello World!
        </div>
        `,
        data(){
            return {

            }
        },
        watch: {},
        computed: {},
        methods: {},
    });

    app.mount('#app');
    ```
    ```html
    <!-- App.vue -->
    <template>
        <div>
            Hello World!
        </div>
    </template>
    ```
1. In `src` directory, we have `assests` where we can store our media files such as iamges and `components` to store the Vue components.

## A New Vue Project
1. This section is to have the initial setup for a Vue project. We can just use `vue create [project_name]` and remove all the files in `src` besides `main.js`. 
1. After all, we run `npm run serve` to start the developing server. 

## Creating a Basic Vue App
1. In convention, we create a main Vue controller as `App.vue`.
1. We firstly create a new object that's similar to the object that we pass to `Vue.createApp()`, which has exactly the same structure for the instance.
1. After configuring the object, we can use `export default` to export the object and use it in the other JavaScript file. 
    ```html
    <!-- src/App.vue -->
    <template></template>

    <script>
    export default {
        data() {
            return {
            friends: [
                {
                    id: "manuel",
                    name: "Manuel Lorenz",
                    phone: "0123 45678 90",
                    email: "manuel@localhost.com",
                },
                {
                    id: "julie",
                    name: "Julie Jones",
                    phone: "0987 654421 21",
                    email: "julie@localhost.com",
                },
            ],
            };
        },
    };
    </script>
    ```
1. We then can use JavaScript module system to import the object from `App.vue` to `main.js`. In this case, we can just use the default export and import the object without parenthesis.
    ```js
    // src/main.js
    import {createApp} from 'vue';
    import App from './App.vue';
    
    createApp(App).mount('#app');
    ```
1. To add HTML elements, we can use the `template` tag directly in the `App.vue` rather than adding elements in the HTML file directly.
    ```html
    <!-- src/App.vue -->
    <template>
        <h2>My Friends</h2>
        <section>
            <ul>
                <li></li>
            </ul>
        </section>
    </template>
    ```

## Adding a Component
1. To manage Vue components, we can create a `components` directory in `src`.
1. In convention, we can name the files in "**PascalCase**", "**camelCase**", or "**kebap-case**".
    ```html
    <!-- src/components/FriendContact.vue -->
    <template>
        <li>
            <h2>{{ friend.name }}</h2>
            <button @click="toggleDetails">Show Details</button>
            <ul v-if="detailsAreVisible">
                <li><strong>Phone: </strong>{{ friend.phone }}</li>
                <li><strong>Email: </strong>{{ friend.email }}</li>
            </ul>
        </li>
    </template>

    <script>
    export default {
        data() {
            return {
            detailsAreVisible: false,
            friend: {
                    id: "manuel",
                    name: "Manuel Lorenz",
                    phone: "0123 45678 90",
                    email: "manuel@localhost.com",
                },
            };
        },
        methods: {
            toggleDetails() {
                this.detailsAreVisible = !this.detailsAreVisible;
            },
        },
    };
    </script>
    ```
1. We then import the component to `main.js` and create a component and give it a name.
    ```js
    // src/main.js
    import { createApp } from 'vue';
    import App from './App.vue';
    import FriendContact from './components/FriendContact.vue'; // import the component

    const app = createApp(App);

    app.component('friend-contact', FriendContact); // name the component in kebap-case to prevent clash to HTML tags

    app.mount('#app');
    ```
1. We then can use the component in `App.vue`
    ```html
    <!-- src/App.vue -->
    <template>
        <h2>My Friends</h2>
        <section>
            <ul>
                <friend-contact></friend-contact>
                <friend-contact></friend-contact>
            </ul>
        </section>
    </template>
    ```
    <img src="images/84-add_component_to_app_vue.png">

## Adding Styling
1. In each Vue component, including `App.vue`, we can have `style` tag as in HTML and put the CSS code there to style the componet. 
    ```html
    <!-- App.vue -->
    <template>
        <h2>My Friends</h2>
        <section>
            <header><h1>My Friends</h1></header>
            <ul>
                <friend-contact></friend-contact>
                <friend-contact></friend-contact>
            </ul>
        </section>
    </template>

    <script>
    export default {
    data() {
        return {
            friends: [
                {
                    id: "manuel",
                    name: "Manuel Lorenz",
                    phone: "0123 45678 90",
                    email: "manuel@localhost.com",
                },
                {
                    id: "julie",
                    name: "Julie Jones",
                    phone: "0987 654421 21",
                    email: "julie@localhost.com",
                },
            ],
        };
    },
    };
    </script>

    <style>
    @import url('https://fonts.googleapis.com/css2?family=Jost&display=swap');
    * {
        box-sizing: border-box;
    }

    html {
        font-family: "Jost", sans-serif;
    }

    body {
        margin: 0;
    }

    header {
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.26);
        margin: 3rem auto;
        border-radius: 10px;
        padding: 1rem;
        background-color: #58004d;
        color: white;
        text-align: center;
        width: 90%;
        max-width: 40rem;
    }

    #app ul {
        margin: 0;
        padding: 0;
        list-style: none;
    }

    #app li {
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.26);
        margin: 1rem auto;
        border-radius: 10px;
        padding: 1rem;
        text-align: center;
        width: 90%;
        max-width: 40rem;
    }

    #app h2 {
        font-size: 2rem;
        border-bottom: 4px solid #ccc;
        color: #58004d;
        margin: 0 0 1rem 0;
    }

    #app button {
        font: inherit;
        cursor: pointer;
        border: 1px solid #ff0077;
        background-color: #ff0077;
        color: white;
        padding: 0.05rem 1rem;
        box-shadow: 1px 1px 2px rgba(0, 0, 0, 0.26);
    }

    #app button:hover,
    #app button:active {
        background-color: #ec3169;
        border-color: #ec3169;
        box-shadow: 1px 1px 4px rgba(0, 0, 0, 0.26);
    }
    </style>
    ```



# Component Communication
## Introducing "Props" (Parent => Child Communication)
1. To enable components to communicate, we can use `props` property which is a reserved keyword as `data` and `methods` to get the data passing from the parent to child components. The idea is exactly the same as [React components](https://github.com/allenlin90/programmingLearning/tree/master/javascriptLearning/modernReactWithRedux#communicating-with-props).
1. So as it does in React, the HTML attribute should be in `kebap-case`, while for JavaScrfipt object property key, we should use `camelCase`. `kebap-case` isn't a legal naming style for JavaScript properties.
    ```html
    <!-- src/App.vue -->
    <template>
    <h2>My Friends</h2>
        <section>
            <header><h1>My Friends</h1></header>
            <ul>
            <friend-contact
                name="Manuel Lorenz"
                phone-number="0123 45678 90"
                email-address="manuel@localhost.com"
            ></friend-contact>
            <friend-contact
                name="Julie Jones"
                phone-number="0123 45678 90"
                email-address="julie@localhost.com"
            ></friend-contact>
            </ul>
        </section>
    </template>
    ```
1. In this case, we can use an array to catch the passing data from the parent in `FriendContact` component.
1. We then case access the passed values as the properties in `data` through `this` or its name in the HTML template.
    ```html
    <!-- src/components/FriendContact.vue -->
    <template>
        <li>
            <h2>{{ name }}</h2>
            <button @click="toggleDetails">
                {{ detailsAreVisible ? "Hide" : "Show" }} Details
            </button>
            <ul v-if="detailsAreVisible">
                <li><strong>Phone: </strong>{{ phoneNumber }}</li>
                <li><strong>Email: </strong>{{ emailAddress }}</li>
            </ul>
        </li>
    </template>

    <script>
    export default {
        props: ["name", "phoneNumber", "emailAddress"],
        data() {
            return {
                detailsAreVisible: false,
                friend: {
                    id: "manuel",
                    name: "Manuel Lorenz",
                    phone: "0123 45678 90",
                    email: "manuel@localhost.com",
                },
            };
        },
        methods: {
            toggleDetails() {
                this.detailsAreVisible = !this.detailsAreVisible;
            },
        },
    };
    </script>
    ```

## Prop Behavior & Changing Props
1. From the previous section, we can notice that `App.vue` acts as the "parent" component and `FriendContact` is the "child" component.
1. Note that we shouldn't mutate (change) the `props` to follow [one-way data flow](https://vuejs.org/v2/guide/components-props.html#One-Way-Data-Flow). The values should be only changed from where it was passed to the component. For example, we have another property passed from `App.vue` to `FriendContact.vue`.
    ```html
    <!-- src/App.vue -->
    <template>
        <h2>My Friends</h2>
        <section>
            <header><h1>My Friends</h1></header>
            <ul>
                <friend-contact
                    name="Manuel Lorenz"
                    phone-number="0123 45678 90"
                    email-address="manuel@localhost.com"
                    is-favorite="1"
                ></friend-contact>
                <friend-contact
                    name="Julie Jones"
                    phone-number="0123 45678 90"
                    email-address="julie@localhost.com"
                    is-favorite="0"
                ></friend-contact>
            </ul>
        </section>
    </template>
    ```
    ```html
    <!-- src/components/FriendContact.vue -->
    <template>
        <li>
            <h2>{{ name }}</h2>
            <button @click="toggleDetails">
                {{ detailsAreVisible ? "Hide" : "Show" }} Details
            </button>
            <button @click="toggleFavorite">Toggle Favorite</button>
            <ul v-if="detailsAreVisible">
                <li><strong>Phone: </strong>{{ phoneNumber }}</li>
                <li><strong>Email: </strong>{{ emailAddress }}</li>
            </ul>
        </li>
    </template>

    <script>
    export default {
        props: ["name", "phoneNumber", "emailAddress", "isFavorite"],
        data() {
            return {
                detailsAreVisible: false,
                friend: {
                    id: "manuel",
                    name: "Manuel Lorenz",
                    phone: "0123 45678 90",
                    email: "manuel@localhost.com",
                },
            };
        },
        methods: {
            toggleDetails() {
                this.detailsAreVisible = !this.detailsAreVisible;
            },
            toggleFavorite() {
                if (this.isFavorite === "1") {
                    this.isFavorite = "0";
                } else {
                    this.isFavorite = "1";
                }
            },
        },
    };
    </script>
    ```
    <img src="images/90-unit_data_flow.png">
1. There are 2 ways that we can modify the props.
    1. We can modify the data in the parent component (which is `App.vue` in this case) and pass the updated value to the child component. 
    1. We can take the props as the initial data for a data property in the child component and has a separated state to control it.
        ```html
        <!-- src/components/FriendContact.vue -->
        <template>
            <li>
                <h2>{{ name }} {{ friendIsFavorite === "1" ? "(Favorite)" : "" }}</h2>
                <button @click="toggleFavorite">Toggle Favorite</button>
                <button @click="toggleDetails">
                    {{ detailsAreVisible ? "Hide" : "Show" }} Details
                </button>
                <ul v-if="detailsAreVisible">
                    <li><strong>Phone: </strong>{{ phoneNumber }}</li>
                    <li><strong>Email: </strong>{{ emailAddress }}</li>
                </ul>
            </li>
        </template>

        <script>
        export default {
            props: ["name", "phoneNumber", "emailAddress", "isFavorite"],
            data() {
                return {
                    detailsAreVisible: false,
                    friend: {
                        id: "manuel",
                        name: "Manuel Lorenz",
                        phone: "0123 45678 90",
                        email: "manuel@localhost.com",
                    },
                    friendIsFavorite: this.isFavorite,
                };
            },
            methods: {
                toggleDetails() {
                    this.detailsAreVisible = !this.detailsAreVisible;
                },
                toggleFavorite() {
                    if (this.friendIsFavorite === "1") {
                        this.friendIsFavorite = "0";
                    } else {
                        this.friendIsFavorite = "1";
                    }
                },
            },
        };
        </script>
        ```

## Validating Props
1. The `props` data can be complicated, so we would like to [validate the data](https://vuejs.org/v2/guide/components-props.html#Prop-Validation) when we work in larger projects with other developers. 
1. We can have `type` to check the type of the data value such as `String`, `Number`, and `Boolean`; `required` to check if the prop is required to pass to the component; and `default` to have a default value if the value is not given. Note that `default` can be a function (method) to give a calculated value. 
1. We can also use `validator` which takes only function to check if the prop is valid. The validator function must return a Boolean value (`true`/`false`).
    ```html
    <!-- src/components/FriendContact.vue -->
    <script>
    export default {
        props: {
            name: {
                type: String,
                required: true,
            },
            phoneNumber: {
                type: String,
                requried: true,
            },
            emailAddress: {
                type: String,
                requried: true,
            },
            isFavorite: {
                type: String,
                requried: false,
                default: "0",
                validator: function (value) {
                    return value === "1" || value === "0";
                },
            },
        },
        data() {
            return {
                detailsAreVisible: false,
                friend: {
                    id: "manuel",
                    name: "Manuel Lorenz",
                    phone: "0123 45678 90",
                    email: "manuel@localhost.com",
                },
                friendIsFavorite: this.isFavorite,
            };
        },
        methods: {
            toggleDetails() {
                this.detailsAreVisible = !this.detailsAreVisible;
            },
            toggleFavorite() {
                if (this.friendIsFavorite === "1") {
                    this.friendIsFavorite = "0";
                } else {
                    this.friendIsFavorite = "1";
                }
            },
        },
    };
    </script>
    ```
1. Note that `props` are validated before a component instance is created, so instance properties (e.g. `data`, `computed`, etc) will not be available inside `default` or validator functions.

## Working with Dynamic Props Values
1. To pass a boolean value through `props`, we can use `v-bind` or its shorthand `:` on the HTML attribute. Note that a regular HTML attribute is always a text (`String`).
1. Besides passing props one by one, we can use `v-for` and the variable to create a dynamic component as a list.
    ```html
    <!-- src/App.vue -->
    <template>
        <h2>My Friends</h2>
        <section>
            <header>
                <h1>My Friends</h1>
            </header>
            <ul>
                <friend-contact
                    v-for="friend in friends"
                    :key="friend.id"
                    :name="friend.name"
                    :phone-number="friend.phone"
                    :email-address="friend.email"
                    :is-favorite="true"
                ></friend-contact>
            </ul>
        </section>
    </template>
    ```
1. We then can revise the structure in `FriendContact` component for the new props.
    ```html
    <!-- src/components/FriendContact.vue -->
    <template>
        <li>
            <h2>{{ name }} {{ friendIsFavorite ? "(Favorite)" : "" }}</h2>
            <button @click="toggleFavorite">Toggle Favorite</button>
            <button @click="toggleDetails">
                {{ detailsAreVisible ? "Hide" : "Show" }} Details
            </button>
            <ul v-if="detailsAreVisible">
                <li><strong>Phone: </strong>{{ phoneNumber }}</li>
                <li><strong>Email: </strong>{{ emailAddress }}</li>
            </ul>
        </li>
    </template>

    <script>
    export default {
        // props: ["name", "phoneNumber", "emailAddress", "isFavorite"],
        props: {
            name: {
                type: String,
                required: true,
            },
            phoneNumber: {
                type: String,
                requried: true,
            },
            emailAddress: {
                type: String,
                requried: true,
            },
            isFavorite: {
                type: Boolean,
                requried: false,
                default: false,
                // validator: function (value) {
                //     return value === "1" || value === "0";
                // },
            },
        },
        data() {
            return {
                detailsAreVisible: false,
                friendIsFavorite: this.isFavorite,
            };
        },
        methods: {
            toggleDetails() {
                this.detailsAreVisible = !this.detailsAreVisible;
            },
            toggleFavorite() {
                this.friendIsFavorite = !this.friendIsFavorite;
            },
        },
    };
    </script>
    ```

## Emitting Custom Events (Child => Parent Communication)
1. In this friend list app, `is-favorite` should not be given as a arbitrary value but as a property of a `friend` object. Therefore, we give another `isFavorite` property to a friend object. 
1. In addition, if the data is fetched and stored in a database that if the user toggle the "favorite" button, we should send the data back to the server to store the preference that the user has made. Therefore, rather than just passing the props from parent to child compoennt, we should be able to send the data back from child to the parent as well. 
1. In Vue, we can use a prebuilt method `$emit()`, which is simialar to `$refs`, in the child component. Therefore, the parent component can "**listen**" to the event sending from the child component. The 1st argument is the event name that the parent can "catch". 
1. We can pass a 2nd arguement to the `$emit()` method, so the "**listener**" in the parent component can catch the value and work on other features.
1. In this case, we can pass the `id` of the `friend` object to the child and pass it back when the user clicks on the "Toggle Favorite" button to triger the listener.
1. In `App.vue`, we can put a listener matching the event name in on the child component and use its own `methods` to handle the data. 
1. In this case, we can use `.find` array method to refer to the `friend` object and toggle its `isFavorite` property. 
1. Though the concept is very similar to React app, React app passes the method directly from parent to the child to allow the child component toggles the property of a data in the parent. However, both ways can be workaround in both frameworks.
    ```html
    <!-- src/components/FriendContact.vue -->
    <template>
        <li>
            <!-- change the detector in ternary operator to isFavorite -->
            <h2>{{ name }} {{ isFavorite ? "(Favorite)" : "" }}</h2>
            <button @click="toggleFavorite">Toggle Favorite</button>
            <button @click="toggleDetails">
                {{ detailsAreVisible ? "Hide" : "Show" }} Details
            </button>
            <ul v-if="detailsAreVisible">
                <li><strong>Phone: </strong>{{ phoneNumber }}</li>
                <li><strong>Email: </strong>{{ emailAddress }}</li>
            </ul>
        </li>
    </template>

    <script>
    export default {
        props: {
            id: { // get this from parent component
                type: String,
                required: true,
            },
            name: {
                type: String,
                required: true,
            },
            phoneNumber: {
                type: String,
                requried: true,
            },
            emailAddress: {
                type: String,
                requried: true,
            },
            isFavorite: {
                type: Boolean,
                requried: false,
                default: false,
            },
        },
        data() {
            return {
                detailsAreVisible: false,
                // remove friendIsFavorite prop
            };
        },
        methods: {
            toggleDetails() {
                this.detailsAreVisible = !this.detailsAreVisible;
            },
            toggleFavorite() {
                this.$emit("toggle-favorite", this.id);
                // the 1st argument is the event name
                // send the id back to notice the parent                
            },
        },
    };
    </script>
    ```
    ```html
    <!-- src/App.vue -->
        <template>
        <h2>My Friends</h2>
        <section>
            <header>
                <h1>My Friends</h1>
            </header>
            <ul>
                <!-- pass id to child component -->
                <friend-contact
                    v-for="friend in friends"
                    :key="friend.id"
                    :id="friend.id" 
                    :name="friend.name"
                    :phone-number="friend.phone"
                    :email-address="friend.email"
                    :is-favorite="friend.isFavorite"
                    @toggle-favorite="toggleFavoriteStatus"
                ></friend-contact>
                <!-- add a listener to handle the emit event and call a method -->
            </ul>
        </section>
    </template>

    <script>
    export default {
        data() {
            return {
                friends: [
                    {
                        id: "manuel",
                        name: "Manuel Lorenz",
                        phone: "0123 45678 90",
                        email: "manuel@localhost.com",
                        isFavorite: true,
                    },
                    {
                        id: "julie",
                        name: "Julie Jones",
                        phone: "0987 654421 21",
                        email: "julie@localhost.com",
                        isFavorite: false,
                    },
                ],
            };
        },
        methods: {
            toggleFavoriteStatus(friendId) {
                const identifiedFriend = this.friends.find( // use .find method to locate the friend object has the same 'id'
                    (friend) => friend.id === friendId
                );
                // toggle 'isFavorite' property to the opposite
                identifiedFriend.isFavorite = !identifiedFriend.isFavorite;
            },
        },
    };
    </script>
    ```

## Defining & Validating Custom Events
1. In a Vue component, we can use another property `emits` (simialr to `porps` and `data`), which we use an `array` to list all the `emits` in the component. It can be easier to manage when the app is developed by multiple developers.
1. In addition, we can make `emits` an object and have more configuration on it. We can also [validate the value](https://v3.vuejs.org/guide/component-custom-events.html#validate-emitted-events) that the `emits` function returns. Note that the validator can only return a Boolean value.
    ```js
    const app = Vue.createApp({
        props: {},
        emits: ['event-handler'],
        emits: {
            'event-handler': function(id) {
                if (id) true;
                return false;
            }
        }
        data(){},
        methods: {}
    });
    ```

## Prop / Event Fallthrough & Binding All Props
1. [Prop Fallthrough](https://v3.vuejs.org/guide/component-attrs.html#non-prop-attributes) - You can set props (and listen to events) on a component which you haven't registered inside of that component. 
1. Besides passing each property from parent to child component, we can use `v-bind`  to send all the properties of an object to the child. Note that we can't use it in `v-for` and can only use this feature when the data property is an JavaScript object.
1. Note that we should be careful and avoid naming clashes. For example, in the following component, we should avoid using `name` in the `company` object as it may overwrite `name` from a `friend`. 
1. Since it's a shorthand, we can't use `:` column directly, as it requries a attribute name, so the syntax is `v-bind="Object"`
    ```html
    <!-- App.vue -->
    <template>
        <h2>My Friends</h2>
        <section>
            <header>
                <h1>My Friends</h1>
            </header>
            <ul>
                <friend-contact
                    v-for="friend in friends"
                    :key="friend.id"
                    :id="friend.id"
                    :name="friend.name"
                    :phone-number="friend.phone"
                    :email-address="friend.email"
                    :is-favorite="friend.isFavorite"
                    v-bind="company"
                    @toggle-favorite="toggleFavoriteStatus"
                ></friend-contact>
            </ul>
        </section>
    </template>

    <script>
    export default {
        data() {
            return {
                friends: [
                    {
                        id: "manuel",
                        name: "Manuel Lorenz",
                        phone: "0123 45678 90",
                        email: "manuel@localhost.com",
                        isFavorite: true,
                    },
                    {
                        id: "julie",
                        name: "Julie Jones",
                        phone: "0987 654421 21",
                        email: "julie@localhost.com",
                        isFavorite: false,
                    },
                ],
                company: {
                    country: 'TH'
                }
            };
        },
        methods: {
            toggleFavoriteStatus(friendId) {
                const identifiedFriend = this.friends.find(
                    (friend) => friend.id === friendId
                );
                identifiedFriend.isFavorite = !identifiedFriend.isFavorite;
            },
        },
    };
    </script>
    ```
    ```html
    <!-- components/FriendContact.vue -->
    <template>
        <li>
            <!-- this country is passed from the parent component -->
            <h2>{{ country }}</h2>
        </li>
    </template>
    ```

## Demo: Adding Components & Connecting Them
1. In this section, we'd like to have a form to allow users to create a new entry for the friend list. Therefore, we create a new component `NewFriend.vue`.
1. The following the code from practice to make the component fulfill the desirable feature to take user inputs. The main problem from the practice is forget to use data binding to store the input values in the `stata` by using `v-bind` or `v-model`. Therefore, `data` property is not used in this case.
1. Besides, users input values in the inputs tags are fetched with regular JavaScript DOM which may not be the optimized way to retrieve data and cause the code looking tedious. However, I chose to create the friend contact object in the component before sending back to `App.vue`.  
    ```html
    <!-- Vue component in practice -->
    <template>
        <section>
            <form action="" @submit.prevent="createFriend">
                <label for="create_firstname">First Name</label>
                <input
                    type="text"
                    name="firstname"
                    id="create_firstname"
                    required
                />
                <label for="create_lastname">Last Name</label>
                <input type="text" name="lastname" id="create_lastname" required />
                <label for="create_phone">Phone Number</label>
                <input type="text" name="phone" id="create_phone" required />
                <label for="create_email">Email</label>
                <input type="email" name="email" id="create_email" required />
                <button>Create</button>
            </form>
        </section>
    </template>

    <script>
    export default {
        emits: ["create-new-friend"],
        data() {
            return {
                firstname: "",
                lastname: "",
                phone: "",
                email: "",
                isFavorite: false,
            };
        },
        methods: {
            createFriend(event) {
                event.preventDefault();
                const formDOM = event.target;
                const user = [...formDOM.querySelectorAll("input")].reduce(
                    (friend, input) => {
                        friend[input.name] = input.value;
                        input.value = "";
                        return friend;
                    },
                    {}
                );
                const friend = {
                    id: user.firstname.toLowerCase(),
                    name: user.firstname + " " + user.lastname,
                    phone: user.phone,
                    email: user.email,
                    isFavorite: false,
                };
                this.$emit("create-new-friend", friend);
            },
        },
    };
    </script>

    <style scoped>
    section {
        text-align: center;
        width: 90%;
        max-width: 40rem;
        margin: 2rem auto;
    }

    form {
        margin: 0 auto;
        padding: 1rem;
        display: grid;
        grid-template-columns: max-content 1fr;
        grid-gap: 1rem;
    }

    label {
        justify-self: start;
    }

    button {
        grid-column: 1 / 3;
        justify-self: center;
    }
    </style>
    ```
    ```html
    <!-- App.vue -->
    <template>
        <h2>My Friends</h2>
        <section>
            <header>
                <h1>My Friends</h1>
            </header>
            <new-friend @create-new-friend="createANewFriend"></new-friend>
        </section>
    </template>

    <script>
    export default {
        data() {
            return {
                friends: [
                    {
                        id: "manuel",
                        name: "Manuel Lorenz",
                        phone: "0123 45678 90",
                        email: "manuel@localhost.com",
                        isFavorite: true,
                    },
                    {
                        id: "julie",
                        name: "Julie Jones",
                        phone: "0987 654421 21",
                        email: "julie@localhost.com",
                        isFavorite: false,
                    },
                ],
            };
        },
        methods: {
            toggleFavoriteStatus(friendId) {
                const identifiedFriend = this.friends.find(
                    (friend) => friend.id === friendId
                );
                identifiedFriend.isFavorite = !identifiedFriend.isFavorite;
            },
            createANewFriend(friend) {
                this.friends.push(friend);
            },
        },
    };
    </script>
    ```
1. Solutions from the lecture.
    ```html
    <!-- src/components/NewFriend.vue -->
    <template>
        <form action="" @submit.prevent="submitData">
            <div>
                <label for="">Name</label>
                <input type="text" v-model="enteredName">
            </div>
            <div>
                <label for="">Phone</label>
                <input type="tel" v-model="enteredPhone">
            </div>
            <div>
                <label for="">E-mail</label>
                <input type="email" v-model="enteredEmail">
            </div>
            <div>
                <button>Add Contact</button>
            </div>
        </form>
    </template>

    <script>
    export default {
        emits: ['add-contact'],
        data() {
            return {
                enteredName: '',
                enteredPhone: '',
                enteredEmail: '',
            }
        },
        methods: {
            submitData() {
                this.$emit('add-contact', this.enteredName, this.enteredPhone, this.enteredEmail);
            }
        }
    };
    </script>
    ```
    ```html
    <!-- App.vue -->
    <template>
        <h2>My Friends</h2>
        <section>
            <header>
                <h1>My Friends</h1>
            </header>
            <new-friend @add-contact="addContact"></new-friend>
            <ul>
                <friend-contact
                    v-for="friend in friends"
                    :key="friend.id"
                    :id="friend.id"
                    :name="friend.name"
                    :phone-number="friend.phone"
                    :email-address="friend.email"
                    :is-favorite="friend.isFavorite"
                    @toggle-favorite="toggleFavoriteStatus"
                ></friend-contact>
            </ul>
        </section>
    </template>

    <script>
    export default {
        data() {
            return {
                friends: [
                    {
                        id: "manuel",
                        name: "Manuel Lorenz",
                        phone: "0123 45678 90",
                        email: "manuel@localhost.com",
                        isFavorite: true,
                    },
                    {
                        id: "julie",
                        name: "Julie Jones",
                        phone: "0987 654421 21",
                        email: "julie@localhost.com",
                        isFavorite: false,
                    },
                ],
            };
        },
        methods: {
            toggleFavoriteStatus(friendId) {
                const identifiedFriend = this.friends.find(
                    (friend) => friend.id === friendId
                );
                identifiedFriend.isFavorite = !identifiedFriend.isFavorite;
            },
            addContact(name, phone, email) {
                const newFriendContact = {
                    id: new Date().toISOString(),
                    name,
                    phone,
                    email,
                    isFavorite: false
                };
                this.friends.push(newFriendContact);
            }
        },
    };
    </script>
    ```

## Demo: Adding More Component Communication
1. In this case, we add another button to allow users to "delete" a friend from the list. 
1. We firstly create a `button` and give it another `emits` to send data back to `App.vue` where the friend list stores. Note that though we can use another method to send the `emit` back, we can delcare it directly in the HTML template.
1. After sending the data back to `App.vue`, we can use a method with [`Array.filter()`](https://www.w3schools.com/jsref/jsref_filter.asp) to remove the friend from the list by its id. Note that `.filter` method only keeps items in the array that matches a given condition. 
    ```html
    <!-- src/components/FriendContact -->
    <template>
        <li>
            <h2>{{ name }} {{ isFavorite ? "(Favorite)" : "" }}</h2>
            <button @click="toggleFavorite">Toggle Favorite</button>
            <button @click="toggleDetails">
                {{ detailsAreVisible ? "Hide" : "Show" }} Details
            </button>
            <ul v-if="detailsAreVisible">
                <li><strong>Phone: </strong>{{ phoneNumber }}</li>
                <li><strong>Email: </strong>{{ emailAddress }}</li>
            </ul>
            <!-- have emit as in-line expression -->
            <button @click="$emit('delete', id)">Delete</button>
        </li>
    </template>

    <script>
    export default {
        props: {
            id: {
                type: String,
                require: true, 
            },
            // ...
        },
        emits: ['delete', 'toggleFavorite'],
        data(){ return {} },
        methods: {},
    }
    </script>
    ```
    ```html
    <!-- App.vue -->
    <template>
        <h2>My Friends</h2>
        <section>
            <header>
                <h1>My Friends</h1>
            </header>
            <new-friend @add-contact="addContact"></new-friend><ul>
                <friend-contact
                    v-for="friend in friends"
                    :key="friend.id"
                    :id="friend.id"
                    :name="friend.name"
                    :phone-number="friend.phone"
                    :email-address="friend.email"
                    :is-favorite="friend.isFavorite"
                    @toggle-favorite="toggleFavoriteStatus"
                    @delete="deleteContact"
                ></friend-contact>
            </ul>
        </section>
    </template>

    <script>
    export default {
        data() {
            return {
                friends: [
                    {
                        id: "manuel",
                        name: "Manuel Lorenz",
                        phone: "0123 45678 90",
                        email: "manuel@localhost.com",
                        isFavorite: true,
                    },
                    {
                        id: "julie",
                        name: "Julie Jones",
                        phone: "0987 654421 21",
                        email: "julie@localhost.com",
                        isFavorite: false,
                    },
                ],
            };
        },
        methods: {
            toggleFavoriteStatus(friendId) {
                const identifiedFriend = this.friends.find(
                    (friend) => friend.id === friendId
                );
                identifiedFriend.isFavorite = !identifiedFriend.isFavorite;
            },
            addContact(name, phone, email) {
                const newFriendContact = {
                    id: new Date().toISOString(),
                    name,
                    phone,
                    email,
                    isFavorite: false
                };
                this.friends.push(newFriendContact);
            },
            deleteContact(friendId) {
                this.friends = this.friends.filter(friend=>friend.id !== friendId);
            },
        },
    };
    </script>
    ```

## Assignment 6: Time to practice: Props and Custom events
1. Task 1: 
    1. Add two components to the app: 
    1. An ActiveUser component and an UserData component
    1. ActiveUser should output a username (h2) and age (h3)
    1. UserData should output two input fields => for name and age
    1. Optional: Add styling of your choice
1. Task 2: Output both components side-by-side in your main App template
1. Task 3: Add user data and ensure it contains a name and age
    1. User data should be output in ActiveUser
    1. It should be updated via the UserData component
1. Tentative solution. This is not so different from the solution given by the lecturer.
    ```html
    <!-- src/components/UserData.vue -->
    <template>
        <form action="" @submit.prevent="activateUser">
            <div>
                <label for="username">User Name</label>
                <input type="text" id="username" v-model="username">
            </div>
            <div>
                <label for="user_age">User Age</label>
                <input type="text" id="user_age" v-model="userAge">
            </div>
            <button>submit</button>
        </form>
    </template>

    <script>
    export default {
        emits: ['activate-user'],
        data() {
            return {
                username: '',
                userAge: 0
            }
        },
        methods: {
            activateUser() {
                this.$emit('activate-user', this.username, this.userAge);
            }
        }
    }
    </script>
    ```
    ```html
    <!-- src/components/ActiveUser.vue -->
    <template>
        <div>
            <h2>{{ username }}</h2>
            <h3 v-if="userAge">{{ userAge }}</h3>
        </div>
    </template>

    <script>
    export default {
        props: {
            username: {
                type: String,
                required: true, 
            },
            userAge: {
                type: Number,
                requried: true,
            },
        }
    }
    </script>
    ```
    ```html
    <!-- App.vue -->
    <template>
        <section>
            <user-data @activate-user="getUser"></user-data>
            <active-user
                :username="username"
                :user-age="userAge"
            ></active-user>
        </section>
    </template>

    <script>
    export default {
        data(){
            return {
                username: '',
                userAge: 0,    
            }
        },
        methods: {
            getUser(name, age) {
                this.username = name;
                this.userAge = parseInt(age);
            }
        }
    }
    </script>
    ```
    ```js
    // main.js
    import { createApp } from 'vue';
    import App from './App.vue';
    import ActiveUser from './components/ActiveUser.vue';
    import UserData from './components/UserData.vue';

    const app = createApp(App);

    app.component('active-user', ActiveUser);
    app.component('user-data', UserData);

    app.mount('#app');
    ```

## A Potential Problem
1. Since we start to build components with multiple layers, we are passing `props` and `emits` through several component. The components in the middle layers is only used to "open" the channel the ensure the data can be sent from the innermost component.
1. We use another syntax when there's no method to handle the emits and just pass it upwards. In this case we can [emit a value with an `$event`](https://v3.vuejs.org/guide/component-basics.html#emitting-a-value-with-an-event).
    ```html
    <!-- App.vue -->
    <template>
        <div>
            <active-element
                :topic-title="activeTopic && activeTopic.title"
                :text="activeTopic && activeTopic.fullText"
            ></active-element>
            <knowledge-base
                :topics="topics"
                @select-topic="activateTopic"
            ></knowledge-base>
        </div>
    </template>
    ```
    ```html
    <!-- KnowledgeBase -->
    <template>
        <section>
            <h2>Select a Topic</h2>
            <knowledge-grid
                :topics="topics"
                @select-topic="$emit('select-topic', $event)"
            ></knowledge-grid>
        </section>
    </template>
    ```
    ```html
    <!-- KnowledgeGrid -->
    <knowledge-element
      v-for="topic in topics"
      :key="topic.id"
      :id="topic.id"
      :topic-name="topic.title"
      :description="topic.description"
      @select-topic="$emit('select-topic', $event)"
    ></knowledge-element>
    ```
    ```html
    <!-- KnowledgeElement -->
    <template>
        <li>
            <h3>{{ topicName }}</h3>
            <p>{{ description }}</p>
            <button @click="$emit('select-topic', id)">Learn More</button>
        </li>
    </template>
    ```

## Provide + Inject To The Rescue
1. In Vue, we can use [`provide` and `inject`](https://v3.vuejs.org/guide/component-provide-inject.html#working-with-reactivity) (both of which are reserved properties as `data`, `methods,` and `computed`) and use these properties on the component to send data directly. 
1. In the previous example, an array of `topics` is stored in `App.vue`, while we'd like to use the data in `KnowledgeGrid`. We use provide in the "**parent**" component which sends the data, and use `inject` in the child component which is `KnowledgeGrid` to catch the data. Note that the component to `provide` the data must be a parent or ancestor of the "**injected**" component.
1. With the feature, we can avoid passing data through `KnowledgeBase` and pass directly from `App` to `KnowledgeGrid`. 
    ```html
    <!-- App.vue -->
    <script>
    export default {
        provide: {
            topics: [
                {
                    id: 'basics',
                    title: 'The Basics',
                    description: 'Core Vue basics you have to know',
                    fullText:
                        'Vue is a great framework and it has a couple of key concepts: Data binding, events, components and reactivity - that should tell you something!',
                },
                {
                    id: 'components',
                    title: 'Components',
                    description:
                        'Components are a core concept for building Vue UIs and apps',
                    fullText:
                        'With components, you can split logic (and markup) into separate building blocks and then combine those building blocks (and re-use them) to build powerful user interfaces.',
                },
            ],
        }
    }
    </script>
    ```
    ```html
    <!-- KnowledgeGrid.vue -->
    <script>
    export default {
        inject: ['topics'],
    }
    </script>
    ```
1. However, this creates another issue when the `data` is dynamic and mutable. When the `topic` object in `topcis` changes, it won't reflect to the data in `provide`. Therefore, we can declare `provide` as a method in the like `data`.
1. In addition, we can use `mounted` lifecycle method to simluate an async data fetch to add extra topic in the `topics` array. Note that we use array function to ensure `this` keyword refer to the correct scope and thus get the data from `this.topics`.
    ```js
    <!-- App.vue -->
    export default {
        data() {
            return {
                topics: [
                    {
                        id: 'basics',
                        title: 'The Basics',
                        description: 'Core Vue basics you have to know',
                        fullText:
                            'Vue is a great framework and it has a couple of key concepts: Data binding, events, components and reactivity - that should tell you something!',
                    },
                    {
                        id: 'components',
                        title: 'Components',
                        description:
                            'Components are a core concept for building Vue UIs and apps',
                        fullText:
                            'With components, you can split logic (and markup) into separate building blocks and then combine those building blocks (and re-use them) to build powerful user interfaces.',
                    },
                ],
            }
        },
        provide() {
            return {
                topics: this.topics,
            }
        },
        mounted() {
            setTimeout(() => {
                this.topics.push({
                    id: 'event',
                    title: 'Events',
                    description: 'Events are important in Vue',
                    fullText: 'Events allow you to trigger code on demand!',
                });
            }, 3000);
        }
    }
    ```

## Provide + Inject for Functions / Methods
1. `provide` and `inject` can not only be used on data but also for methods (function). Since we can pass the method from `App.vue` to `KnowledgeElement.vue`, we can remove the `$emit()` in `KnowledgeGrid.vue`.
1. In this case, we can expect a method is provided and to be injected as `selectTopc`. 
    ```html
    <!-- KnowledgeElement.vue -->
    <template>
        <li>
            <h3>{{ topicName }}</h3>
            <p>{{ description }}</p>
            <button @click="selectTopic(id)">Learn More</button>
        </li>
    </template>

    <script>
    export default {
        inject: ['selectTopic'],
        props: ['id', 'topicName', 'description'],
        emits: ['select-topic'],
    };
    </script>
    ```
    ```js
    // App.vue
    export default {
        provide() {
            return {
                topics: this.topics,
                selectTopic: this.activateTopic, // send the method with a given key
            };
        },
        methods: {
            activateTopic(topicId) {
                this.activeTopic = this.topics.find(
                    (topic) => topic.id === topicId
                );
            },
        },
    };
    ```

## Provide + Inject vs Props & Custom Events
1. Though `provide` and `inject` can be useful, it can also be very confusing when a team of developers try to understand where both of these are used. At the first sight, we can't know exactly which component in the Vue app is "**injected**".
1. Therefore, in some scanerios, we can still use pass-through `emit` to ensure other developers can understand the structure in a more obvious way.
    <img src="images/103-module_summary.png">



# Diving Deeper Into Components
## Global vs Local Components
1. If we register components at the main `app` which is in the `main.js`, these components will be "global" components which can be accessed from any component in the Vue app. Thus, we can use them anywhere in the `template` tag.
1. However, this approach can also be confusing when the app goes large. Besides, Vue needs to load all the components since the app initiates which can reduce app performance. Besides, some of the components may only be used once in the whole app.
1. To register a component locally, we can use `components` keyword, which is another reserved property as `data` and `methods`, and have key/value pair to indicate the component. Note that we can use either "**kebap-case**" in string or "**PascalCase**" for the property.
1. In addition, we can use PascalCase on the component as a self-closing element. Note that the regular kebap-case as for regular HTML tags doesn't work for custom compoenent for self-closing tag.
    ```vue
    <!-- Vue.app -->
    <template>
        <div>
            <TheHeader />
            <the-header></the-header>
            <badge-list></badge-list>
            <user-info
                :full-name="activeUser.name"
                :info-text="activeUser.description"
                :role="activeUser.role"
            ></user-info>
        </div>
    </template>
    ```
    ```html
    <script>
    import TheHeader from "./components/TheHeader.vue";
    import BadgeList from "./components/BadgeList.vue";
    import UserInfo from "./components/UserInfo.vue";

    export default {
        components: { 
            "the-header": TheHeader,
            BadgeList, // PascalCase also works. Vue will translate it to kebap-case for HTML
            UserInfo,
        },
        data() {
            return {
                activeUser: {
                    name: "Maximilian Schwarzmller",
                    description: "Site owner and admin",
                    role: "admin",
                },
            };
        },
    };
    </script>
    ```
    ```html
    <style>
    html {
        font-family: sans-serif;
    }

    body {
        margin: 0;
    }
    </style>
    ```

## Scoped Styles
1. In convention, we can have the styling globally in `App.vue` which styling can be applied to all the child components in it. 
1. We can add `scoped` on the `style` tag to limit the styling to be applied to only the component itself. The styling won't be applied to its sibling, neighbor, or child component.
    ```html
    <!-- App.vue -->
    <style scoped>
    </style>
    ```

## Introducing Slots   
1. We may have custom styled components which are used to wrap other elements. In this case, the child element in the wrapper has to be injected to the general component, which is not ideal for its purpose because we create these components with styling for general purpose that we can also import them globally in `main.js`. 
1. One solution is to pass `content` to props in string. The other solution is to use [`slot`](https://v3.vuejs.org/guide/component-slots.html#slots) in Vue.
     ```html
    <template>
        <div> {{ content }} </div>
    </template>

    <script>
    export default {
        props: ['content'],
    }
    </script>

    <style>
    div {
        margin: 2rem auto;
        max-width: 30rem;
        border-radius: 12px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.26);
        padding: 1rem;
    }
    </style>
    ```
    ```html
    <!-- UserInfo.vue -->
    <!-- this doesn't work! Because BaseCard.vue doesn't know what's inside of it -->
    <template>
        <section>
            <base-card>
                <header>
                    <h3>{{ fullName }}</h3>
                    <base-badge
                        :type="role"
                        :caption="role.toUpperCase()"
                    ></base-badge>
                </header>
                <p>{{ infoText }}</p>
            </base-card>
        </section>
    </template>
    ```
1. We then update the placeholder in `BaseCard.vue` by using `slot`.
    ```html
    <template>
        <div>
            <slot></slot>
        </div>
    </template>
    ```

## Named Slots
1. When using multiple `slot` in a general component, we can give `name` attribute to differentiate each `slot` tag. Note that we can have only one unamed `slot` in the component.
1. In this case have another `slot` named "**header**" which is inside a header tag. 
    ```html
    <!-- BaseCard.vue -->
    <template>
        <div>
            <header>
                <slot name="header"></slot>
            </header>
            <slot></slot>
        </div>
    </template>
    ```
1. We there can use `template`, which is a Vue tag, to import the named `slot` and use `v-slot:[name]` to bind the "**name**" that we give to the named `slot`.
    ```html
    <!-- UserInfo.Vue -->
    <template>
        <section>
            <base-card>
                <!-- use v-slot:[name] to import the named slot -->
                <template v-slot:header>
                    <h3>{{ fullName }}</h3>
                    <base-badge
                        :type="role"
                        :caption="role.toUpperCase()"
                    ></base-badge>
                </template>
                <p>{{ infoText }}</p>
            </base-card>
        </section>
    </template>
    ```
1. In addition, if there are multiple inner `template` tag, we can also indicate the `default` one to bind with the unamed `slot`. 
    ```html
    <!-- UserInfo.vue -->
    <template>
        <section>
            <base-card>
                <template v-slot:header>
                    <h2>Available Badges</h2>
                </template>
                <template v-slot:default>
                    <ul>
                        <li>
                            <base-badge type="admin" caption="ADMIN"></base-badge>
                        </li>
                        <li>
                            <base-badge type="author" caption="AUTHOR"></base-badge>
                        </li>
                    </ul>
                </template>
            </base-card>
        </section>
    </template>
    ```

## Slot Styles & Compilation
1. As we "**scoped**" the styling, it doesn't affect to the content sent to the `slot` and its child elements.
1. Vue will analyze and compile the `template` and its elements before rendering to the screen. Therefore, the regular CSS scope won't work as the styling is "fixed" to only the general HTML tags in the component. 
1. Thus, in this case, we need to move the styling for `header` HTML tag into `BaseCard.vue`. 
    ```html
    <!-- BaseCard.vue -->
    <template>
        <div>
            <header>
                <slot name="header"></slot>
            </header>
            <slot></slot>
        </div>
    </template>

    <script>
    export default {
        props: ["content"],
    };
    </script>

    <style scoped>
    div {
        margin: 2rem auto;
        max-width: 30rem;
        border-radius: 12px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.26);
        padding: 1rem;
    }

    header {
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    </style>
    ```

## More on Slots
1. We can have default elements in the general component if we have some content in the `slot`. 
    ```html
    <!-- BaseCard.vue -->
    <template>
        <div>
            <header>
                <slot name="header">
                    <!-- This h2 tag only shows when there's nothing sending to  -->
                    <h2>The Default</h2>
                </slot>
            </header>
            <slot></slot>
        </div>
    </template>
    ```
1. We can access the `slots` with a reserved property `$slots` which is an object similar to `$emit`. For example, we can use `mounted()` lifecycle method to print the element in the console. If the slot is named, we can use its name directly or use `default` to access the unamed one.
1. By using `console.log`, we can notice that the app prints `this.$slots.header` twice that the first is `undefined` as there's nothing given in the `slot`. 
1. Therefore, we can use the feature with `v-if` to check if there's any element is given and should Vue create a DOM for the `header` `slot`. 
    ```html
    <!-- BaseCard.vue -->
    <template>
        <div>
            <!-- prevents creating headerDOM if no child element is given -->
            <header v-if="$slots.header">
                <slot name="header">
                    <!-- <h2>The Default</h2> -->
                </slot>
            </header>
            <slot></slot>
        </div>
    </template>

    <script>
    export default {
        mounted() {
            console.log(this.$slots.header);
            console.log(this.$slots.default);
        }
    };
    </script>
    ```
1. In addition, `v-slot:` has a shorthand similar to `:` for `v-bind` and `@` for `v-on` that we can use a pound sign `#` to replace the attribute. 
    ```html
    <!-- BadgeList.vue -->
    <template>
        <section>
            <base-card>
                <!-- use v-slot: shorthand as '#' -->
                <template #default>
                    <ul>
                        <li>
                            <base-badge type="admin" caption="ADMIN"></base-badge>
                        </li>
                        <li>
                            <base-badge type="author" caption="AUTHOR"></base-badge>
                        </li>
                    </ul>
                </template>
            </base-card>
        </section>
    </template>
    ```

## Scoped Slots
1. In some scenarios, we would like the `slot` to access data that is only available in a child component using it, which data is usually an array. In this case, we can use [`scoped slots`](https://v3.vuejs.org/guide/component-slots.html#scoped-slots). 
    ```html
    <!-- CourseGoals.vue -->
    <template>
        <ul>
            <li v-for="goal in goals" :key="goal">
                <slot></slot>
            </li>
        </ul>
    </template>

    <script>
    export default {
        data() {
            return {
                goals: ["Finish the course", "Learn Vue"],
            };
        },
    };
    </script>
    ```

## Dynamic Components
1. We firstly restructure `App.vue` and create another 2 components for demo purpose, `ManageGoals.vue` and `ActiveGoals.vue`.
    ```html
    <!-- ActiveGoals.vue -->
    <template>
        <h2>Active Goals</h2>
    </template>
    ```
    ```html
    <!-- ManageGoals.vue -->
    <template>
        <h2>Manage Goals</h2>
    </template>
    ```
    ```html
    <!-- App.vue -->
    <template>
        <div>
            <the-header></the-header>
            <active-goals></active-goals>
            <manage-goals></manage-goals>
        </div>
    </template>
    ```
1. In this case, if we'd like to create buttons to control which component to show, we can use `v-if`, `data`, and `methods` to control the components.
1. However, this approach can be very tedious and hard to manage when there are many components.
    ```html
    <template>
        <div>
            <the-header></the-header>
            <button @click="setSelectedComponent('active-goals')">
                Active Goals
            </button>
            <button @click="setSelectedComponent('manage-goals')">
                Manage Goals
            </button>
            <active-goals
                v-if="selectedComponent === 'active-goals'"
            ></active-goals>
            <manage-goals
                v-if="selectedComponent === 'manage-goals'"
            ></manage-goals>
        </div>
    </template>

    <script>
    import TheHeader from "./components/TheHeader.vue";
    import ActiveGoals from "./components/ActiveGoals.vue";
    import ManageGoals from "./components/ManageGoals.vue";

    export default {
        components: {
            "the-header": TheHeader,
            ActiveGoals,
            ManageGoals,
        },
        data() {
            return {
                selectedComponent: "active-goals",
            };
        },
        methods: {
            setSelectedComponent(cmp) {
                this.selectedComponent = cmp;
            },
        },
    };
    </script>
    ```
1. The other way to have dynamic component is to use `component` element (which is Vue only tag) with `is` attribute that binds with a data.
    ```vue
    <!-- App.vue -->
    <template>
        <div>
            <the-header></the-header>
            <button @click="setSelectedComponent('active-goals')">
                Active Goals
            </button>
            <button @click="setSelectedComponent('manage-goals')">
                Manage Goals
            </button>
            <component :is="selectedComponent"></component>
        </div>
    </template>
    ```
    ```js
    // App.vue
    import TheHeader from "./components/TheHeader.vue";
    import ActiveGoals from "./components/ActiveGoals.vue";
    import ManageGoals from "./components/ManageGoals.vue";

    export default {
        components: {
            "the-header": TheHeader,
            ActiveGoals,
            ManageGoals,
        },
        data() {
            return {
                selectedComponent: "active-goals",
            };
        },
        methods: {
            setSelectedComponent(cmp) {
                this.selectedComponent = cmp;
            },
        },
    };
    ```

## Keeping Dynamic Components Alive
1. In some cases, we may have components that have `input` tags as part of the elements. However, when the user switch between the component, the inserted value in the `input` will be removed because the component is re-rendered by default.
    ```vue
    <template>
        <div>
            <h2>Manage Goals</h2>
            <!-- inserted value in input tag will be removed when the user switch between components -->
            <input type="text" />
        </div>
    </template>
    ```
1. In this case, we can use a Vue only tag `keep-alive` which will "**cache**" the component rather than trashing it from the DOM and re-render it.
    ```vue
    <!-- App.vue -->
    <template>
        <div>
            <the-header></the-header>
            <button @click="setSelectedComponent('active-goals')">
                Active Goals
            </button>
            <button @click="setSelectedComponent('manage-goals')">
                Manage Goals
            </button>
            <!-- use keep-alive tag to cache the component and its state -->
            <keep-alive>
                <component :is="selectedComponent"></component>
            </keep-alive>            
        </div>
    </template>
    ```

## Applying What We Know & A Problem
1. In case we want to apply a error catch in `ManageGoals` component that the user submits empty value. We can either use `alert` to show a warning or create another component `ErrorAlert` to show the warning message. 
1. In this case, we use `dialog` with `open` attribute to show contain the message and use `slot` to have customized elements in the component. 
    ```html
    <!-- ErrorAlert.vue -->
    <template>
        <dialog open>
            <slot></slot>
        </dialog>
    </template>

    <style scoped>
    dialog {
        margin: 0;
        position: fixed;
        top: 20vh;
        left: 30%;
        width: 40%;
        background-color: white;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.26);
        padding: 1rem;
    }
    </style>
    ```
1. We have an `input` tag in `ManageGoals` and use `ref` attribute with `this.$refs.[name]` to refer to the element. Though we can use DOM selector, this approach is easier and with less code.
1. We then have a method applied to the button and create a data `inputIsInvalid` as the state. If the input is empty, we can trigger and change the state that cause the component to re-render.
1. We then can add another button in the `dialog` component (as customized content) and toggle the state back to close the warning message.
    ```vue
    <!-- ManageGoals.vue -->
    <template>
        <div>
            <h2>Manage Goals</h2>
            <input type="text" ref="goal" />
            <button @click="setGoal">Set Goal</button>
            <error-alert v-if="inputIsInvalid">
                <h2>Input is invalid!</h2>
                <p>Please enter at least a few characters...</p>
                <button @click="confrimError">Okay</button>
            </error-alert>
        </div>
    </template>
    ```
    ```html
    <!-- ManageGoals.vue -->
    <script>
    import ErrorAlert from "./ErrorAlert.vue";

    export default {
        components: {
            ErrorAlert,
        },
        data() {
            return {
                inputIsInvalid: false,
            };
        },
        methods: {
            setGoal() {
                const enteredValue = this.$refs.goal.value;
                if (enteredValue === "") {
                    this.inputIsInvalid = true;
                }
            },
            confrimError() {
                this.inputIsInvalid = false;
            },
        },
    };
    </script>
    ```

## Teleporting Elements
1. From the previous case, we can inspect the HTML structure and notice that the `dialog` element is nested in the inner component. In this case, we can "teleport" the element and set it at the "root" of the component by using `teleport` which is a Vue only tag.
1. `teleport` tag has `to` attribute which we can pass a regular CSS selector such as `body` or `#app` to select the element in HTML DOM.
1. In the following case, `error-alert` component will be rendered in the `body` tag directly rather than nested in `ManageGoals` component.
    ```vue
    <!-- ManageGoals.vue -->
    <template>
        <div>
            <h2>Manage Goals</h2>
            <input type="text" ref="goal" />
            <button @click="setGoal">Set Goal</button>
            <!-- teleport the warpped element to body tag -->
            <teleport to="body">
                <error-alert v-if="inputIsInvalid">
                    <h2>Input is invalid!</h2>
                    <p>Please enter at least a few characters...</p>
                    <button @click="confrimError">Okay</button>
                </error-alert>
            </teleport>
        </div>
    </template>
    ```

## Working with Fragments
1. In Vue2, the elements in a `template` should be wrapped in a single block element, it means that in the `template` tag, there should be only a single `div`, `section`, or other HTML wrapper tags that contains all the other HTML elements.
    ```vue
    <!-- Vue 2 -->
    <template>
        <div>
            <h2>Manage Goals</h2>
            <input type="text" ref="goal" />
            <button @click="setGoal">Set Goal</button>
            <!-- teleport the warpped element to body tag -->
            <teleport to="body">
                <error-alert v-if="inputIsInvalid">
                    <h2>Input is invalid!</h2>
                    <p>Please enter at least a few characters...</p>
                    <button @click="confrimError">Okay</button>
                </error-alert>
            </teleport>
        </div>
    </template>
    ```
1. However, we can have the elements in Vue3 directly without a wrapper containing all the elements of a component.
    ```vue
    <!-- Vue 3 -->
    <template>
        <h2>Manage Goals</h2>
        <input type="text" ref="goal" />
        <button @click="setGoal">Set Goal</button>
        <!-- teleport the warpped element to body tag -->
        <teleport to="body">
            <error-alert v-if="inputIsInvalid">
                <h2>Input is invalid!</h2>
                <p>Please enter at least a few characters...</p>
                <button @click="confrimError">Okay</button>
            </error-alert>
        </teleport>
    </template>
    ```

## The Vue Style Guide
1. For naming and structuring of a Vue app, we can follow the [Style Guide](https://v3.vuejs.org/style-guide/#rule-categories) from Vue.js.

## Moving to a Different Folder Structure
1. We can use further file structuring to manage the components.
    <img src="images/121-module_summary.png">



# Course Projct: The Learning Resources App
## Setup & First Steps
1. We firstly create `components` directory in `src` and `App.vue` as the initial files. 
    ```js
    // main.js
    import { createApp } from 'vue';
    import App from './App.vue';

    const app = createApp(App)

    app.mount('#app');
    ```
    ```html
    <!-- App.vue -->
    <template>
        <ul>
            <li v-for="storedResource in storedResources" :key="storedResource.id">
                <h2>{{ storedResource.title }}</h2>
                <p>{{ storedResource.description }}</p>
                <a :href="storedResource.link">{{ storedResource.title }}</a>
            </li>
        </ul>
    </template>

    <script>
    export default {
        data() {
            return {
                storedResources: [
                    {
                        id: 'official-guide',
                        title: 'Official Guide',
                        description: 'The official Vue.js documentation',
                        link: 'https://vuejs.org',
                    },
                    {
                        id: 'google',
                        title: 'Google',
                        description: 'Learn to google...',
                        link: 'https://google.org',
                    },
                ],
            };
        },
    };
    </script>
    ```

## First Components & Props
1. We then create a sub-folder in `components` to hold all the learning resource related components.
    ```html
    <!-- src/components/learning-resources/LearningResource.vue -->
    <template>
        <li>
            <div>
                <header>
                    <h3>{{ title }}</h3>
                    <button>Delete</button>
                </header>
            </div>
            <p>{{ description }}</p>
            <nav>
                <a :href="link" target="_blank">View Resource</a>
            </nav>
        </li>
    </template>

    <script>
    export default {
        props: ['title', 'description', 'link'],
    };
    </script>
    ```
1. We send the `props` from `App.vue` to `LearningResource.vue` and import to use the component.
    ```html
    <!-- App.vue -->
    <template>
        <ul>
            <learning-resource
                v-for="res in storedResources"
                :key="res.id"
                :title="res.title"
                :description="res.description"
                :link="res.link"
            ></learning-resource>
        </ul>
    </template>

    <script>
    import LearningResource from './components/learning-resources/LearningResource.vue';
    export default {
        components: {
            LearningResource,
        },
        data() {
            return {
                storedResources: [
                    {
                        id: 'official-guide',
                        title: 'Official Guide',
                        description: 'The official Vue.js documentation',
                        link: 'https://vuejs.org',
                    },
                    {
                        id: 'google',
                        title: 'Google',
                        description: 'Learn to google...',
                        link: 'https://google.org',
                    },
                ],
            };
        },
    };
    </script>
    ```

## Styling and More Components
1. We create another component `StoredResources` to wrap the contents stored in `storedResources` Array. We firstly remove `LearningResources` component from `App.vue` and restructure it. We pass the array as a `prop` to `StoredResources`.
    ```html
    <!-- App.vue -->
    <template>
        <stored-resources :resources="storedResources"></stored-resources>
    </template>

    <script>
    import StoredResources from './components/learning-resources/StoredResources.vue';

    export default {
        components: {
            StoredResources,
        },
        data() {
            return {
                storedResources: [
                    {
                        id: 'official-guide',
                        title: 'Official Guide',
                        description: 'The official Vue.js documentation',
                        link: 'https://vuejs.org',
                    },
                    {
                        id: 'google',
                        title: 'Google',
                        description: 'Learn to google...',
                        link: 'https://google.org',
                    },
                ],
            };
        },
    };
    </script>

    <style>
    @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');
    * {
        box-sizing: border-box;
    }

    html {
        font-family: 'Roboto', sans-serif;
    }

    body {
        margin: 0;
    }
    </style>
    ```
1. `StoredResources` receive an array of objects as the learning resource.
    ```html
    <!-- src/components/learning-resources/StoredResources.vue -->
    <template>
        <ul>
            <learning-resource
                v-for="res in resources"
                :key="res.id"
                :title="res.title"
                :description="res.description"
                :link="res.link"
            ></learning-resource>
        </ul>
    </template>

    <script>
    import LearningResource from './LearningResource.vue';
    export default {
        components: { LearningResource },
        props: ['resources'],
    };
    </script>

    <style scoped>
    ul {
        list-style: none;
        margin: 0;
        padding: 0;
        margin: auto;
        max-width: 40rem;
    }
    </style>
    ```
1. We add some styling to `LearningResource.vue`.
    ```html
    <!-- src/components/learning-resources/LearningResource.vue -->
    <template>
        <li>
            <div>
                <header>
                    <h3>{{ title }}</h3>
                    <button>Delete</button>
                </header>
            </div>
            <p>{{ description }}</p>
            <nav>
                <a :href="link" target="_blank">View Resource</a>
            </nav>
        </li>
    </template>

    <script>
    export default {
        props: ['title', 'description', 'link'],
        methods: {},
    };
    </script>

    <style scoped>
    li {
        margin: auto;
        max-width: 40rem;
    }

    header {
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    h3 {
        font-size: 1.25rem;
        margin: 0.5rem 0;
    }

    p {
        margin: 0.5rem 0;
    }

    a {
        text-decoration: none;
        color: #ce5c00;
    }

    a:hover,
    a:active {
        color: #c89300;
    }
    </style>
    ```

## Header & BaseCard Components
1. We create `BaseCard` component, which we can use in the whole app, so we can register it in `main.js`.
    ```js
    // main.js
    import { createApp } from 'vue';
    import App from './App.vue';
    import BaseCard from './components/UI/BaseCard.vue';

    const app = createApp(App);
    app.component('base-card', BaseCard);

    app.mount('#app');
    ```
1. For the component, it's basically a wrapper which we can pass customized content into it, so we can use `slot` to inject elements when using it with other components.
    ```html
    <!-- src/components/UIBaseCard.vue -->
    <template>
        <div>
            <slot></slot>
        </div>
    </template>

    <style scoped>
    div {
        border-radius: 12px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.26);
        padding: 1rem;
        margin: 2rem auto;
        max-width: 40rem;
    }
    </style>
    ```
1. We create a header to be used as the main header in the app. It takes a `prop` to show the title in the header. 
    ```html
    <template>
        <header>
            <h1>{{ title }}</h1>
        </header>
    </template>

    <script>
    export default {
        props: ['title'],
    };
    </script>

    <style scoped>
    header {
        width: 100%;
        height: 5rem;
        background-color: #640032;
        display: flex;
        justify-content: center;
        align-items: center;
    }

    header h1 {
        color: white;
        margin: 0;
    }
    </style>
    ```
1. We use `TheHeader` component in `App.vue`.
    ```html
    <!-- App.vue -->
    <template>
        <the-header title="RememberMe"></the-header>
        <stored-resources :resources="storedResources"></stored-resources>
    </template>

    <script>
    import StoredResources from './components/learning-resources/StoredResources.vue';
    import TheHeader from './components/layouts/TheHeader.vue';

    export default {
        components: {
            StoredResources,
            TheHeader,
        },
    };
    </script>
    ```

## Adding a Base Button
1. We create another component `BaseButton` similar to `BaseCard` that can be used any where in the Vue app. 
1. We can use `v-bind` to bind both `type` and `class` HTML attributes to manipulate the behavior of the element. Note that the `class` is scoped to apply only to the button element itself, so we must pass the name of the `class` when calling it from the parent component.
1. Besides, we use `slot` to allow developers to send custom content in the button.
    ```html
    <!-- src/components/UI/BaseButton.vue -->
    <template>
        <button :type="type" :class="mode"><slot></slot></button>
    </template>

    <script>
    export default {
        props: ['type', 'mode'],
    };
    </script>

    <style scoped>
    button {
        padding: 0.75rem 1.5rem;
        font-family: inherit;
        background-color: #3a0061;
        border: 1px solid #3a0061;
        color: white;
        cursor: pointer;
    }

    button:hover,
    button:active {
        background-color: #270041;
        border-color: #270041;
    }

    .flat {
        background-color: transparent;
        color: #3a0061;
        border: none;
    }

    .flat:hover,
    .flat:active {
        background-color: #edd2ff;
    }
    </style>
    ```
1. Register the component in `main.js`.
    ```js
    // main.js
    import { createApp } from 'vue';
    import App from './App.vue';
    import BaseCard from './components/UI/BaseCard.vue';
    import BaseButton from './components/UI/BaseButton.vue';

    const app = createApp(App);
    app.component('base-card', BaseCard);
    app.component('base-button', BaseButton);

    app.mount('#app');
    ```
1. Update to use the component in `LearningResources`.
    ```vue
    <!-- src/components/learning-resource/LearningResources.vue -->
    <template>
        <li>
            <base-card>
                <header>
                    <h3>{{ title }}</h3>
                    <base-button mode="flat">Delete</base-button>
                </header>
                <p>{{ description }}</p>
                <nav>
                    <a :href="link" target="_blank">View Resource</a>
                </nav>
            </base-card>
        </li>
    </template>
    ```

## Dynamic Components & Attribute Fallthrough
1. We then create buttons to either "add" new resoruce or "view" all the stored resource. The components are `AddResource.vue` and `TheResources.vue`. 
1. We use `BaseCard` component to wrap the buttons and use HTML attribute "fall-through" behavior to use "**click**" event handler on the component.
1. We then use dynamic component by import components (which don't have globally access and isn't registered in `main.js`) with `is` attribute to change the component. 
1. We therefore took off `StoredResources` component from `App.vue`. However, this also lose its `data` (the array storing learning resources). The solution will be provided in the next section.
    ```vue
    <!-- src/components/learning-resources/TheResource.vue -->
    <template>
        <base-card>
            <!-- Add event handler to component directly -->
            <base-button @click="setSelectedTab('stored-resources')"
                >Stored Resources</base-button
            >
            <base-button @click="setSelectedTab('add-resources')"
                >Add Resource</base-button
            >
        </base-card>
        <component :is="selectedTab"></component>
    </template>
    ```
    ```html
    <script>
    import StoredResources from './StoredResources.vue';
    import AddResources from './AddResources.vue';
    export default {
        components: {
            StoredResources,
            AddResources,
        },
        data() {
            return {
                selectedTab: 'stored-resources',
            };
        },
        methods: {
            setSelectedTab(tab) {
                this.selectedTab = tab;
            },
        },
    };
    </script>
    ```

## Adding & Styling Tabs
1. We restructure `App.vue` and move `storedResources` array from the component to `TheResources`.
    ```html
    <!-- App.vue -->
    <template>
        <the-header title="RememberMe"></the-header>
        <the-resources></the-resources>
    </template>

    <script>
    import TheHeader from './components/layouts/TheHeader.vue';
    import TheResources from './components/learning-resources/TheResources.vue';

    export default {
        components: {
            TheHeader,
            TheResources,
        },
    };
    </script>

    <style>
    @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');
    * {
        box-sizing: border-box;
    }

    html {
        font-family: 'Roboto', sans-serif;
    }

    body {
        margin: 0;
    }
    </style>
    ```
1. In `TheResources`, we use `provide` property to send the array to `StoredResources` to render if the user selects it.
1. Besides, we use `computed` to check which component the user selects and apply class on it.
    ```vue
    <!-- src/components/learning-resource -->
    <template>
        <base-card>
            <base-button
                @click="setSelectedTab('stored-resources')"
                :mode="storedResButtonMode"
                >Stored Resources</base-button
            >
            <base-button
                @click="setSelectedTab('add-resource')"
                :mode="addResButtonMode"
                >Add Resource</base-button
            >
        </base-card>
        <component :is="selectedTab"></component>
    </template>
    ```
    ```html
    <!-- src/components/learning-resource -->
    <script>
    import StoredResources from './StoredResources.vue';
    import AddResource from './AddResource.vue';

    export default {
        components: {
            StoredResources,
            AddResource,
        },
        data() {
            return {
                selectedTab: 'stored-resources',
                storedResources: [
                    {
                        id: 'official-guide',
                        title: 'Official Guide',
                        description: 'The official Vue.js documentation',
                        link: 'https://vuejs.org',
                    },
                    {
                        id: 'google',
                        title: 'Google',
                        description: 'Learn to google...',
                        link: 'https://google.org',
                    },
                ],
            };
        },
        provide() {
            return {
                resources: this.storedResources,
            };
        },
        computed: {
            storedResButtonMode() {
                return this.selectedTab === 'stored-resources' ? null : 'flat';
            },
            addResButtonMode() {
                return this.selectedTab === 'add-resource' ? null : 'flat';
            },
        },
        methods: {
            setSelectedTab(tab) {
                this.selectedTab = tab;
            },
        },
    };
    </script>
    ```
1. In `StoredResources`, we use `inject` to catch the data sending from its parent component. From the previous lecture, we just simply change the data from `props` to `inejct`. 
    ```html
    <!-- src/components/learning-resources/StoredResources.vue -->
    <template>
        <ul>
            <learning-resource
                v-for="res in resources"
                :key="res.id"
                :title="res.title"
                :description="res.description"
                :link="res.link"
            ></learning-resource>
        </ul>
    </template>

    <script>
    import LearningResource from './LearningResource.vue';
    export default {
        inject: ['resources'], // change from props to 'inject' to catch data from 'provide'
        components: { LearningResource },
    };
    </script>

    <style scoped>
    ul {
        list-style: none;
        margin: 0;
        padding: 0;
        margin: auto;
        max-width: 40rem;
    }
    </style>
    ```

## Adding a Form
1. We then add a `form` to `AddResource` component to allow users to input new data to the `storedResources` array.
1. We have several `input` elements wrapped with `div` and use `BaseButton` as the submit button to the form. Note that we can use the `fall-through` feature by passing `type` attribute on the `<button>` directly without sending the `type` as `props` to `BaseButton` component.
    ```html
    <!-- AddResource.vue -->
    <template>
        <base-card>
            <form action="">
                <div class="form-control">
                    <label for="title">Title</label>
                    <input type="text" name="title" id="title" />
                </div>
                <div class="form-control">
                    <label for="description">Description</label>
                    <textarea
                        name="description"
                        id="description"
                        rows="3"
                    ></textarea>
                </div>
                <div class="form-control">
                    <label for="link">Link</label>
                    <input type="url" name="link" id="link" />
                </div>
                <div>
                    <base-button type="submit">Add Resource</base-button>
                </div>
            </form>
        </base-card>
    </template>

    <script>
    export default {};
    </script>

    <style scoped>
    label {
        font-weight: bold;
        display: block;
        margin-bottom: 0.5rem;
    }

    input,
    textarea {
        display: block;
        width: 100%;
        font: inherit;
        padding: 0.15rem;
        border: 1px solid #ccc;
    }

    input:focus,
    textarea:focus {
        outline: none;
        border-color: #3a0061;
        background-color: #f7ebff;
    }

    .form-control {
        margin: 1rem 0;
    }
    </style>
    ```
1. Therefore, we can just remove `type` from `props` in `BaseButton` component.
    ```html
    <!-- src/components/UI/BaseButton.vue -->
    <template>
        <button :class="mode">
            <slot></slot>
        </button>
    </template>

    <script>
    export default {
        props: ['mode'],
    };
    </script>

    <style scoped>
    button {
        padding: 0.75rem 1.5rem;
        font-family: inherit;
        background-color: #3a0061;
        border: 1px solid #3a0061;
        color: white;
        cursor: pointer;
    }

    button:hover,
    button:active {
        background-color: #270041;
        border-color: #270041;
    }

    .flat {
        background-color: transparent;
        color: #3a0061;
        border: none;
    }

    .flat:hover,
    .flat:active {
        background-color: #edd2ff;
    }
    </style>
    ````

## Fetching User Input
1. After setting up the HTML elements, we can work on the event handlers and connects between `TheResources.vue` and `AddResource.vue` component.
    ```vue
    <!-- src/components/learning-resources/AddResources.vue -->
    <template>
        <base-card>
            <form @submit.prevent="submitData">
                <div class="form-control">
                    <label for="title">Title</label>
                    <input type="text" name="title" id="title" ref="titleInput" />
                </div>
                <div class="form-control">
                    <label for="description">Description</label>
                    <textarea
                        name="description"
                        id="description"
                        rows="3"
                        ref="descInput"
                    ></textarea>
                </div>
                <div class="form-control">
                    <label for="link">Link</label>
                    <input type="url" name="link" id="link" ref="linkInput" />
                </div>
                <div>
                    <base-button type="submit">Add Resource</base-button>
                </div>
            </form>
        </base-card>
    </template>
    ```
1. From `TheResources.vue` we can `provide` a method from the component to be used in the other component. We firstly create `addResource` in `methods` which can push new input from the user to the array and send it to child components by using `provide`.
    ```js
    // src/components/learning-resources/TheResources.vue
    import StoredResources from './StoredResources.vue';
    import AddResource from './AddResource.vue';

    export default {
        components: {
            StoredResources,
            AddResource,
        },
        data() {
            return {
                selectedTab: 'stored-resources',
                storedResources: [
                    {
                        id: 'official-guide',
                        title: 'Official Guide',
                        description: 'The official Vue.js documentation',
                        link: 'https://vuejs.org',
                    },
                    {
                        id: 'google',
                        title: 'Google',
                        description: 'Learn to google...',
                        link: 'https://google.org',
                    },
                ],
            };
        },
        provide() {
            return {
                resources: this.storedResources,
                addResource: this.addResource,
            };
        },
        computed: {
            storedResButtonMode() {
                return this.selectedTab === 'stored-resources' ? null : 'flat';
            },
            addResButtonMode() {
                return this.selectedTab === 'add-resource' ? null : 'flat';
            },
        },
        methods: {
            setSelectedTab(tab) {
                this.selectedTab = tab;
            },
            addResource(title, description, url) {
                const newResource = {
                    id: new Date().toISOString(),
                    title,
                    description,
                    link: url,
                };
                this.storedResources.unshift(newResource);
                this.selectedTab = 'stored-resources';
            },
        },
    };
    ```
1. In `AddResource.vue`, we use `inject` to catch `addResource` method from `TheResources.vue` and call the method in its own method `submitData` to pass the data back to `TheResources.vue` component.
    ```js
    // src/components/learning-resources/AddResources.vue
    export default {
        inject: ['addResource'],
        methods: {
            submitData() {
                const enteredTitle = this.$refs.titleInput.value;
                const enteredDescription = this.$refs.descInput.value;
                const enteredLink = this.$refs.linkInput.value;

                this.addResource(enteredTitle, enteredDescription, enteredLink);
            },
        },
    };
    ```
1. In addition, we can use `keep-alive` tag to wrap the dynamic component in `TheResources.vue` to provide a better user experience that the inserted values won't be removed when switching between components.
    ```vue
    <!-- src/components/learning-resources/TheResources.vue -->
    <template>
        <base-card>
            <base-button
                @click="setSelectedTab('stored-resources')"
                :mode="storedResButtonMode"
                >Stored Resources</base-button
            >
            <base-button
                @click="setSelectedTab('add-resource')"
                :mode="addResButtonMode"
                >Add Resource</base-button
            >
        </base-card>
        <keep-alive>
            <component :is="selectedTab"></component>
        </keep-alive>
    </template>
    ```

## Adding a Modal Dialog
1. We create another general component `BaseDialog.vue` as `UI` and register it in `main.js`.
1. In this component, we allow developers to have 3 sections of custom contents, `header`, `main_content` and `actions`, so we need to give `name` to each `slot`. Besides, we give a default header to the `slot`.
1. Besides, we `emit` the action when the user try to click on the "close" button or on the backdrop (which is the filter-like background) to turn off the `dialog`. Note that in the styling, we have an empty `div` stretching and covering the whole viewport to create a filter-like backdrop.
    ```html
    <!-- src/components/UI/BaseDialog.vue -->
    <template>
        <div @click="$emit('close')"></div>
        <dialog open>
            <header>
                <slot name="header">
                    <h2>{{ title }}</h2>
                </slot>
            </header>
            <section>
                <slot></slot>
            </section>
            <menu>
                <slot name="actions">
                    <!-- this only shows if devleoper doesn't give any button -->
                    <base-button @click="$emit('close')">Close</base-button>
                </slot>
            </menu>
        </dialog>
    </template>

    <script>
    export default {
        props: {
            title: {
                type: String,
                required: false,
            },
        },
        emits: ['close'],
    };
    </script>

    <style scoped>
    div {
        position: fixed;
        top: 0;
        left: 0;
        height: 100vh;
        width: 100%;
        background-color: rgba(0, 0, 0, 0.75);
        z-index: 10;
    }

    dialog {
        position: fixed;
        top: 20vh;
        left: 10%;
        width: 80%;
        z-index: 100;
        border-radius: 12px;
        border: none;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.26);
        padding: 0;
        margin: 0;
        overflow: hidden;
    }

    header {
        background-color: #3a0061;
        color: white;
        width: 100%;
        padding: 1rem;
    }

    header h2 {
        margin: 0;
    }

    section {
        padding: 1rem;
    }

    menu {
        padding: 1rem;
        display: flex;
        justify-content: flex-end;
        margin: 0;
    }

    @media (min-width: 768px) {
        dialog {
            left: calc(50% - 20rem);
            width: 40rem;
        }
    }
    </style>
    ```
1. In `AddResource.vue`, we can "**listen**" to the emits.
    ```vue
    <!-- src/components/learning-resources/AddResource.vue -->
    <template>
        <base-dialog
            v-if="inputIsInvalid"
            title="Invalid Input"
            @close="confirmError"
        >
        <!-- handle emitted 'close' event -->
            <template #default>
                <p>Unfortunaltely, at least one input value is invalid.</p>
                <p>
                    Please check all inputs and make sure you enter at least a few
                    characters into each input field.
                </p>
            </template>
            <template v-slot:actions>
                <base-button @click="confirmError">Okay</base-button>
            </template>
        </base-dialog>
        <base-card>
            <form @submit.prevent="submitData">
                <div class="form-control">
                    <label for="title">Title</label>
                    <input type="text" name="title" id="title" ref="titleInput" />
                </div>
                <div class="form-control">
                    <label for="description">Description</label>
                    <textarea
                        name="description"
                        id="description"
                        rows="3"
                        ref="descInput"
                    ></textarea>
                </div>
                <div class="form-control">
                    <label for="link">Link</label>
                    <input type="url" name="link" id="link" ref="linkInput" />
                </div>
                <div>
                    <base-button type="submit">Add Resource</base-button>
                </div>
            </form>
        </base-card>
    </template>
    ```

## Deleting Items
1. To allow users to delete an item from the resource array, we add a new method `removeResource` in `TheResources.vue`. This method takes the `id` of the item object, so we can remove it from the array. This method should be provided to be used in each child component. 
    ```js
    // src/components/learning-resources/TheResources.vue
    import StoredResources from './StoredResources.vue';
    import AddResource from './AddResource.vue';

    export default {
        components: {
            StoredResources,
            AddResource,
        },
        data() {
            return {
                selectedTab: 'stored-resources',
                storedResources: [
                    {
                        id: 'official-guide',
                        title: 'Official Guide',
                        description: 'The official Vue.js documentation',
                        link: 'https://vuejs.org',
                    },
                    {
                        id: 'google',
                        title: 'Google',
                        description: 'Learn to google...',
                        link: 'https://google.org',
                    },
                ],
            };
        },
        provide() {
            return {
                resources: this.storedResources,
                addResource: this.addResource,
                deleteResource: this.removeResource,
            };
        },
        computed: {
            storedResButtonMode() {
                return this.selectedTab === 'stored-resources' ? null : 'flat';
            },
            addResButtonMode() {
                return this.selectedTab === 'add-resource' ? null : 'flat';
            },
        },
        methods: {
            setSelectedTab(tab) {
                this.selectedTab = tab;
            },
            addResource(title, description, url) {
                const newResource = {
                    id: new Date().toISOString(),
                    title,
                    description,
                    link: url,
                };
                this.storedResources.unshift(newResource);
                this.selectedTab = 'stored-resources';
            },
            removeResource(resId) {
                this.storedResources = this.storedResources.filter(
                    (res) => res.id !== resId
                ); // this doesn't work!
                console.log(this.storedResources.length);
            },
        },
    };
    ```
1. Besides, we need to modify `StoredResources.vue` to ensure the component pass `id` as `props` to its child component which is `LearningResources.vue`.
    ```html
    <!-- src/components/learning-resources/StoredResource.vue -->
    <template>
        <ul>
            <learning-resource
                v-for="res in resources"
                :key="res.id"
                :id="res.id"
                :title="res.title"
                :description="res.description"
                :link="res.link"
            ></learning-resource>
        </ul>
    </template>
    ```
1. In `LearningResource`, we use `inject` to catch the method sending from `TheResources.vue` and triger it when the user clicks on the "delete" button.
    ```vue
    <!-- src/components/learning-resources/LearningResource.vue -->
    <template>
        <li>
            <base-card>
                <header>
                    <h3>{{ title }}</h3>
                    <base-button mode="flat" @click="deleteResource(id)"
                        >Delete</base-button
                    >
                </header>
                <p>{{ description }}</p>
                <nav>
                    <a :href="link" target="_blank">View Resource</a>
                </nav>
            </base-card>
        </li>
    </template>    
    <script>
    export default {
        props: ['id', 'title', 'description', 'link'],
        inject: ['deleteResource'],
        methods: {},
    };
    </script>
    ```
1. However, this approach doesn't work because we are overwriting the data of `this.storedResources` in `TheResources.vue`. 
1. `Array.filter` method returns a new array which will change the `data` in `TheResources.vue` while the "**provided**" data to child components are still referring to the initial array.
1. Therefore, we need to modify the array directly rather than assigning a new array to the data. In this case, we can use `splice` to remove an item at a given index in the array.
    ```js
    // src/components/learning-resources/TheResources.vue
    import StoredResources from './StoredResources.vue';
    import AddResource from './AddResource.vue';

    export default {
        components: {
            StoredResources,
            AddResource,
        },
        data() {
            return {
                selectedTab: 'stored-resources',
                storedResources: [
                    {
                        id: 'official-guide',
                        title: 'Official Guide',
                        description: 'The official Vue.js documentation',
                        link: 'https://vuejs.org',
                    },
                    {
                        id: 'google',
                        title: 'Google',
                        description: 'Learn to google...',
                        link: 'https://google.org',
                    },
                ],
            };
        },
        provide() {
            return {
                resources: this.storedResources,
                addResource: this.addResource,
                deleteResource: this.removeResource,
            };
        },
        computed: {
            storedResButtonMode() {
                return this.selectedTab === 'stored-resources' ? null : 'flat';
            },
            addResButtonMode() {
                return this.selectedTab === 'add-resource' ? null : 'flat';
            },
        },
        methods: {
            setSelectedTab(tab) {
                this.selectedTab = tab;
            },
            addResource(title, description, url) {
                const newResource = {
                    id: new Date().toISOString(),
                    title,
                    description,
                    link: url,
                };
                this.storedResources.unshift(newResource);
                this.selectedTab = 'stored-resources';
            },
            removeResource(resId) {
                const resIndex = this.storedResources.findIndex(res => res.id === resId);
                this.storedResources.splice(resIndex, 1);
            },
        },
    };
    ```
1. The main reason of this issue is that the items rendered on the page are created by other Vue components. Since these componets takes data from `provide` and `inject` rather than `props`, it won't re-render because the data has been sent in the initial stage. Therefore, we have to ensure what data each component is referring to and manipulate on the correct `data`.

## Adding "Teleport"
1. We can put the dialog component `BaseDialog.vue` in the outter layer in HTML for semantic purpose. 
1. For the case, we can use `teleport` tag in `template` and specify the location by using CSS selector. 
    ```vue
    <!-- src/components/UI/BaseDialog.vue -->
    <template>
        <teleport to="body">
            <div @click="$emit('close')"></div>
            <dialog open>
                <header>
                    <slot name="header">
                        <h2>{{ title }}</h2>
                    </slot>
                </header>
                <section>
                    <slot></slot>
                </section>
                <menu>
                    <slot name="actions">
                        <base-button @click="$emit('close')">Close</base-button>
                    </slot>
                </menu>
            </dialog>
        </teleport>
    </template>
    ```



# Form
## v-model & Inputs
1. To retrieve the data from `input` tags in `form`, we can use either `methods` on the `input` or use `v-model` which binds to the properties in `data` directly, so we don't need to use `v-bind` and methods to handle the input event.
1. To prevent the submited `form` to refresh the page, we can use `.prevent` on the event listener on the `form` tag directly.
    ```html
    <!-- src/components/TheForm.vue -->
    <template>
        <form @submit.prevent="submitForm">
            <div class="form-control">
                <label for="user-name">Your Name</label>
                <input
                    id="user-name"
                    name="user-name"
                    type="text"
                    v-model="userName"
                />
            </div>
            <div class="form-control">
                <label for="age">Your Age (Years)</label>
                <input id="age" name="age" type="number" />
            </div>
            <div class="form-control">
                <label for="referrer">How did you hear about us?</label>
                <select id="referrer" name="referrer">
                    <option value="google">Google</option>
                    <option value="wom">Word of mouth</option>
                    <option value="newspaper">Newspaper</option>
                </select>
            </div>
            <div class="form-control">
                <h2>What are you interested in?</h2>
                <div>
                    <input id="interest-news" name="interest" type="checkbox" />
                    <label for="interest-news">News</label>
                </div>
                <div>
                    <input
                        id="interest-tutorials"
                        name="interest"
                        type="checkbox"
                    />
                    <label for="interest-tutorials">Tutorials</label>
                </div>
                <div>
                    <input id="interest-nothing" name="interest" type="checkbox" />
                    <label for="interest-nothing">Nothing</label>
                </div>
            </div>
            <div class="form-control">
                <h2>How do you learn?</h2>
                <div>
                    <input id="how-video" name="how" type="radio" />
                    <label for="how-video">Video Courses</label>
                </div>
                <div>
                    <input id="how-blogs" name="how" type="radio" />
                    <label for="how-blogs">Blogs</label>
                </div>
                <div>
                    <input id="how-other" name="how" type="radio" />
                    <label for="how-other">Other</label>
                </div>
            </div>
            <div>
                <button>Save Data</button>
            </div>
        </form>
    </template>

    <script>
    export default {
        data() {
            return {
                userName: '',
            };
        },
        methods: {
            submitForm() {
                console.log('Username: ' + this.userName);
                this.userName = '';
            },
        },
    };
    </script>
    ```

## Working with v-model Modifiers and Numbers
1. Though the lecture introduced that `v-model` can turn value retrieved from `input[type=number]` into `Number`, it is updated at the latest [Vue framework](https://v3.vuejs.org/guide/component-custom-events.html#handling-v-model-modifiers) (2021/05/15) that we need to use `.modifier` such as `v-model.number=""` to turn the input data into certain data type.
1. Therefore, in the regular case, `v-model` will still retrieve value as `String` type to store in `data`. This is exactly the same as using `refs` to retrive value from the DOM. 
1. Note that `v-model.number` works with `input[type=text]` that it can also convert value in `String` to `Number`.
1. There are other [modifiers](https://v3.vuejs.org/guide/component-custom-events.html#handling-v-model-modifiers) such as `.lazy` and `.trim`.

## v-model and Dropdowns
1. `v-model` can also work on `select` tag with `option` tags. We can set an initial for it to apply as the value in each option.
    ```html
    <!-- TheForm.vue -->
    <template>
        <form @submit.prevent="submitForm">
            <div class="form-control">
                <label for="referrer">How did you hear about us?</label>
                <select id="referrer" name="referrer" v-model="referrer">
                    <option value="google">Google</option>
                    <option value="wom">Word of mouth</option>
                    <option value="newspaper">Newspaper</option>
                </select>
            </div>
            <div>
                <button>Save Data</button>
            </div>
        </form>
    </template>

    <script>
    export default {
        data() {
            return {
                userName: '',
                userAge: null,
                referrer: 'wom',
            };
        },
        methods: {
            submitForm() {
                console.log('Referrer: ' + this.referrer);
                this.referrer = 'wom';
            },
        },
    };
    </script>
    ```

## Using v-model with Checkboxes & Radiobuttons
1. When working with multiple checkboxs `input[type=checkbox]` sharing the same `name` attribute, we can have them using the same `v-model` and pointing to the same `data`. 
1. Note that we should have an array to catch the data. Besides, each `input` should have its own unique `value` attribute to let Vue differentiate between them. Each value will be pushed to the array by the order of user clicking on the checkbox.
1. If there's a single checkbox, it handles with only `Boolean` value. 
1. For radio buttons `input[type=radio]`, we should also assign unique `value` to each of them, while them can also share the same `data` with `v-model`. The initial value can be set as `null`. 
    ```html
    <!-- TheForm.vue -->
    <template>
        <form @submit.prevent="submitForm">
            <div class="form-control">
                <h2>What are you interested in?</h2>
                <div>
                    <input
                        id="interest-news"
                        name="interest"
                        type="checkbox"
                        value="news"
                        v-model="interest"
                    />
                    <label for="interest-news">News</label>
                </div>
                <div>
                    <input
                        id="interest-tutorials"
                        name="interest"
                        type="checkbox"
                        value="tutorials"
                        v-model="interest"
                    />
                    <label for="interest-tutorials">Tutorials</label>
                </div>
                <div>
                    <input
                        id="interest-nothing"
                        name="interest"
                        type="checkbox"
                        value="nothing"
                        v-model="interest"
                    />
                    <label for="interest-nothing">Nothing</label>
                </div>
            </div>
            <div class="form-control">
                <h2>How do you learn?</h2>
                <div>
                    <input
                        id="how-video"
                        name="how"
                        type="radio"
                        value="video"
                        v-model="how"
                    />
                    <label for="how-video">Video Courses</label>
                </div>
                <div>
                    <input
                        id="how-blogs"
                        name="how"
                        type="radio"
                        value="blogs"
                        v-model="how"
                    />
                    <label for="how-blogs">Blogs</label>
                </div>
                <div>
                    <input
                        id="how-other"
                        name="how"
                        type="radio"
                        values="other"
                        v-model="how"
                    />
                    <label for="how-other">Other</label>
                </div>
            </div>
            <div class="form-control">
                <input
                    type="checkbox"
                    name="confirm-terms"
                    id="confirm-terms"
                    v-model="confirm"
                />
                <label for="confirm-terms">Agree to terms of use?</label>
            </div>
            <div>
                <button>Save Data</button>
            </div>
        </form>
    </template>

    <script>
    export default {
        data() {
            return {
                userName: '',
                userAge: null,
                referrer: 'wom',
                interest: [], // multiple checkboxes
                how: null,
                confirm: false, // single checkbox
            };
        },
        methods: {
            submitForm() {
                console.log('Checkboxes');
                console.log(this.interest);
                this.interest = [];

                console.log('Radio buttons');
                console.log(this.how);
                this.how = null;

                console.log('Confirm?');
                console.log(this.confirm);
                this.confirm = false;
            },
        },
    };
    </script>
    ```

## Adding Basic Form Validation
1. We can use a input event [`blur`](https://www.w3schools.com/jsref/event_onblur.asp) (similar to [`onfocusout`](https://www.w3schools.com/jsref/event_onfocusout.asp)) which trigers when the user leaves an `input` field if it has been focused on.
1. We can have another state `userNameValidity` in `data` to check whether to show the error message and add `invalid` class to the `input` and `label` tag. 
    ```html
    <!-- TheForm.vue -->
    <template>
        <form @submit.prevent="submitForm">
            <div
                class="form-control"
                :class="{ invalid: userNameValidity === 'invalid' }"
            >
                <label for="user-name">Your Name</label>
                <input
                    id="user-name"
                    name="user-name"
                    type="text"
                    v-model.trim="userName"
                    @blur="validateInput"
                />
                <p v-if="userNameValidity === 'invalid'">
                    Please enter a valid name!
                </p>
            </div>
            <div>
                <button>Save Data</button>
            </div>
        </form>
    </template>

    <script>
    export default {
        data() {
            return {
                userNameValidity: 'pending',
            };
        },
        methods: {
            validateInput() {
                if (!this.userName) {
                    this.userNameValidity = 'invalid';
                } else {
                    this.userNameValidity = 'valid';
                }
            },
        },
    };
    </script>

    <style scoped>
    form {
        margin: 2rem auto;
        max-width: 40rem;
        border-radius: 12px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.26);
        padding: 2rem;
        background-color: #ffffff;
    }

    .form-control {
        margin: 0.5rem 0;
    }

    label {
        font-weight: bold;
    }

    .form-control.invalid input { /* turn input field red */
        border-color: red;
    }

    .form-control.invalid label { /* turn label color red */
        color: red;
    }

    h2 {
        font-size: 1rem;
        margin: 0.5rem 0;
    }

    input,
    select {
        display: block;
        width: 100%;
        font: inherit;
        margin-top: 0.5rem;
    }

    select {
        width: auto;
    }

    input[type='checkbox'],
    input[type='radio'] {
        display: inline-block;
        width: auto;
        margin-right: 1rem;
    }

    input[type='checkbox'] + label,
    input[type='radio'] + label {
        font-weight: normal;
    }

    button {
        font: inherit;
        border: 1px solid #0076bb;
        background-color: #0076bb;
        color: white;
        cursor: pointer;
        padding: 0.75rem 2rem;
        border-radius: 30px;
    }

    button:hover,
    button:active {
        border-color: #002350;
        background-color: #002350;
    }
    </style>
    ```

## Building a Custom Control Component
1. We create a `RatingControl` component to allow users to select one of the 3 options.
    ```html
    <!-- RatingControl.vue -->
    <template>
        <ul>
            <li :class="{ active: activeOption === 'poor' }">
                <button type="button" @click="activate('poor')">Poor</button>
            </li>
            <li :class="{ active: activeOption === 'average' }">
                <button type="button" @click="activate('average')">Average</button>
            </li>
            <li :class="{ active: activeOption === 'great' }">
                <button type="button" @click="activate('great')">Great</button>
            </li>
        </ul>
    </template>

    <script>
    export default {
        data() {
            return {
                activeOption: null,
            };
        },
        methods: {
            activate(option) {
                this.activeOption = option;
            },
        },
    };
    </script>

    <style scoped>
    .active {
        border-color: #a00078;
    }

    .active button {
        color: #a00078;
    }

    ul {
        list-style: none;
        margin: 0.5rem 0;
        padding: 0;
        display: flex;
    }

    li {
        margin: 0 1rem;
        border: 1px solid #ccc;
        padding: 1rem;
        display: flex;
        justify-content: center;
        align-items: center;
    }

    button {
        font: inherit;
        border: none;
        background-color: transparent;
        cursor: pointer;
    }
    </style>
    ```
1. We then can import and use the component in `TheForm` locally. However, we haven't connected the componet and its data with the `form` in this lecture.
    ```html
    <!-- TheForm.vue -->
    <template>
        <form @submit.prevent="submitForm">
            <div class="form-control">
                <rating-control></rating-control>
            </div>
            <div>
                <button>Save Data</button>
            </div>
        </form>
    </template>

    <script>
    import RatingControl from './RatingControl.vue';
    export default {
        components: {
            RatingControl,
        },
    };
    </script>
    ```

## Using v-model on Custom Components
1. `v-model` is actually a shorthand to use both `v-on:input` and `v-bind:value`. However, we have only learnt to how to use `v-model` on `input` and `select` tags so far. We haven't learnt how to work it on custom components such as `RatingControl.vue` that we just made.
1. When creating a [custom component](https://v3.vuejs.org/guide/migration/v-model.html#overview), Vue will automatically set a `modelValue` as a `prop` to the component behind the scenes. Besides, the custom component will "**emit**" an event `update:modelValue`.
1. By the feature, we still can use `v-model` on a custom component, while we need to declare both the `props` and `emits` in the custom components.
    ```js
    // RatingControl.vue 
    export default {
        props: ['modelValue'],
        emits: ['update:modelValue'],
        data() {
            return {
                activeOption: null,
            };
        },
        methods: {
            activate(option) {
                this.activeOption = option;
            },
        },
    };
    ```
1. In `TheForm`, when we are using `v-model`, it's like we are using both `:model-value=""` and `@update:modelValue=""`. 
    ```html
    <!-- TheForm.vue -->
    <template>
        <form @submit.prevent="submitForm">
            <div class="form-control">
                <rating-control
                    v-model="rating"
                    :model-value="rating"
                    @update:modelValue=""
                ></rating-control>
            </div>
            <div>
                <button>Save Data</button>
            </div>
        </form>
    </template>

    <script>
    import RatingControl from './RatingControl.vue';
    export default {
        components: {
            RatingControl,
        },
    };
    </script>
    ```
1. Therefore, in `RatingControl.vue`, we should use `emit` to send the data back. 
1. However, `data` value from  injected data such as values from `props` or `inject` only receive once and set as initial, it won't be changed though new value is passed in the parent component. 
1. Therefore, we can use `computed` to work on the dynamic styling instead.
    ```html
    <!-- RatingControl.vue -->
    <template>
        <ul>
            <li :class="{ active: activeOption === 'poor' }">
                <button type="button" @click="activate('poor')">Poor</button>
            </li>
            <li :class="{ active: activeOption === 'average' }">
                <button type="button" @click="activate('average')">Average</button>
            </li>
            <li :class="{ active: activeOption === 'great' }">
                <button type="button" @click="activate('great')">Great</button>
            </li>
        </ul>
    </template>

    <script>
    export default {
        props: ['modelValue'],
        emits: ['update:modelValue'],
        // data() {
        //     return {
        //         activeOption: this.modelValue,
        //     };
        // },
        computed: {
            activeOption() {
                return this.modelValue;
            },
        },
        methods: {
            activate(option) {
                this.$emit('update:modelValue', option);
            },
        },
    };
    </script>
    ```
1. Note that we reset all the inputs in `submitForm` method in `TheForm.vue`.
    ```html
    <!-- TheForm.vue -->
    <script>
    import RatingControl from './RatingControl.vue';
    export default {
        components: {
            RatingControl,
        },
        data() {
            return {
                userName: '',
                userAge: null,
                referrer: 'wom',
                interest: [],
                how: null,
                confirm: false,
                userNameValidity: 'pending',
                rating: null,
            };
        },
        methods: {
            submitForm() { // print out and reset all states
                console.log('Username: ' + this.userName);
                this.userName = '';

                console.log('Userage: ');
                console.log(this.userAge + 5);
                this.userAge = null;

                console.log('Referrer: ' + this.referrer);
                this.referrer = 'wom';

                console.log('Checkboxes');
                console.log(this.interest);
                this.interest = [];

                console.log('Radio buttons');
                console.log(this.how);
                this.how = null;

                console.log('Confirm?');
                console.log(this.confirm);
                this.confirm = false;

                console.log('Rating');
                console.log(this.rating);
                this.rating = null;
            },
        },
    };
    </script>
    ```



# Sending Http Requests
## Starting App & Why we need a Backend
## Adding a Backend
1. The reseaon here is only that we need a backend to work with HTTP requests.
1. We just start a new project in [Firebase](https://firebase.google.com/). 

## How to (Not) Send Http Requests
1. We can use either `axios` or `fetch` API to send HTTP requests to a backend server.

## Sending a POST Request to Store Data
1. We can check [Firebase realtime database documentation](https://firebase.google.com/docs/reference/rest/database) for the pattern to call REST API served by firebase.
1. In this case, we can naming anything after the endpoint to call to Firebase and add it a suffix with `.json`. Firebase will create the data and store in its realtime database.
1. The part is relatively easy that we just use `fetch` to call the endpoint with POST method and send the data.
1. Besides, since we don't store the input in the memory locally.
    ```js
    // LearningSurvey.vue
    fetch(
        'firebase_endpoint/surveys.json',
        {
            method: 'post',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                name: this.enteredName,
                rating: this.chosenRating,
            }),
        }
    );
    ```

## Getting Data (GET Request) & Transforming Response Data
1. Since we don't have data sending from the parent component, we can take off `props` from the object.
1. As `fetch` API returns a `Promise`, we can use `.then` to handle the aysnc behavior and update the received data to `data`. 
1. On the other hand, we can also use `async/await` syntax for async function.
1. The endpoint send back an object with an unique id as the key property and `name` and `rating` aligned with the id.
    ```html
    <!-- UserExperience.vue -->
    <template>
        <section>
            <base-card>
                <h2>Submitted Experiences</h2>
                <div>
                    <base-button @click="loadExperiences"
                        >Load Submitted Experiences</base-button
                    >
                </div>
                <ul>
                    <survey-result
                        v-for="result in results"
                        :key="result.id"
                        :name="result.name"
                        :rating="result.rating"
                    ></survey-result>
                </ul>
            </base-card>
        </section>
    </template>

    <script>
    import SurveyResult from './SurveyResult.vue';

    export default {
        // props: ['results'],
        data() {
            return {
                results: [],
            };
        },
        components: {
            SurveyResult,
        },
        methods: {
            loadExperiences() {
                fetch(
                    'https://vue-http-demo-3a652-default-rtdb.asia-southeast1.firebasedatabase.app/surveys.json'
                )
                    .then((response) => {
                        if (response.ok) return response.json();
                    })
                    .then((data) => {
                        const results = [];
                        for (const id in data) {
                            results.push({
                                id,
                                name: data[id].name,
                                rating: data[id].rating,
                            });
                        }
                        this.results = results;
                    });
            },
        },
    };
    </script>
    ```

## Loading Data When a Component Mounts
1. We can use the lifecycle methods as React app does, to call the endpoint and load the data before the elements rendered to the screen. This approach can significantly improve user experience.
1. In this case, we can simply call the `loadExperiences` method in `mounted`.
    ```js
    // UserExperiences.vue
    import SurveyResult from './SurveyResult.vue';

    export default {
        // props: ['results'],
        data() {
            return {
                results: [],
            };
        },
        components: {
            SurveyResult,
        },
        methods: {
            loadExperiences() {
                fetch(
                    'https://vue-http-demo-3a652-default-rtdb.asia-southeast1.firebasedatabase.app/surveys.json'
                )
                    .then((response) => {
                        if (response.ok) return response.json();
                    })
                    .then((data) => {
                        const results = [];
                        console.log(data);
                        for (const id in data) {
                            results.push({
                                id,
                                name: data[id].name,
                                rating: data[id].rating,
                            });
                        }
                        this.results = results;
                    });
            },
        },
        mounted() {
            this.loadExperiences();
        },
    };
    ```

## Showing a "Loading..." Message
1. We can have a new state `isLoading` in `data` and set default as `false`.
1. When the app starts it runs `loadExperience` and turn the state to `true`.
1. After it receives data from the endpoint, we can tur nthe state back to `false`.
1. After configuring the states and methods, we can use `v-if` and `v-else` to decide whether to show the hint message.
    ```html
    <!-- UserExperience.vue -->
    <template>
        <section>
            <base-card>
                <h2>Submitted Experiences</h2>
                <div>
                    <base-button @click="loadExperiences"
                        >Load Submitted Experiences</base-button
                    >
                </div>
                <p v-if="isLoading">Lading...</p>
                <ul v-else>
                    <survey-result
                        v-for="result in results"
                        :key="result.id"
                        :name="result.name"
                        :rating="result.rating"
                    ></survey-result>
                </ul>
            </base-card>
        </section>
    </template>

    <script>
    import SurveyResult from './SurveyResult.vue';

    export default {
        // props: ['results'],
        data() {
            return {
                results: [],
                isLoading: false,
            };
        },
        components: {
            SurveyResult,
        },
        methods: {
            loadExperiences() {
                this.isLoading = true;
                fetch(
                    'https://vue-http-demo-3a652-default-rtdb.asia-southeast1.firebasedatabase.app/surveys.json'
                )
                    .then((response) => {
                        if (response.ok) return response.json();
                    })
                    .then((data) => {
                        this.isLoading = false;
                        const results = [];
                        console.log(data);
                        for (const id in data) {
                            results.push({
                                id,
                                name: data[id].name,
                                rating: data[id].rating,
                            });
                        }
                        this.results = results;
                    });
            },
        },
        mounted() {
            this.loadExperiences();
        },
    };
    </script>
    ```

## Handling the "No Data" State
1. We can add other logical expressions to check whether we have received any data after successfully call the endpoint.
1. We can check whether `isLoading` is `false` as the fetching process has done and if `results` array has `length` more than 0.
    ```vue
    <!-- UserExperience.vue -->
    <template>
        <section>
            <base-card>
                <h2>Submitted Experiences</h2>
                <div>
                    <base-button @click="loadExperiences"
                        >Load Submitted Experiences</base-button
                    >
                </div>
                <p v-if="isLoading">Lading...</p>
                <p v-else-if="!isLoading && (!results || !results.length)">
                    No stored experiences found. Start adding some survey results
                    first.
                </p>
                <ul v-else-if="!isLoading && results && results.length">
                    <survey-result
                        v-for="result in results"
                        :key="result.id"
                        :name="result.name"
                        :rating="result.rating"
                    ></survey-result>
                </ul>
            </base-card>
        </section>
    </template>
    ````

## Handling Technical / Browser-side Errors
1. We give a new state `error` to check if there's error when calling the endpoint.
1. We can switch the execution order for `v-if` and `v-else-if` for the desirable results. For example, we firstly check loading is completed, if there's any error on the endpoint call. 
1. 
    ```html
    <!-- UserExperience.vue -->
    <template>
        <section>
            <base-card>
                <h2>Submitted Experiences</h2>
                <div>
                    <base-button @click="loadExperiences"
                        >Load Submitted Experiences</base-button
                    >
                </div>
                <p v-if="isLoading">Loading...</p>
                <p v-else-if="!isLoading && error">{{ error }}</p>
                <p v-else-if="!isLoading && (!results || !results.length)">
                    No stored experiences found. Start adding some survey results
                    first.
                </p>
                <ul v-else>
                    <survey-result
                        v-for="result in results"
                        :key="result.id"
                        :name="result.name"
                        :rating="result.rating"
                    ></survey-result>
                </ul>
            </base-card>
        </section>
    </template>

    <script>
    import SurveyResult from './SurveyResult.vue';

    export default {
        // props: ['results'],
        data() {
            return {
                results: [],
                isLoading: false,
                error: null,
            };
        },
        components: {
            SurveyResult,
        },
        methods: {
            loadExperiences() {
                this.isLoading = true;
                this.error = null;
                fetch(
                    'https://vue-http-demo-3a652-default-rtdb.asia-southeast1.firebasedatabase.app/surveys.json'
                )
                    .then((response) => {
                        if (response.ok) return response.json();
                    })
                    .then((data) => {
                        this.isLoading = false;
                        const results = [];
                        console.log(data);
                        for (const id in data) {
                            results.push({
                                id,
                                name: data[id].name,
                                rating: data[id].rating,
                            });
                        }
                        this.results = results;
                    })
                    .catch((error) => {
                        console.log(error);
                        this.isLoading = false;
                        this.error =
                            'Failed to fetch data - please try again later.';
                    });
            },
        },
        mounted() {
            this.loadExperiences();
        },
    };
    </script>
    ```

## Handling Error Responses
1. This section is about handling error when calling sending POST request to the endpoint. In some scenarios, the server respond an error with hint as the request maybe invalid or there's something wrong on the server-side.
1. In this case, we can use `.then` to check if `response` object respond by Firebase endpoint has a `true` `.ok` property. If not, we can `throw new Error()` and use `.catch` to react to the error in JavaScript and render a customized hint to the user.
    ```html
    <!-- LearningSurvey.vue -->
    <template>
        <section>
            <base-card>
                <h2>How was you learning experience?</h2>
                <form @submit.prevent="submitSurvey">
                    <div class="form-control">
                        <label for="name">Your Name</label>
                        <input
                            type="text"
                            id="name"
                            name="name"
                            v-model.trim="enteredName"
                        />
                    </div>
                    <h3>My learning experience was ...</h3>
                    <div class="form-control">
                        <input
                            type="radio"
                            id="rating-poor"
                            value="poor"
                            name="rating"
                            v-model="chosenRating"
                        />
                        <label for="rating-poor">Poor</label>
                    </div>
                    <div class="form-control">
                        <input
                            type="radio"
                            id="rating-average"
                            value="average"
                            name="rating"
                            v-model="chosenRating"
                        />
                        <label for="rating-average">Average</label>
                    </div>
                    <div class="form-control">
                        <input
                            type="radio"
                            id="rating-great"
                            value="great"
                            name="rating"
                            v-model="chosenRating"
                        />
                        <label for="rating-great">Great</label>
                    </div>
                    <p v-if="invalidInput">
                        One or more input fields are invalid. Please check your
                        provided data.
                    </p>
                    <p v-if="error">{{ error }}</p>
                    <div>
                        <base-button>Submit</base-button>
                    </div>
                </form>
            </base-card>
        </section>
    </template>

    <script>
    export default {
        data() {
            return {
                enteredName: '',
                chosenRating: null,
                invalidInput: false,
                error: null,
            };
        },
        emits: ['survey-submit'],
        methods: {
            submitSurvey() {
                if (this.enteredName === '' || !this.chosenRating) {
                    this.invalidInput = true;
                    return;
                }
                this.invalidInput = false;

                // this.$emit('survey-submit', {
                //     userName: this.enteredName,
                //     rating: this.chosenRating,
                // });

                this.error = null;
                fetch(
                    'https://vue-http-demo-3a652-default-rtdb.asia-southeast1.firebasedatabase.app/surveys.json',
                    {
                        method: 'post',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            name: this.enteredName,
                            rating: this.chosenRating,
                        }),
                    }
                )
                    .then((response) => {
                        if (response.ok) {
                            // if...
                        } else {
                            throw new Error('Could not save data!');
                        }
                    })
                    .catch((error) => {
                        console.log(error);
                        this.error = error.message; // catch from the Error object from .then
                    });

                this.enteredName = '';
                this.chosenRating = null;
            },
        },
    };
    </script>
    ```



# Routing: Building "Multi-Page" Single Page Application
## What & Why?
1. Vue is a SPA (single page application) framework, so when user using the app, all the UI and components are controled by JavaScript and it doesn't change the path on the search bar in the browser. 
1. Therefore, when we share the URL of the web app, the user will always be directed to the initial page of the app.

## Routing Setup
1. To use routing system in Vue, we can install package `vue-router`. In this case, we add a suffix `@next` when install the package `npm install vue-router@next`. 
1. There are 2 main configuration to setup `vue-router` which are [`history`](https://next.router.vuejs.org/guide/essentials/history-mode.html) and `routes`. 
1. `history` is to record the path that the user has visited, and it can be 2 modes `hash` and `HTML5`. We use `createWebHistory` which is based on `HTML5` in this case.
1. `routes` are the paths that we want to register in the case. 
    ```js
    // main.js
    import { createApp } from 'vue';
    import { createRouter, createWebHistory } from 'vue-router'; // import vue-router

    import App from './App.vue';

    const router = createRouter({ // register behavior and configure startup
        history: createWebHistory(),
        routes: [],
    });

    const app = createApp(App)

    app.mount('#app');
    ```

## Registering & Rendering Routes
1. We can register the components to render with the route. Therefore, we import the component to `main.js` directly.
1. After registeration, we can use `app.use` to register router to the Vue app. This concept is similar to use `Express` framework in NodeJS.
    ```js
    // main.js
    import { createApp } from 'vue';
    import { createRouter, createWebHistory } from 'vue-router';

    import App from './App.vue';
    import TeamsList from './components/teams/TeamsList.vue';
    import UsersList from './components/users/UsersList.vue';

    const router = createRouter({
        history: createWebHistory(),
        routes: [
            { path: '/teams', component: TeamsList }, // our-domain.com/teams => TeamsList
            { path: '/users', component: UsersList },
        ],
    });

    const app = createApp(App);

    app.use(router);

    app.mount('#app');
    ```
1. After registering the components in `main.js`, we can remove component in `App.vue` as the rendering mechanism will be handled by `vue-router` in `main.js`. 
1. Besides, we need to add `router-view` tag in the template.
1. Note that the buttons on the top navigation doesn't work yet.
    ```html
    <!-- App.vue -->
    <template>
        <!-- <the-navigation @set-page="setActivePage"></the-navigation> -->
        <the-navigation></the-navigation>
        <main>
            <!-- <component :is="activePage"></component> -->
            <router-view></router-view>
        </main>
    </template>

    <script>
    // import TeamsList from './components/teams/TeamsList.vue';
    // import UsersList from './components/users/UsersList.vue';
    import TheNavigation from './components/nav/TheNavigation.vue';

    export default {
        components: {
            TheNavigation,
            // TeamsList,
            // UsersList,
        },
        data() {
            return {
                activePage: 'teams-list',
                teams: [
                    { id: 't1', name: 'Frontend Engineers', members: ['u1', 'u2'] },
                    {
                        id: 't2',
                        name: 'Backend Engineers',
                        members: ['u1', 'u2', 'u3'],
                    },
                    { id: 't3', name: 'Client Consulting', members: ['u4', 'u5'] },
                ],
                users: [
                    { id: 'u1', fullName: 'Max Schwarz', role: 'Engineer' },
                    { id: 'u2', fullName: 'Praveen Kumar', role: 'Engineer' },
                    { id: 'u3', fullName: 'Julie Jones', role: 'Engineer' },
                    { id: 'u4', fullName: 'Alex Blackfield', role: 'Consultant' },
                    { id: 'u5', fullName: 'Marie Smith', role: 'Consultant' },
                ],
            };
        },
        provide() {
            return {
                teams: this.teams,
                users: this.users,
            };
        },
        /*
        methods: {
            setActivePage(page) {
                this.activePage = page;
            },
        },
        */
    };
    </script>
    ```

## Navigating with router-link
1. We then change the link from `button` tags to `router-link` which is `vue-router` specific and creates an anchor tag `<a>` behind the scenes.
1. Since we aren't using `button` tags and to `emit` data from the component, we can simply remove the `script` section from the component.
1. As the links are changed to anchor tags `<a>`, we need to modify the CSS styling.
    ```html
    <!-- src/components/nav/TheNavigation.vue -->
    <template>
        <header>
            <nav>
                <ul>
                    <li>
                        <!-- <button @click="setActivePage('teams-list')">Teams</button> -->
                        <router-link to="/teams">Teams</router-link>
                    </li>
                    <li>
                        <!-- <button @click="setActivePage('users-list')">Users</button> -->
                        <router-link to="/users">Users</router-link>
                    </li>
                </ul>
            </nav>
        </header>
    </template>

    <script>
    export default {
        emits: ['set-page'],
        // methods: {
        //   setActivePage(page) {
        //     this.$emit('set-page', page);
        //   },
        // },
    };
    </script>

    <style scoped>
    header {
        width: 100%;
        height: 5rem;
        background-color: #11005c;
    }

    nav {
        height: 100%;
    }

    ul {
        list-style: none;
        margin: 0;
        padding: 0;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
    }

    li {
        margin: 0 2rem;
    }

    a {
        /* font: inherit; */
        text-decoration: none;
        background: transparent;
        border: 1px solid transparent;
        cursor: pointer;
        color: white;
        padding: 0.5rem 1.5rem;
        display: inline-block;
    }

    a:hover,
    a:active {
        color: #f1a80a;
        border-color: #f1a80a;
        background-color: #1a037e;
    }
    </style>
    ```
1. After rendering the elements on the page, we can notice that the selected anchor tag will have `vue-router` classes added automatically.
1. We therefore can use such feature to style the element when a link is selected.

## Styling Active Links
1. The selected anchor tag will add 2 classes [`router-link-exact-active` and `router-link-active`](https://router.vuejs.org/api/#v-slot-api-3-1-0). The main difference between those are that if we have nested `link` tags, all the related elements will be added with `router-link-active`, while the `link` that the user links to exactly (which is the current path) will be added with `router-link-exact-active`.
1. Therefore, we can just style the anchor tag that has such classes to apply specific styling when it's selected.
    ```css
    /* src/components/nav/TheNavigation.vue */
    header {
        width: 100%;
        height: 5rem;
        background-color: #11005c;
    }

    nav {
        height: 100%;
    }

    ul {
        list-style: none;
        margin: 0;
        padding: 0;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
    }

    li {
        margin: 0 2rem;
    }

    a {
        /* font: inherit; */
        text-decoration: none;
        background: transparent;
        border: 1px solid transparent;
        cursor: pointer;
        color: white;
        padding: 0.5rem 1.5rem;
        display: inline-block;
    }

    a:hover,
    a:active,
    a.router-link-active {
        color: #f1a80a;
        border-color: #f1a80a;
        background-color: #1a037e;
    }
    ```
1. In addition, both `router-link-active` and `router-link-exact-active` are default classes created by `vue-router`.
1. We can change the name for the class in `main.js` when setting up and configuring `vue-router`. 
    ```js
    // main.js
    import { createApp } from 'vue';
    import { createRouter, createWebHistory } from 'vue-router';

    import App from './App.vue';
    import TeamsList from './components/teams/TeamsList.vue';
    import UsersList from './components/users/UsersList.vue';

    const router = createRouter({
        history: createWebHistory(),
        routes: [
            { path: '/teams', component: TeamsList }, // our-domain.com/teams => TeamsList
            { path: '/users', component: UsersList },
        ],
        linkActiveClass: 'active', // change default from 'router-link-active'
        linkExactActiveClass: 'exact-active' // change default from 'router-link-exact-active'
    });

    const app = createApp(App);

    app.use(router);

    app.mount('#app');
    ```

## Programmatic Navigation
1. In some cases, we'd like to redirect the user to the other path after finishing certain tasks. For example, after a user finishes registration or adding new data, the app can direct the user to the other view to check the results.
1. We can use [`programmatic navigation`](https://router.vuejs.org/guide/essentials/navigation.html#programmatic-navigation) to redirect the user to certain route that is registered in `vue-router`.
1. Besides, there are other [router methods](https://router.vuejs.org/api/#router-instance-methods) such as `this.$router.forward()` and `this.$router.back()`.
    ```html
    <!-- src/components/users/UserList.vue -->
    <template>
        <!-- add a button to redirect the user as example -->
        <button @click="confirmInput">Confirm</button>
        <ul>
            <user-item
                v-for="user in users"
                :key="user.id"
                :name="user.fullName"
                :role="user.role"
            ></user-item>
        </ul>
    </template>

    <script>
    import UserItem from './UserItem.vue';

    export default {
        components: {
            UserItem,
        },
        inject: ['users'],
        methods: {
            confirmInput() {
                this.$router.push('/teams'); // direct to /teams route
                this.$router.forward(); // go next page 
                this.$router.back(); // go last page
            },
        },
    };
    </script>

    <style scoped>
    ul {
        list-style: none;
        margin: 2rem auto;
        max-width: 20rem;
        padding: 0;
    }
    </style>
    ```

## Passing Data with Route Params (Dynamic Segments)
1. In routes, we can set parameters similar to the system in `Express` as using [dynamic route segments or route matching](https://router.vuejs.org/guide/essentials/dynamic-matching.html#dynamic-route-matching).
1. Under the same main route, we can use a column to sepecify the parameters that we want to pass to the route and the component we want to render on the route.
1. Note that these dynamic route should be places as the last before any static route. Otherwise, the sub-route can be considered as a dynamic parameter when Vue checking the route.
    ```js
    // main.js
    import { createApp } from 'vue';
    import { createRouter, createWebHistory } from 'vue-router';

    import App from './App.vue';
    import TeamsList from './components/teams/TeamsList.vue';
    import UsersList from './components/users/UsersList.vue';
    import TeamMembers from './components/teams/TeamMembers.vue';

    const router = createRouter({
        history: createWebHistory(),
        routes: [
            { path: '/teams', component: TeamsList }, 
            { path: '/users', component: UsersList },
            { path: '/teams/new' }, // this route should be placed before dynamic route or 'new' will be considered as a 'teamId'
            { path: '/teams/:teamId', component: TeamMembers }, 
        ],
        linkActiveClass: 'active', 
        linkExactActiveClass: 'exact-active'
    });

    const app = createApp(App);

    app.use(router);

    app.mount('#app');
    ```
1. In this case, we can "inject" the data from `App.vue` for `users` and `teams`.
1. We then use Vue lifecycle method `created` to prepare the `data` before the App is rendered to the screen.
1. For dynamic routing, we can use a reserved property `$route` (not `$router`!) to retrieve the parameters. This property basically gives the value in the URL. Other properties such as `query`, `hash`, `path`, and `href` are also stored in `this.$route`.
1. After retrieving the `teamId`, we can use `.find` to match items (team and user) from the "injected data" to store in the `data` of the component.
1. Therefore, after the components rendered on the screen, all the data has been ready and show elements according to the given parameter.
    ```html
    <!-- src/components/teams/TeamMembers.vue -->
    <template>
        <section>
            <h2>{{ teamName }}</h2>
            <ul>
                <user-item
                    v-for="member in members"
                    :key="member.id"
                    :name="member.fullName"
                    :role="member.role"
                ></user-item>
            </ul>
        </section>
    </template>

    <script>
    import UserItem from '../users/UserItem.vue';

    export default {
        inject: ['users', 'teams'],
        components: {
            UserItem,
        },
        data() {
            return {
                teamName: '',
                members: [],
            };
        },
        created() {
            const teamId = this.$route.params.teamId;
            const selectedTeam = this.teams.find((team) => team.id === teamId);
            const members = selectedTeam.members;
            const selectedMembers = [];
            for (const member of members) {
                const selectedUser = this.users.find((user) => user.id === member);
                selectedMembers.push(selectedUser);
            }
            this.members = selectedMembers;
            this.teamName = selectedTeam.name;
        },
    };
    </script>

    <style scoped>
    section {
        margin: 2rem auto;
        max-width: 40rem;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.26);
        padding: 1rem;
        border-radius: 12px;
    }

    h2 {
        margin: 0.5rem 0;
    }

    ul {
        list-style: none;
        margin: 0;
        padding: 0;
    }
    </style>
    ```

## Navigation & Dynamic Paths
1. In `TeamsItem.vue`, we can replace the `<a>` with `router-link` tag. 
1. The `to` property can be bound as other HTML attributes that it can be bound to a variable by Vue.
1. In this case, we'd like to redirect the user to a list of members when the user selects one of the listed teams.
1. Therefore, we need the `teamId` passed from the parent component, which is `TeamsList.vue`. 
    ```html
    <!-- src/components/teams/TeamsList.vue -->
    <!-- passing team id  -->
    <template>
        <ul>
            <teams-item
                v-for="team in teams"
                :key="team.id"
                :id="team.id"
                :name="team.name"
                :member-count="team.members.length"
            ></teams-item>
        </ul>
    </template>
    ```
    ```html
    <!-- src/components/teams/TeamsItem.vue -->
    <template>
        <li>
            <h3>{{ name }}</h3>
            <div class="team-members">{{ memberCount }} Members</div>
            <router-link :to="teamMembersLink">View Members</router-link>
            <!-- <a href="#">View Members</a> -->
        </li>
    </template>

    <script>
    export default {
        props: ['id', 'name', 'memberCount'],
        computed: {
            teamMembersLink() {
                return '/teams/' + this.id;
            },
        },
    };
    </script>
    ```

## Updating Params Data with Watchers
1. If the user is on a page that using dynamic paramter, it doesn't work directly if we use `router-link` and point to the same route with the other parameter. For example, if we are on `/teams/t1` and would like to navigate to `/teams/t2` which both are handled by `teams/:teamId`.
1. However, though the components and elements rendering on the screen doesn't change, the route in the browser search bar **DOES** change.
1. This is a designed behavior of `vue-router` that it does change the route on the browser search bar but doesn't re-build or re-render the components on the screen.
1. In addition, the reserved property `this.$route` will always be updated when the route changes.
1. Therefore, we can use "watcher" with `watch` to keep listening to `this.$route` to check if it is changed.
1. However, this approach has a bug that when it changes to other route, it returns an error. It's not sure whether it's coming from Vue3 or `vue-router`. 
1. Nevertheless, we can use another approach by passing the id as `props` to the component which allows the component to be resuable at the other route or project.
    ```js
    // TeamMembers.vue
    import UserItem from '../users/UserItem.vue';

    export default {
        inject: ['users', 'teams'],
        components: {
            UserItem,
        },
        data() {
            return {
                teamName: '',
                members: [],
            };
        },
        methods: {
            loadTeamMembers(route) {
                const teamId = route.params.teamId;
                const selectedTeam = this.teams.find((team) => team.id === teamId);
                const members = selectedTeam.members;
                const selectedMembers = [];
                for (const member of members) {
                    const selectedUser = this.users.find(
                        (user) => user.id === member
                    );
                    selectedMembers.push(selectedUser);
                }
                this.members = selectedMembers;
                this.teamName = selectedTeam.name;
            },
        },
        created() {
            this.loadTeamMembers(this.$route);
        },
        watch: { // this cause an error 
            $route(newRoute) {
                this.loadTeamMembers(newRoute);
            },
        },
    };
    ```

## Passing Params as Props
1. We can pass the parameter as `props` to a component by configuring it in `main.js`. This prevents the issue as using `watch` to listen to `$route` changes.
1. In `TeamMembers.vue`, we can set `teamId` as `props` and use it as argument passing to methods. Besides, unifyin the source of data (as all sending from `props`) would be eaiser to manage than have different source of data. 
    ```js
    // src/components/teams/TeamMembers.vue
    import UserItem from '../users/UserItem.vue';

    export default {
        inject: ['users', 'teams'],
        props: ['teamId'],
        components: {
            UserItem,
        },
        data() {
            return {
                teamName: '',
                members: [],
            };
        },
        methods: {
            loadTeamMembers(teamId) {
                const selectedTeam = this.teams.find((team) => team.id === teamId);
                const members = selectedTeam.members;
                const selectedMembers = [];
                for (const member of members) {
                    const selectedUser = this.users.find(
                        (user) => user.id === member
                    );
                    selectedMembers.push(selectedUser);
                }
                this.members = selectedMembers;
                this.teamName = selectedTeam.name;
            },
        },
        created() {
            this.loadTeamMembers(this.teamId);
        },
        watch: {
            teamId(newId) {
                this.loadTeamMembers(newId);
            },
        },
    };
    ```
1. In `main.js`
    ```js
    // main.js
    import { createApp } from 'vue';
    import { createRouter, createWebHistory } from 'vue-router';

    import App from './App.vue';
    import TeamsList from './components/teams/TeamsList.vue';
    import UsersList from './components/users/UsersList.vue';
    import TeamMembers from './components/teams/TeamMembers.vue';

    const router = createRouter({
        history: createWebHistory(),
        routes: [
            { path: '/teams', component: TeamsList }, 
            { path: '/users', component: UsersList },
            // pass teamId to TeamMembers component as props
            { path: '/teams/:teamId', component: TeamMembers, props: true },
        ],
        linkActiveClass: 'active', 
    });

    const app = createApp(App);

    app.use(router);

    app.mount('#app');
    ```

## Redirecting & "Catch All" Routes
1. There are 3 ways to work around and redirect users according to the path. 
1. When configuring `createRouter` we can 
    1. Render the same component as a certain route.
    1. Use `redirect` and set the route to direct to as the key.
    1. Use `alias` property on a route and show the same component when the user visits the alias route.
1. The main difference between `redirect` and `alias` is that redirect actually changes the URL in the browser search bar, while `alias` just rendering the same component without changing the URL. 
1. Besides, we can use a [catch all route](https://next.router.vuejs.org/guide/migration/#removed-star-or-catch-all-routes) that handles the scenario that a user visits an un-existing route. 
1. Note that we could simply place an asterisk `*` rather than giving any params in previous verions. In new version, we must set a parameter with a custom regex. In this case, we use `.*` which simply means any character `.` that can be repeated at 0 or more times `*`.
    ```js
    // main.js
    import { createApp } from 'vue';
    import { createRouter, createWebHistory } from 'vue-router';

    import App from './App.vue';
    import TeamsList from './components/teams/TeamsList.vue';
    import UsersList from './components/users/UsersList.vue';
    import TeamMembers from './components/teams/TeamMembers.vue';

    const router = createRouter({
        history: createWebHistory(),
        routes: [
            { path: '/', redirect: '/teams' }, // redirect users to /teams
            { path: '/teams', component: TeamsList, alias: '/', }, // show TeamsList component without changing URL
            { path: '/users', component: UsersList },
            { path: '/teams/:teamId', component: TeamMembers, props: true },
            { path: '/:notFound(.*)', redirect: '/' }, // catch all unset routes
        ],
        linkActiveClass: 'active',
    });

    const app = createApp(App);

    app.use(router);

    app.mount('#app');
    ```
1. We can either redirect the user to a certain route or create a new component to show that the path isn't available. We create a new component `NotFound.vue` when catching the unset routes.
1. Note that the "**catch all**" should be set as the last item in the array to prevent catch other set routes by default. 
    ```vue
    <!-- src/components/nav/NotFound.vue -->
    <template>
        <h2>
            Page not found! Maybe view our
            <router-link to="/teams">Teams</router-link>?
        </h2>
    </template>
    ```
    ```js
    // main.js
    import { createApp } from 'vue';
    import { createRouter, createWebHistory } from 'vue-router';

    import App from './App.vue';
    import TeamsList from './components/teams/TeamsList.vue';
    import UsersList from './components/users/UsersList.vue';
    import TeamMembers from './components/teams/TeamMembers.vue';
    import notFound from './components/nav/NotFound.vue';

    const router = createRouter({
        history: createWebHistory(),
        routes: [
            { path: '/', redirect: '/teams' },
            { path: '/teams', component: TeamsList, alias: '/', }, // our-domain.com/teams => TeamsList
            { path: '/users', component: UsersList },
            { path: '/teams/:teamId', component: TeamMembers, props: true, }, // pass params as props
            { path: '/:notFound(.*)', component: notFound, },
        ],
        linkActiveClass: 'active', // change default from 'router-link-active'
    });

    const app = createApp(App);

    app.use(router);

    app.mount('#app');
    ```

## Using Nested Routes
1. In some cases, we'd like to have a [router nested](https://router.vuejs.org/guide/essentials/nested-routes.html) in the other router. 
1. In this case, we can show the list of memebers when the user selects one of the teams, while Vue app just show the list on the same page without redirect or rendering only the appointed component.
1. Thus, we modify `/teams/:teamId` path and nest it as one of `children` in `/teams`. By nesting the router, it's not a standalone route registered in the root `App.vue`.
1. Therefore, We will see nothing changes when we click on any of the teams in the list, while the URL in the browser search bar is changed by the router.
    ```js
    // main.js
    import { createApp } from 'vue';
    import { createRouter, createWebHistory } from 'vue-router';

    import App from './App.vue';
    import TeamsList from './components/teams/TeamsList.vue';
    import UsersList from './components/users/UsersList.vue';
    import TeamMembers from './components/teams/TeamMembers.vue';
    import notFound from './components/nav/NotFound.vue';

    const router = createRouter({
        history: createWebHistory(),
        routes: [
            { path: '/', redirect: '/teams' },
            {
                path: '/teams',
                component: TeamsList,
                children: [ // nest :teamId as a child 
                    { path: ':teamId', component: TeamMembers, props: true, }, 
                ],
            }, 
            { path: '/users', component: UsersList },
            { path: '/:notFound(.*)*', name: 'not-found', component: notFound, },
        ],
        linkActiveClass: 'active', 
    });

    const app = createApp(App);

    app.use(router);

    app.mount('#app');
    ```
1. Since the `:teamId` route is now nested in `/teams`, we need to modify the component rendered when users visit `/teams` which is `TeamsList.vue`.
    ```vue
    <!-- TeamsList.vue -->
    <template>
        <!-- add router-view to render TeamsItem.vue -->
        <router-view></router-view>
        <ul>
            <teams-item
                v-for="team in teams"
                :key="team.id"
                :id="team.id"
                :name="team.name"
                :member-count="team.members.length"
            ></teams-item>
        </ul>
    </template>
    ```
1. Note that the navigation on the top is now `router-link-active` rather than `router-link-exact-active`. We can check [Styling Active Links](#Styling-Active-Links) to check the difference.

## More Fun with Named Routes & Location Objects
1. We can have multiple layers of routes by nesting a router inside another route.
1. However, using multiple layers would have another issue that we have to configure the methods in each component to give dynamic routing setup for `:to` attribute with `router-link` to connect each route and components.
1. We can pass an object and give a property `path` to set the destination pointing to. 
1. However, using only `path` isn't different from giving a string for path on `:to`. We can use other properties, such as `name` to [name routes](https://router.vuejs.org/guide/essentials/named-routes.html#named-routes) and [`params`](https://router.vuejs.org/guide/essentials/named-routes.html#named-routes) to pass parameters.
1. The main benefit of using `name` to name routes is that we may change the paths and components to render on a specific route. By using `name`, we can have an alias pointing to the route, so it can change dynamically if we configure the registered route.
    ```html
    <!-- TeamsItem.vue -->
    <template>
        <li>
            <h3>{{ name }}</h3>
            <div class="team-members">{{ memberCount }} Members</div>
            <router-link :to="teamMembersLink">View Members</router-link>
        </li>
    </template>

    <script>
    export default {
        props: ['id', 'name', 'memberCount'],
        computed: {
            teamMembersLink() {
                // return '/teams/' + this.id;
                return {
                    name: 'team-members', // this gives path according to 'team-members'
                    params: {
                        teamId: this.id,
                    },
                    // path: '/teams' + this.id,
                };
            },
        },
    };
    </script>
    ```

## Using Query Params
1. When working with `router-link`, we can also pass query string as the params after the route in the URL. 
1. We can simply have a `query` property in the object passing to `:to` attribute in `router-link`.
    ```js
    // TeamsItem.vue
    export default {
        props: ['id', 'name', 'memberCount'],
        computed: {
            teamMembersLink() {
                // return '/teams/' + this.id;
                return {
                    name: 'team-members', // this gives path according to 'team-members'
                    params: {
                        teamId: this.id,
                    },
                    query: {
                        sort: 'asc',
                    }
                };
            },
        },
    };
    ```
1. In `TeamMembers.vue`, we can use `this.$route.query` to access the query string passing from the URL.
    ```js
    // TeamMembers.vue
    import UserItem from '../users/UserItem.vue';

    export default {
        inject: ['users', 'teams'],
        props: ['teamId'],
        components: {
            UserItem,
        },
        data() {
            return {
                teamName: '',
                members: [],
            };
        },
        methods: {
            loadTeamMembers(teamId) {
                const selectedTeam = this.teams.find((team) => team.id === teamId);
                const members = selectedTeam.members;
                const selectedMembers = [];
                for (const member of members) {
                    const selectedUser = this.users.find(
                        (user) => user.id === member
                    );
                    selectedMembers.push(selectedUser);
                }
                this.members = selectedMembers;
                this.teamName = selectedTeam.name;
            },
        },
        created() {
            this.loadTeamMembers(this.teamId);
            // check query strings
            console.log(this.$route.query);
        },
        watch: {
            teamId(newId) {
                this.loadTeamMembers(newId);
            },
        },
    };
    ```

## Rendering Multiple Routers with Named Router Views
1. We can set up multiple `router-view` in a component on [named routes](https://router.vuejs.org/guide/essentials/named-views.html#nested-named-views). Each `router-view` works similar to `slot` tag that we can have a unamed tag as the default one, and multiple named one with attribute `name`. 
1. For example, we can add a footer when users visit either `teams` or `users`. 
    ```vue
    <!-- App.vue -->
    <template>
        <the-navigation></the-navigation>
        <main>
            <router-view></router-view>
        </main>
        <footer>
            <!-- router-view for footer -->
            <router-view name="footer"></router-view>
        </footer>
    </template>
    ```
1. When configuring route, we can use plural `components` as property rather than singular `component`.
    ```js
    // main.js
    import TeamsFooter from './components/teams/TeamsFooter.vue';
    import UsersFooter from './components/users/UsersFooter.vue';

    const router = createRouter({
        history: createWebHistory(),
        routes: [
            { path: '/', redirect: '/teams' },
            {
                name: 'teams',
                path: '/teams',
                components: { // use multiple components
                    default: TeamsList,
                    footer: TeamsFooter,
                },
                children: [
                    { name: 'team-members', path: ':teamId', component: TeamMembers, props: true, }, 
                ],
            },
            {
                path: '/users',
                components: {
                    default: UsersList,
                    footer: UsersFooter,
                }
            },
            { path: '/:notFound(.*)*', name: 'not-found', component: notFound, },
        ],
        linkActiveClass: 'active', 
    });

    const app = createApp(App);

    app.use(router);
    ```

## Controlling Scroll Behavior
1. If some scenarios, we'd like to navigate the position of the user on a view. For example, when a user goes to another view and clicks backward to get back to the last page, we'd like to return to the position that the user used to read. 
1. In the `router`, can set `scrollBehavior` which is a method takes 3 arguments, `to`, `from`, and `savedPosition`.
1. `to` and `from` are similar to accessing `this.$route` to get the meta data when browsing a page. Each of them stores the data of where the user visited. 
1. `savedPosition` is an object that has `top` and `left` which represents the position of the user on the page. 
1. When the user firstly visit a route, `savedPosition` is `null` because the user hasn't been to anywhere. 
1. If the user navigates to other route, this property will store the "**position**" that the user was at and `from` will store the `path`. 
1. Therefore, we can use this behavior to setup the initial position when the user visits a route, such as on the top of the page. 
    ```js
    // main.js
    const router = createRouter({
        history: createWebHistory(),
        routes: [
            { path: '/', redirect: '/teams' },
            {
                name: 'teams',
                path: '/teams',
                components: {
                    default: TeamsList,
                    footer: TeamsFooter,
                },
                children: [
                    {
                        name: 'team-members',
                        path: ':teamId',
                        component: TeamMembers,
                        props: true,
                    },
                ],
            }, 
            {
                path: '/users',
                components: {
                    default: UsersList,
                    footer: UsersFooter,
                }
            },
            { path: '/:notFound(.*)*', name: 'not-found', component: notFound, },
        ],
        linkActiveClass: 'active',
        scrollBehavior(to, from, savedPosition) { // set the position when users visit a route
            if (savedPosition) return savedPosition;
            return {
                left: 0,
                top: 0,
            }
        },
    });
    ```

## Introducing Navigation Guards
1. This navigation guards can run code when the route changes. This can be useful to check if the user is authenticated or authorized or check unsaved data before the user navigates away. 
1. For example, on the `router` in `main.js`, we can check before navigating users to a route by using `router.beforeEach()`. 
1. The method takes a function as argument, which has 3 arguments, `to`, `from`, and `next`. We can setup conditions here as the middleware to ensure the condition fits to certain requirements (such as authentication) before navigating the user to the route.
1. Note we can pass Boolean `true` or `false` to `next()` to either allow or block the user from accessing the route. Besides, `next` takes `true` by default if we don't pass any arguments to it. 
1. In addition, we can redirect the user to certain path by giving `path`, `name`, and `params` that is similar to configure a named nested route when registering `router-link`. 
    ```js
    // main.js
    const router = createRouter({
        // router setup
    });

    router.beforeEach(function (to, from, next) {
        console.log('Global beforeEach');
        console.log(to, from);
        if (to.name === 'team-members') {
            next();
        } else {
            // this keeps navigating the user to /teams/t2
            next({ name: 'team-members', params: { teamId: 't2', }, }); 
        }
        // next();
    });
    ```
1. However, in this case, we just add the middleware and simply use `next()` to bypass it.

## Diving Deeper Into Navigation Guards
1. In the previous section, we set `beforeEach` globally that it works on every route in the App. However, we can actaully register navigation guards on a single route. 
1. For example, for `users`, we can add `beforeEnter` on this single route to execute code before entering the route.
    ```js
    // main.js 
    const router = createRouter({
        history: createWebHistory(),
        routes: [
            { path: '/', redirect: '/teams' },
            {
                name: 'teams',
                path: '/teams',
                components: {
                    default: TeamsList,
                    footer: TeamsFooter,
                },
                children: [
                    {
                        name: 'team-members',
                        path: ':teamId',
                        component: TeamMembers,
                        props: true, 
                    },
                ],
            },
            {
                path: '/users',
                components: {
                    default: UsersList,
                    footer: UsersFooter,
                },
                beforeEnter(to, from, next) { // beforeEnter navigation guard
                    console.log('users beforeEnter');
                    console.log(to, from);
                    next();
                }
            },
            { path: '/:notFound(.*)*', name: 'not-found', component: notFound, },
        ],
    });
    ```
1. We can not only add the navigation guard methods in root level in `main.js` but also in the component directly, which are [in-component guards](https://router.vuejs.org/guide/advanced/navigation-guards.html#in-component-guards).
1. The execution order is as the following
    1. [Global guards](https://router.vuejs.org/guide/advanced/navigation-guards.html#global-before-guards) registered on `router` object in `main.js`.
    1. [Pre-route guard](https://router.vuejs.org/guide/advanced/navigation-guards.html#per-route-guard) registered on specific route in `main.js`.
    1. [In-component guards](https://router.vuejs.org/guide/advanced/navigation-guards.html#in-component-guards) registered in a Vue component directly according to lifecycle.
        1. `beforeRouteEnter`
        1. `beforeRouteUpdate`
        1. `beforeRouteLeave`
1. In this case, we update `UserList.vue` with `beforeRouteEnter`. We can notice the execution order is from "global" and "pre-route" to "in-component".
    <img src="images/181-navigation_guard_execution_order.png">
1. In addition, we can use `beforeRouteUpdate` as the lifecycle method similar to `created` and `watch` to decide the data to render on the screen. 
1. However, using `props` and Vue lifecycle methods are still more flexible than using route navigation guards in this case.
    ```js
    // main.js
    import UserItem from '../users/UserItem.vue';

    export default {
        inject: ['users', 'teams'],
        props: ['teamId'],
        components: {
            UserItem,
        },
        data() {
            return {
                teamName: '',
                members: [],
            };
        },
        methods: {
            loadTeamMembers(teamId) {
                const selectedTeam = this.teams.find((team) => team.id === teamId);
                const members = selectedTeam.members;
                const selectedMembers = [];
                for (const member of members) {
                    const selectedUser = this.users.find(
                        (user) => user.id === member
                    );
                    selectedMembers.push(selectedUser);
                }
                this.members = selectedMembers;
                this.teamName = selectedTeam.name;
            },
        },
        created() {
            this.loadTeamMembers(this.teamId);
            console.log(this.$route.query);
        },
        beforeRouteUpdate(to, from, next) { // execute before elements rendered on the screen
            console.log('TeamMembers Cmp beforeRouteUpdate');
            console.log(to, from);
            // this.loadTeamMembers(to.params.teamId);
            next();
        },
        watch: {
            teamId(newId) {
                this.loadTeamMembers(newId);
            },
        },
    };
    ```

## The Global "afterEach" Guard
1. Global `afterEach` is similar to `beforeEach` but only executes after the user changes and "leaves" the route. Therefore, this method can't affect to the navigation directly. 
1. This can be useful to send analytic data such as user behavior and logs.
1. Since it doesn't affect directly to navigation, `afterEach` doesn't take `next` as the function to navigate the user.
    ```js
    // main.js
    router.afterEach(function (to, from) {
        // sending analytics data
        console.log('Global afterEach');
        console.log(to, from);
    });
    ```
## Beyond Entering: Route Leave Guards
1. We can use `beforeRouteLeave` to execute code before navigates out or leave the page. 
1. This can be useful if the view has a `form` or any `input` for user to insert. If the data hasn't been saved, we can prompt to the user to warn the user before leaving. 
1. In this case, we create `changesSvaed` in `data` as state to check if user has saved the data.
1. Create a new button with a method `saveChanges` to "save" the data on the page.
1. Note that `confirm` (and `prompt`) is a browser function similar to `alert` to prompt a small dialog box to noitce the user. 
    ```html
    <!-- UsersList.vue -->
    <template>
        <button @click="confirmInput">Confirm</button>
        <button @click="saveChanges">Save Changes</button>
        <ul>
            <user-item
                v-for="user in users"
                :key="user.id"
                :name="user.fullName"
                :role="user.role"
            ></user-item>
        </ul>
    </template>

    <script>
    import UserItem from './UserItem.vue';

    export default {
        components: {
            UserItem,
        },
        inject: ['users'],
        data() {
            return { // change if data is saved
                changesSaved: false,
            };
        },
        methods: {
            confirmInput() {
                this.$router.push('/teams');
            },
            saveChanges() {
                this.changesSaved = true;
            },
        },
        beforeRouteEnter(to, from, next) {
            console.log('UserList Cmp beforeRouteEnter');
            console.log(to, from);
            next();
        },
        beforeRouteLeave(to, from, next) { // use confirm to prompt and warn user before leaving the page
            console.log('UsersList Cmp beforeRouteLeave');
            console.log(to, from);

            if (this.changesSaved) {
                next();
            } else {
                const userWantsToLeave = confirm(
                    'Are you sure? You got unsaved changes'
                );
                next(userWantsToLeave);
            }
        },
        unmounted() {
            console.log('unmounted');
        },
    };
    </script>
    ```

## Utilizing Route Metadata
1. In every route registered in `main.js`, we can give a `meta` property, which is also known as [route meta fields](https://router.vuejs.org/guide/advanced/meta.html#route-meta-fields).
1. This property can be accessed from any `this.$route` or `to` and `from` in the route guard. 
1. For example, we can have a property `needsAuth` on `teams` path. In the global navigation guard, `beforeEach`, we can use `to.meta.needsAuth` to check whether the user is authenticated before navigating to the route. 
1. In this case, the console only prints the prompt when users visit routes in `teams`, while users don't need to be authenticated when navigating `users`.
    ```js
    // main.js
    const router = createRouter({
        history: createWebHistory(),
        routes: [
            { path: '/', redirect: '/teams' },
            {
                name: 'teams',
                path: '/teams',
                meta: { needsAuth: true }, // set meta data
                components: {
                    default: TeamsList,
                    footer: TeamsFooter,
                },
                children: [
                    {
                        name: 'team-members',
                        path: ':teamId',
                        component: TeamMembers,
                        props: true, 
                    },
                ],
            },
            {
                path: '/users',
                components: {
                    default: UsersList,
                    footer: UsersFooter,
                },
                beforeEnter(to, from, next) {
                    console.log('users beforeEnter');
                    console.log(to, from);
                    next();
                }
            },
            { path: '/:notFound(.*)*', name: 'not-found', component: notFound, },
        ],
        linkActiveClass: 'active', 
        scrollBehavior(to, from, savedPosition) {
            if (savedPosition) return savedPosition;
            return {
                left: 0,
                top: 0,
            }
        },
    });

    router.beforeEach(function (to, from, next) {
        console.log('Global beforeEach');
        console.log(to, from);
        if (to.meta.needsAuth) {
            console.log('Needs auth!');
            next();
        } else {
            next();
        }
    });
    ```

## Organizing Route Files
1. In larger scale projects or apps, we can separate components that actually renders a whole page from `components` directory to `pages`.
1. Therefore, for regular `components` directory, we only keep those are used in the other component or aren't standalone Vue component to differentiate their purpose. 
1. In addition, we can keep router configurations in a separated JavaScript file and import it with Javascript module system. Thus, we can keep our `main.js` neat and clean.
    ```js
    // main.js
    import { createApp } from 'vue';

    import App from './App.vue';
    import router from './router.js';

    const app = createApp(App);

    app.use(router);

    app.mount('#app');
    ```
    ```js
    // router.js
    import { createRouter, createWebHistory } from 'vue-router';
    import TeamsList from './pages/TeamsList.vue';
    import UsersList from './pages/UsersList.vue';
    import TeamMembers from './components/teams/TeamMembers.vue';
    import notFound from './pages/NotFound.vue';
    import TeamsFooter from './pages/TeamsFooter.vue';
    import UsersFooter from './pages/UsersFooter.vue';

    const router = createRouter({
        history: createWebHistory(),
        routes: [
            { path: '/', redirect: '/teams' },
            {
                name: 'teams',
                path: '/teams',
                meta: { needsAuth: true },
                components: {
                    default: TeamsList,
                    footer: TeamsFooter,
                },
                children: [
                    {
                        name: 'team-members',
                        path: ':teamId',
                        component: TeamMembers,
                        props: true, // pass params as props
                    },
                ],
            }, // our-domain.com/teams => TeamsList
            {
                path: '/users',
                components: {
                    default: UsersList,
                    footer: UsersFooter,
                },
                beforeEnter(to, from, next) {
                    console.log('users beforeEnter');
                    console.log(to, from);
                    next();
                }
            },
            { path: '/:notFound(.*)*', name: 'not-found', component: notFound, },
        ],
        linkActiveClass: 'active', // change default from 'router-link-active'
        scrollBehavior(to, from, savedPosition) {
            if (savedPosition) return savedPosition;
            return {
                left: 0,
                top: 0,
            }
        },
    });

    router.beforeEach(function (to, from, next) {
        console.log('Global beforeEach');
        console.log(to, from);
        if (to.meta.needsAuth) {
            console.log('Needs auth!');
            next();
        } else {
            next();
        }
        // if (to.name === 'team-members') {
        //     next();
        // } else {
        //     next({ name: 'team-members', params: { teamId: 't2', }, });
        // }
    });

    router.afterEach(function (to, from) {
        // sending analytics data
        console.log('Global afterEach');
        console.log(to, from);
    });

    export default router;
    ```



# Animations & Transitions
## Animation Basics & CSS Transitions
## Understanding CSS Animations
## Why is "Just CSS" Not Enough?
## Playing CSS Animations with Vue's Help
## Using the Transition Component
## CSS Animations with the Transition Component
## Using Custom CSS Class Names
## Example: Animating a Modal
## Transitioning Between Multiple Elements
## Using Transition Events
## Building JavaScript Transitions (instead of CSS)
## Disabling CSS Transitions
## Getting Started with Animated Lists
## Animating Lists with "transition-group"
## Animate List Item Movement
## Animate Route Changes



# Vuex
## What and why vuex?
1. When managing larger scale projects and apps, it's hard to manage and control all the data and state of each component building up the app. `vuex` can be considered a counterpart to `redux` when using `React` framework. 
    <img src="images/208-what_and_why_using_vuex.png">

## Creating & Using a Store
1. To use `vuex` with state management, we install `vuex` and import `createStore` function similar to `createApp` and `createRouter` to create a `store` object.
1. `createStore` takes an object as argument which has `state` method that manage the stored data and state. This syntax is very similar to using `data` in a vue component.
    ```js
    // main.js
    import { createStore } from 'vuex';

    const store = createStore({
        state() {
            return {};
        }
    })
    ```
1. In this case, we'd like to create a button which keeps adding one when users clicks on it. 
    ```html
    <!-- App.vue -->
    <template>
        <base-container title="Vuex">
            <h3>0</h3> <!-- this shows the counter -->
            <button>Add 1</button>
        </base-container>
    </template>

    <script>
        import BaseContainer from './components/BaseContainer.vue';

        export default {
        components: {
            BaseContainer,
        },
        };
    </script>
    ```
1. We therefore setup in `main.js` that we have a `counter` state in the `store` object.
    ```js
    // main.js
    import { createApp } from 'vue';
    import { createStore } from 'vuex';

    import App from './App.vue';


    const store = createStore({
        state() {
            return {
                counter: 0,
            }
        }
    });
    const app = createApp(App);

    app.use(store);

    app.mount('#app');
    ```
1. This `store` can be accessed globally with `this.$store` after we use `app.use(store)` to import the store object. This is similar to `this.$router` and `this.$route` after we use `vue-router`.
1. Note that we haven't connected the following code and variables, so it doesn't work yet.
    ```vue
    <!-- App.vue -->
    <template>
        <base-container title="Vuex">
        <h3> {{ $store.state.counter }} </h3>
            <button>Add 1</button>
        </base-container>
    </template>
    ```

## Connecting Components to State
1. We can either use the data stored in `$store.state` directly in the component or separate the item into the other component.
1. In this case, we give a method `addOne` and assign to the button which will add 1 to the state every time the button is clicked.
    ```html
    <!-- App.vue -->
    <template>
        <base-container title="Vuex">
            <the-counter></the-counter>
            <button @click="addOne">Add 1</button>
        </base-container>
    </template>

    <script>
    import BaseContainer from './components/BaseContainer.vue';
    import TheCounter from './components/TheCounter.vue';

    export default {
        components: {
            BaseContainer,
            TheCounter,
        },
        computed: {
            counter() {
                return this.$store.state.counter;
            }
        },
        methods: {
            addOne() {
                this.$store.state.counter++;
            }
        },
    };
    </script>
    ```
1. Besides, we can either pass the data from `$store.state` directly or use `computed` to listen to the changing of the `state`. 
    ```html
    <!-- TheCounter.vue -->
    <template>
        <h3>{{ counter }}</h3>
    </template>

    <script>
    export default {
        computed: {
            counter() {
                return this.$store.state.counter;
            }
        }
    }
    </script>
    ```

## Introducing Mutations - A Better Way of Changing Data
1. Though we can modify states in `store` directly, this isn't an ideal approach that it still can cause unexpeceted errors.
1. Therefore, we can use `mutations` feature as the middleware to modify the data stored in `$store`
1. In this case, we create another component, `ChangeCounter.vue` to modify the data in `store`. This approach can be beneficial that the state maybe used in multiple components.
    ```html
    <!-- TheCounter.vue -->
    <template>
        <h3>{{ counter }}</h3>
    </template>

    <script>
    export default {
        computed: {
            counter() {
                return this.$store.state.counter;
            }
        }
    }
    </script>
    ```
1. When modifying the formula or behavior of modifying the component, we may need to change the code in multiple components which may have further hustle on management.
1. In addition, we can have `mutations` property registered in `main.js` when creating the `store` by `vuex`.
1. In `mutations`, we can create methods which has `state` by default that we can access the data stored in vuex `store`.
    ```js
    // main.js
    const store = createStore({
        state() {
            return {
                counter: 0,
            }
        },
        mutations: {
            increment(state){
                state.counter++;
            },
        }
    });
    ```
1. In componenets, we can use `this.$store.commit()` which takes the name of the method in `mutations` to execute. Note that the argument is a String value which is the name of the method.
1. Therefore, for each component using the data in `store`, we can use `$store.commit` to modify the state.
    ```html
    <!-- ChangeCounter.vue -->
    <template>
        <button @click="addOne">Add 1</button>
    </template>

    <script>
    export default {
        methods: {
            addOne() {
                this.$store.commit('increment');
            },
        }
    }
    </script>
    ```

## Passing Data to Mutations with Payloads
1. In some scenarios, we'd like to pass a custom value to `mutations` rather using hardcorded value. 
    ```js
    // main.js
    const store = createStore({
        state() {
            return {
                counter: 0,
            }
        },
        mutations: {
            increment (state){
                state.counter++;
            },
            increase(state, payload) {
                state.counter += payload.value;
            },
        }
    });
    ```
    <img src="images/213-vuex_getters.png">
1. We either pass 2 arguments to `$store.commit()` or have it in [object-style commit](https://vuex.vuejs.org/guide/mutations.html#object-style-commit) that we pass a single object and pass the name of the method in `mutations` as the value with `type` property.
    ```js
    // App.vue
    export default {
        components: {
            BaseContainer,
            TheCounter,
            ChangeCounter,
        },
        computed: {
            counter() {
                return this.$store.state.counter;
            }
        },
        methods: {
            addOne() {
                //   this.$store.commit('increase', { value: 10,});
                this.$store.commit({ // object-style commit
                    type: 'increase', 
                    value: 10,
                });
            }
        },
    };
    ```

## Introducing Getters - A Better Way Of Getting Data
1. Besides retrieving data from `$store` directly, we can use `getters` to fetch data. The concept is similar to `mutaitons` that in some cases, we may need to calculate the data before using it in the components. It can be very tedious to update all the computations in the component that use such data.
1. Therefore, in `main.js`, we can register methods in `getters` in `store` which works similar to `mutations`. 
1. However, the method should return the value that the component will get. Note that the main difference between `getters` and `mutations` is that `getters` chagne and return a new data, while `mutations` chagne on the state directly.
1. Each getter method takes 2 arguments, `state` and `getters` which are the other registerd `getters`. 
    ```js
    // main.js
    const store = createStore({
        state() {
            return {
                counter: 0,
            }
        },
        mutations: {
            increment (state){
                state.counter++;
            },
            increase(state, payload) {
                state.counter += payload.value;
            },
        },
        getters: {
            finalCounter(state) { // return twice the value of the counter
                return state.counter * 2;
            }
        }
    });
    ```
1. In the component, we can simply refer to the method in the `getters` rather than calling it. This is similar to using `computed` in a Vue component. 
1. In the following example, the value rendered by `FavoriteValue.vue` uses `normalizedCounter` in `getters` which shows only numbers between 0 and 100. 
    ```html
    <!-- TheCounter.vue -->
    <template>
        <h3>{{ counter }}</h3>
        <p>We do more...</p>
    </template>

    <script>
    export default {
        computed: {
            counter() { // don't call the method directly as using computed methods 
                return this.$store.getters.finalCounter;
            }
        }
    }
    </script>
    ```
1. In the other scenatio, we can use values calculated from the other `getters`.
    ```js
    // main.js
    const store = createStore({
        state() {
            return {
                counter: 0,
            }
        },
        mutations: {
            increment (state){
                state.counter++;
            },
            increase(state, payload) {
                state.counter += payload.value;
            },
        },
        getters: {
            finalCounter(state) {
                return state.counter * 2;
            },
            normalizedCounter(_, getters) { // use values from the other getter
                const finalCounter = getters.finalCounter;
                if (finalCounter < 0) return 0;
                if (finalCounter > 100) return 100;
                return finalCounter;
            }
        }
    });
    ```
    ```html
    <!-- FavoriteValue.vue -->
    <template>
        <h3>{{ counter }}</h3>
        <p>We do more...</p>
    </template>

    <script>
    export default {
        computed: {
            counter() {
                return this.$store.getters.normalizedCounter;
            }
        }
    }
    </script>
    ```
1. Note that in some cases, we can use underscore `_` to replace the argument to indicate that it's only a placeholder. Otherwise, Vue would catch the unused argument and return an error.

## Running Async Code with Actions
1. In some cases, we need to fetch data from an endpoint or server via HTTP protocol. We need to use async JavaScript to fulfill the requirment. However, we can't use `mutations` with asynchornous code directly.
1. In `vuex`, we can use [`actions`](https://vuex.vuejs.org/guide/actions.html#dispatching-actions) and it's always a good practice to use `actions` to call `mutations` rather than using `mutations` directly. This is similar to use `redux-thunk` and create async action creator in `redux` for `React` app. 
1. In `main.js`, we can registers methods in `actions` as `mutations` and `getters`. In `actions`, we can declare methods which have the same name as those in `mutations`. This is a good approach, so know what methods we want to work with between `actions` and `mutations`.
1. Methods in `actions` has an argument `context`. We therefore can call `context.commit()` and give the name of the method in `mutations` we want to work with. 
1. This syntax works similar to call a mutation method in a component with `this.$store.commit('mutation_method', payload)` or `this.$store.commit({type: 'mutation_method', payload})`. 
1. In `actions`, we can run Async JavaScript.
    ```js
    // main.js
    const store = createStore({
        state() {
            return {
                counter: 0,
            }
        },
        mutations: {
            increment (state){
                state.counter++;
            },
            increase(state, payload) {
                state.counter += payload.value;
            },
        },
        actions: {
            increment(context) {
                setTimeout(function(){
                    context.commit('increment');
                }, 2000);
            }
        },
        getters: {
            finalCounter(state) {
                return state.counter * 2;
            },
            normalizedCounter(_, getters) {
                const finalCounter = getters.finalCounter;
                if (finalCounter < 0) return 0;
                if (finalCounter > 100) return 100;
                return finalCounter;
            }
        }
    });
    ```
1. To use `actions`, we can call `this.$store.dispatch()` in componenets which works as `this.$store.commit()` and it takes either 2 arguments with the name of the method as a string and an object for payload or an object with `type` property and orther keys we want to pass.
    ```js
    // App.vue
    export default {
        components: {
            BaseContainer,
            TheCounter,
            ChangeCounter,
            FavoriteValue,
        },
        computed: {
            counter() {
                return this.$store.state.counter;
            },
        },
        methods: {
            addOne() {
                //   this.$store.commit('increase', { value: 10,});
                this.$store.dispatch({ 
                    type: 'increase', 
                    value: 10,
                });
            }
        },
    };
    ```

## Understanding the Action "Context"
1. With `context`, we can access other properties and methods in the `store.` For example, we can check data with `context.state` and `context.getters`. 
1. We can even check other actions with `context.dispatch`. This can be useful as an middleware that we can call a HTTP request and check whether the response is desirable to show either success or failure message to users.
1. Note that we can use ES6 syntax to simplify the code and makes it cleaner.
    ```js
    const store = createStore({
        state: {
            counter: 0,
        },
        mutations: {
            increment(state){
                state.counter++;
            }
        },
        actions: {
            increment({commit}) {
                commit('increment');
            }
        }
    });
    ```

## Using Mapper Helpers
1. In case that we have multiple (and way many) `getters` or data to call from `vuex` we can use `mapGetters` function, which take an array with name in string of the methods that we want to use. We then can use the method in `template` directly. 
    ```html
    <!-- TheCounter.vue -->
    <template>
        <!-- use mapped getter method directly -->
        <h3>{{ finalCounter }}</h3>
    </template>

    <script>
    import { mapGetters } from 'vuex';

    export default {
        computed: {
            // counter() {
            //     return this.$store.getters.finalCounter;
            // }
            ...mapGetters(['finalCounter']),
        },
    }
    </script>
    ```
1. Not only `getters` but also `state`, `mutations`, and `actions` have mapping feature. All of them work in similar syntax and behavior.
1. To pass `payload`, we can pass an object to the method when using it directly.
1. Besides passing an array, we can give an object and change the name as the alias. Note that the name we want to use is the property/key and the value is the name of the method in stirng. 
    ```html
    <!-- ChangeCounter.vue -->
    <template>
        <button @click="inc">Add 2</button>
        <!-- pass a payload object -->
        <button @click="increase({value: 11})">Add 11</button>
    </template>

    <script>
    import {mapActions} from 'vuex';

    export default {
        methods: {
            // addOne() {
            //     this.$store.dispatch('increment');
            // },
            // ...mapActions(['increase', 'increment']),
            ...mapActions({
                inc: 'increment',
                increase: 'increase',
            }),
        }
    }
    </script>
    ```

## Example: Adding more state
1. In this case, we'd like to add a new section and state for login/logout.
1. We create new `state` in the `store` which is a Boolean value to indicate that if the user has logged in.
    ```js
    // main.js
    const store = createStore({
        state() {
            return {
                counter: 0,
                isLoggedIn: false, // check if the user has logged in
            }
        },
        mutations: {
            increment (state){
                state.counter++;
            },
            increase(state, payload) {
                state.counter += payload.value;
            },
            setAuth(state, payload){ // login/logout the user
                state.isLoggedIn = payload.isAuth;
            },
        },
        actions: {
            increment(context) {
                setTimeout(function(){
                    context.commit('increment');
                }, 2000);
            },
            increase(context, payload){
                console.log(context);
                context.commit('increase', payload);
            },
            login(context) { // action to login user
                context.commit('setAuth', {isAuth: true,});
            },
            logout(context) { // action to logout user
                context.commit('setAuth', {isAuth: false,});
            },
        },
        getters: {
            finalCounter(state) {
                return state.counter * 2;
            },
            normalizedCounter(_, getters) {
                const finalCounter = getters.finalCounter;
                if (finalCounter < 0) return 0;
                if (finalCounter > 100) return 100;
                return finalCounter;
            },
            userIsAuthenticated(state) { // check current login status
                return state.isLoggedIn;
            }
        }
    });
    ```
1. Show the function section only if the user has logged in. 
    ```html
    <!-- App.vue -->
    <template>
        <base-container v-if="isAuthed" title="Vuex">
            <the-counter></the-counter>
            <favorite-value></favorite-value>
            <button @click="addOne">Add 10</button>
            <change-counter></change-counter>
        </base-container>
        <base-container title="auth">
            <user-auth></user-auth>
        </base-container>
    </template>

    <script>
        import BaseContainer from './components/BaseContainer.vue';
        import TheCounter from './components/TheCounter.vue';
        import ChangeCounter from './components/ChangeCounter.vue';
        import FavoriteValue from './components/FavoriteValue.vue';
        import UserAuth from './components/UserAuth.vue';

        export default {
        components: {
            BaseContainer,
            TheCounter,
            ChangeCounter,
            FavoriteValue,
            UserAuth,
        },
        computed: {
            counter() {
                return this.$store.state.counter;
            },
            isAuthed() { // user login status
                return this.$store.getters.userIsAuthenticated;
            }
        },
        methods: {
            addOne() {
                this.$store.dispatch({ 
                    type: 'increase', 
                    value: 10,
                });
            }
        },
    };
    </script>
    ```
1. Section to allow user to either login or logout.
    ```html
    <!-- UserAuth.vue -->
    <template>
        <button v-if="!isAuth" @click="login">Login</button>
        <button v-else @click="logout">Logout</button>
    </template>

    <script>
    export default {
        methods: {
            login() {
                this.$store.dispatch('login');
            },
            logout() {
                this.$store.dispatch('logout');
            }
        },
        computed: {
            isAuth() {
                return this.$store.getters.userIsAuthenticated;
            }
        }
    }
    </script>
    ```

## Organizing your Store with Modules
1. When App/project goes large, we can have multiple states in the `store` which can be hard to manage.
1. `vuex` provide module system that we can split the states up into different modules.
1. For example, in the previous case, we can separate `counter` and `authentication` into different modules.
1. Note that `vuex` would return error any find no actions. This would be from naming issues or incorrect configuration during setup, such as mispelling for `actions`. 
    ```js
    // main.js
    const counterModule = {
        state() {
            return {
                counter: 0,
            }
        },
        mutations: {
            increment (state){
                state.counter++;
            },
            increase(state, payload) {
                state.counter += payload.value;
            },
        },
        actions: {
            increment(context) {
                setTimeout(function(){
                    context.commit('increment');
                }, 2000);
            },
            increase(context, payload){
                console.log(context);
                context.commit('increase', payload);
            },
        },
        getters: {
            finalCounter(state) {
                return state.counter * 2;
            },
            normalizedCounter(_, getters) {
                const finalCounter = getters.finalCounter;
                if (finalCounter < 0) return 0;
                if (finalCounter > 100) return 100;
                return finalCounter;
            },
        },
    }

    const store = createStore({
        modules: { // imoprt counterModule object with any property name
            number: counterModule
        },
        state() {
            return {
                isLoggedIn: false,
            }
        },
        mutations: {
            setAuth(state, payload){
                state.isLoggedIn = payload.isAuth;
            },
        },
        actions: {
            login(context) {
                context.commit('setAuth', {isAuth: true,});
            },
            logout(context) {
                context.commit('setAuth', {isAuth: false,});
            },
        },
        getters: {
            userIsAuthenticated(state) {
                return state.isLoggedIn;
            }
        }
    });
    ```

## Understanding Local Module State
1. Since we have separate `store` into modules, the `state` in `mutations` and `getters` can only access the local states which are in the same module. 
1. This would be confusing as the `states` in the store module can actually be accessed from as those store in the root.
1. For example, if we try use a getter in `counterModule` to check whether the user is authenticated which is store in the root `store`. It return nothing as the module can only access the local states in the same object.
    ```js
    // main.js
    const counterModule = {
        state() {
            return {
                counter: 0,
            }
        },
        mutations: {
            increment (state){
                state.counter++;
            },
            increase(state, payload) {
                console.log(state);
                state.counter += payload.value;
            },
        },
        actions: {
            increment(context) {
                setTimeout(function(){
                    context.commit('increment');
                }, 2000);
            },
            increase(context, payload){
                console.log(context);
                context.commit('increase', payload);
            },
        },
        getters: {
            testAuth(state) { // check isLoggedIn state from store root. This returns nothing
                return state.isLoggedIn;
            },
            finalCounter(state) {
                return state.counter * 2;
            },
            normalizedCounter(_, getters) {
                const finalCounter = getters.finalCounter;
                if (finalCounter < 0) return 0;
                if (finalCounter > 100) return 100;
                return finalCounter;
            },
        },
    }
    ```
1. In modules, we can pass 2 more arguments, [`rootState` and `rootGetters`](https://vuex.vuejs.org/guide/modules.html#module-local-state) to use the data in the root `store`.
    ```js
    // main.js
    const counterModule = {
        state() {
            return {
                counter: 0,
            }
        },
        mutations: {
            increment (state){
                state.counter++;
            },
            increase(state, payload) {
                state.counter += payload.value;
            },
        },
        actions: {
            increment(context) {
                setTimeout(function(){
                    context.commit('increment');
                }, 2000);
            },
            increase(context, payload){
                console.log(context);
                context.commit('increase', payload);
            },
        },
        getters: {
            testAuth(state, getters, rootState) {
                return rootState.isLoggedIn; // get state from root store
            },
            finalCounter(state) {
                return state.counter * 2;
            },
            normalizedCounter(_, getters) {
                const finalCounter = getters.finalCounter;
                if (finalCounter < 0) return 0;
                if (finalCounter > 100) return 100;
                return finalCounter;
            },
        },
    }
    ```

## Namespacing Modules
1. In some cases or larger projects, we may have name clashes for methods in `actions` and `getters`. This feature can be useful to manage large scale projects and prevent accidentally calling the actions and getters in the root store with similar or the same name.
1. We can use [`namespacing`](https://vuex.vuejs.org/guide/modules.html#namespacing) to keep modules separated. Therefore, we can't access the state and properties from a "**named**" module. To enable `namespacing` feature, we can simply add `namespaced:true` in the module object. 
    ```js
    // mani.js
    const counterModule = {
        namespaced: true, // enable namespacing
        state() {
            return {
                counter: 0,
            }
        },
        mutations: {
            increment (state){
                state.counter++;
            },
            increase(state, payload) {
                console.log(state);
                state.counter += payload.value;
            },
        },
        actions: {
            increment(context) {
                setTimeout(function(){
                    context.commit('increment');
                }, 2000);
            },
            increase(context, payload){
                console.log(context);
                context.commit('increase', payload);
            },
        },
        getters: {
            testAuth(state, getters, rootState) {
                return rootState.isLoggedIn;
            },
            finalCounter(state) {
                return state.counter * 2;
            },
            normalizedCounter(_, getters) {
                const finalCounter = getters.finalCounter;
                if (finalCounter < 0) return 0;
                if (finalCounter > 100) return 100;
                return finalCounter;
            },
        },
    }
    ```
1. Thus, to access states and methods in a module, we can check from the name of the module that we link to the root `store`.
    ```js
    const store = createStore({
        modules: {
            numbers: counterModule, // 'number' key is the name givin to counterModule. It only affects when namespacing: true is given in the module.
        }
    })
    ```
1. In the component to call the methods from the module, we change the syntax by accessing the named module from `getters`.
1. For `mapGetters` we pass the namespace as the first argument. 
    ```js
    // FavoriteValue.vue
    export default {
        computed: {
            counter() {
                return this.$store.getters['numbers/normalizedCounter'];
            }
        }
    }
    ```
    ```js
    // TheCounter.vue
    import { mapGetters } from 'vuex';
    export default {
        computed: {
            // counter() {
            //     return this.$store.getters.finalCounter;
            // }
            ...mapGetters('numbers', ['finalCounter']),
        },
    }
    ```
1. For `actions`, it's similar while in the object-like commit, we can just put the name space in the type property. 
    ```js
    // ChagneCounter.vue
    export default {
        methods: {
            ...mapActions('numbers', {
                inc: 'increment',
                increase: 'increase',
            }),
        }
    }
    ```
    ```js
    // App.vue
    export default {
        components: {
            BaseContainer,
            TheCounter,
            ChangeCounter,
            FavoriteValue,
            UserAuth,
        },
        computed: {
            counter() {
                return this.$store.state.counter;
            },
            isAuthed() {
                return this.$store.getters.userIsAuthenticated;
            }
        },
        methods: {
            addOne() {
                this.$store.dispatch({ 
                    type: 'numbers/increase', // add namespace as path
                    value: 10,
                });
            }
        },
    };
    ```

## Structuring Vuex Code & Files
1. Though we can create a new file `store.js` to keep all the related `store` and `states` code, it can go very large if many states need to be managed. 
1. We can create another directory `store` as the same level as `components`.
    1. `src`
    1. `src/store`
    1. `src/store/modules`
    1. `src/store/modules/counter`
1. We use JavaScript module system and have 4 files in each directory. However, in simple project, we can skip using complicated file structure.
    1. `index.js`
    1. `actions.js`
    1. `mutations.js`
    1. `getters.js`

## A Challenge
1. The target is to use `vuex` to manage the data in the shopping app which allows users to add items and sum the price up before checking out.

## Challenge Solution
1. We firstly create a `store` folder with `index.js` in `src`. In this case, since the app isn't complicated, we can have only `products.js` for `productModule` and `cart.js` for `cartModule`.
    ```js
    // src/store/index.js
    import { createStore } from 'vuex';

    import productModule from './modules/products.js';
    import cartModule from './modules/cart.js';

    const store = createStore({
        modules: {
            productModule,
            cartModule,
        },
        state() {
            return {
                isLoggedIn: false,
            }
        },
        getters: {
            loginStatus(state){
                return state.isLoggedIn;
            },
        },
        mutations: {
            setAuth(state, payload) {
                state.isLoggedIn = payload.isAuth;
            },
        },
        actions: {
            login(context) {
                context.commit('setAuth', {isAuth: true,});
            },
            logout(context) {
                context.commit('setAuth', {isAuth: false,});
            },
        }
    });

    export default store;
    ```
    ```js
    // src/store/modules/cart.js
    export default {
        state() {
            return {
                cart: { 
                    items: [], 
                    total: 0, 
                    qty: 0 
                },
            }
        },
        getters: {
            getCart(state) {
                return state.cart;
            },
            products() { return state.items },
            totalSum() { return state.total },
            quantity() { return state.qty },
        },
        mutations: {
            addToCart(state, payload) {
                const productInCartIndex = state.cart.items.findIndex(
                    (ci) => ci.productId === payload.id
                );
        
                if (productInCartIndex >= 0) {
                    state.cart.items[productInCartIndex].qty++;
                } else {
                    const newItem = {
                        productId: payload.id,
                        title: payload.title,
                        image: payload.image,
                        price: payload.price,
                        qty: 1,
                    };
                    state.cart.items.push(newItem);
                }
                state.cart.qty++;
                state.cart.total += payload.price;
            },
            removeFromCart(state, payload) {
                const productId = payload.prodId
                const productInCartIndex = state.cart.items.findIndex(
                    (cartItem) => cartItem.productId === productId
                );
                const prodData = state.cart.items[productInCartIndex];
                state.cart.items.splice(productInCartIndex, 1);
                state.cart.qty -= prodData.qty;
                state.cart.total -= prodData.price * prodData.qty;
            },
        },
        actions: {
            addToCart(context, payload) {
                context.commit('addToCart', payload);
            },
            removeFromCart(context, payload) {
                context.commit('removeFromCart', payload);
            },
        }
    }
    ```
1. Configure `main.js` to import correct JavaScript modules
    ```js
    // main.js
    import { createApp } from 'vue';

    import router from './router.js';
    import App from './App.vue';
    import store from './store/index.js';
    import BaseBadge from './components/ui/BaseBadge.vue';

    const app = createApp(App)

    app.use(router);

    app.use(store);

    app.component('base-badge', BaseBadge);

    app.mount('#app');
    ```
1. In addition, we'd like to use `namespacing` feature, so we set both `products.js` and `cart.js` with `namespaced: true`.
    ```js
    // src/store/modules/cart.js
    export default {
        namespaced: true,
        state() {
            return {
                cart: { 
                    items: [], 
                    total: 0, 
                    qty: 0 
                },
            }
        },
        getters: {
            getCart(state) {
                return state.cart;
            },
            products(state) { return state.cart.items },
            totalSum(state) { return state.cart.total },
            quantity(state) { return state.cart.qty },
        },
        mutations: {
            addToCart(state, payload) {
                const productInCartIndex = state.cart.items.findIndex(
                    (ci) => ci.productId === payload.id
                );
        
                if (productInCartIndex >= 0) {
                    state.cart.items[productInCartIndex].qty++;
                } else {
                    const newItem = {
                        productId: payload.id,
                        title: payload.title,
                        image: payload.image,
                        price: payload.price,
                        qty: 1,
                    };
                    state.cart.items.push(newItem);
                }
                state.cart.qty++;
                state.cart.total += payload.price;
            },
            removeFromCart(state, payload) {
                const productId = payload.prodId
                const productInCartIndex = state.cart.items.findIndex(
                    (cartItem) => cartItem.productId === productId
                );
                const prodData = state.cart.items[productInCartIndex];
                state.cart.items.splice(productInCartIndex, 1);
                state.cart.qty -= prodData.qty;
                state.cart.total -= prodData.price * prodData.qty;
            },
        },
        actions: {
            addToCart(context, payload) {
                context.commit('addToCart', payload);
            },
            removeFromCart(context, payload) {
                context.commit('removeFromCart', payload);
            },
        }
    }
    ```



# Main Project: "Find a Coach" Web App
## Planning the Project / Web App
## Planning the Data Requirements
## Planning the Layout / Components
## Registering Routes
## Adding Route Page Components
## Working on the Main Layout & Styling
## Wiring Up Pages
## Adding Vuex and Coach Data
## Working on the Coaches List and List Items
## Adding a Couple of Base Components (Base Card, Base Button, Base Badge)
## Building the Coach Detail Component
## Filtering Coaches
## Registering as a Coach: The Form
## Adding Coaches to Vuex
## Adding Form Validation
## Working on the Contact Form
## Storing Requests (Messages) with Vuex
## Outputting Incoming Requests (Messages)
## Filtering Requests for teh Active Coach
## Sending a PUT Http Request to Store Coach Data
## Fetching Coach Data (GET Http Request)
## Rendering a Loading Spinner
## Adding Http Error Handling
## Sending Coaching Requests Http Requests
## Caching Http Response Data
## Adding Route Transitions
## The "Not Found" Page & Summary



# Vue & Authentication
## How Authentication Works in Vue Apps (or any SPA)
1. In this case, we can generate a token on the server side and store on the client side. Every time the client (user) wants to request data from the server, the server (backend) will verify the attached token to ensure the request is verified and valid. 

## Locking / Protecting Backend Resources
1. We can set up rules for realtime database to decide how can we read and write the data. For further information, we can look up [Firebase Realtime Database Rules](https://firebase.google.com/docs/database/security).
    ```json
    // firebase rules for realtime database
    {
        "rules": {
            "coaches": {
            ".read": true,
            ".write": "auth != null"
        },
            "requests": {
            ".read": "auth != null",
            ".write": true
            }
        }
    }
    ```

## Adding an Authentication Page (Login & Signup)
1. In `pages` directory, we create a new folder `auth` and a new component `UserAuth.vue`.
    ```html
    <!-- UserAuth.vue -->
    <template>
        <base-card>
            <form action="">
                <div class="form-control">
                    <label for="email">Email</label>
                    <input type="email" name="email" id="email" required>
                </div>
                <div class="form-control">
                    <label for="password">Password</label>
                    <input type="password" name="password" id="password">
                </div>
                <base-button>Login</base-button>
                <base-button type="button" mode="flat">Signup instead</base-button>
            </form>
        </base-card>
    </template>

    <style scoped>
    form {
        margin: 1rem;
        padding: 1rem;
    }

    .form-control {
        margin: 0.5rem 0;
    }

    label {
        font-weight: bold;
        margin-bottom: 0.5rem;
        display: block;
    }

    input,
    textarea {
        display: block;
        width: 100%;
        font: inherit;
        border: 1px solid #ccc;
        padding: 0.15rem;
    }

    input:focus,
    textarea:focus {
        border-color: #3d008d;
        background-color: #faf6ff;
        outline: none;
    }
    </style>
    ```
1. We then register the new page component in `router.js`.
    ```js
    // router.js
    import UserAuth from './pages/auth/UserAuth.vue';

    const router = createRouter({
        history: createWebHistory(),
        routes: [
            { path: '/', redirect: '/coaches' },
            { path: '/coaches', component: CoachesList },
            {
            path: '/coaches/:id',
            component: CoachDetail,
            props: true,
            children: [
                { path: 'contact', component: ContactCoach } 
            ]
            },
            { path: '/register', component: CoachRegistation },
            { path: '/requests', component: RequestsReceived },
            { path: '/auth', component: UserAuth }, // register UserAuth
            { path: '/:notFound(.*)', component: NotFound }
        ]
    });
    ```
1. After configuring the component, we can set up the JavaScript to work on it. Besides, we allow users to either sign in or sign up by the form and can switch the function by a button. 
    ```html
    <!-- src/pages/auth/UserAuth.vue -->
    <template>
        <base-card>
            <form @submit.prevent="submitForm">
                <div class="form-control">
                    <label for="email">Email</label>
                    <input type="email" name="email" id="email" v-model.trim="email" required>
                </div>
                <div class="form-control">
                    <label for="password">Password</label>
                    <input type="password" name="password" id="password" v-model.trim="password" required>
                </div>
                <p v-if="!formIsValid">Please enter a valid email and password (must be at least 6 characters long).</p>
                <base-button>{{ submitButtonCaption }}</base-button>
                <base-button type="button" mode="flat" @click="switchAuthMode">{{ switchModeButtonCaption }}</base-button>
            </form>
        </base-card>
    </template>

    <script>
    export default {
        data() {
            return {
                email: '',
                password: '',
                formIsValid: true,
                mode: 'login',
            }
        },
        computed: {
            submitButtonCaption() {
                if (this.mode === 'login') {
                    return 'Login';
                }
                return 'Signup';
            }, 
            switchModeButtonCaption() {
                if (this.mode === 'login') {
                    return 'Signup instead';
                }
                return 'Login instead';
            },
        },
        methods: {
            submitForm() {
                this.formIsValid = true;
                if (!this.email || !this.includes('@') || this.password.length < 6) {
                    this.formIsValid = false;
                    return;
                }
                // send HTTP request...
            },
            switchAuthMode() {
                if (this.mode === 'login') {
                    this.mode = 'signup';
                } else {
                    this.mode = 'login';
                }
            }
        }
    }
    ```

## Preparing Vuex
1. In Firebase, we check in authentication on the left panel and enable email/password in sign-in method. Note that we just allow the first option to allow users to sign with in both email and password (not email link only).
1. In addition, we can look up Firebase Auth REST API and check its [sign up with email / password](https://firebase.google.com/docs/reference/rest/auth#section-create-email-password) and [sign in with email / password](https://firebase.google.com/docs/reference/rest/auth#section-sign-in-email-password). 
1. Note that Firebase Auth REST API for email / password only works if we enable the feature in Firebase project control.
1. In this case, we can use `vuex` to help use manage the data. Therefore, we create `auth` in modules under `store` directory.
1. We then import the new `authModule` into `index.js` in `store`. Besides, the `getters` and `state` are actually for authentication.
    ```js
    // src/store/index.js
    import { createStore } from 'vuex';

    import coachesModule from './modules/coaches/index.js';
    import requestsModule from './modules/requests/index.js';
    import authModule from './modules/auth/index.js';

    const store = createStore({
    modules: {
        coaches: coachesModule,
        requests: requestsModule,
        auth: authModule,
    },
    });

    export default store;
    ```
1. At this stage, we haven't set up `mutations` and `actions` of `auth` yet. However, to ensure Vue app works correctly we just export empty objects at this moment.
    ```js
    // src/store/modules/auth/index.js
    import mutations from './mutations.js';
    import actions from './actions.js';
    import getters from './getters.js';

    export default {
        state() {
            return {
            userId: 'c3'
            };
        },
        mutations,
        actions,
        getters,
    }

    // src/store/modules/auth/getters.js
    export default { 
        userId(state) {
            return state.userId;
        }
    }

    // src/store/modules/auth/mutations.js
    export default {}
    
    // src/store/modules/auth/actions.js
    export default {}
    ```

## Adding a "Signup" Action & Flow
1. We can set up `src/store/modules/auth/mutations.js`
    ```js
    // src/store/modules/auth/mutations.js
    export default {
        setUser(state, payload) {
            state.token = payload.token;
            state.userId = payload.userId;
            state.tokenExpiration = payload.tokenExpiration;
        }
    }
    ```
1. We then set up `src/store/modules/auth/action.js`
    ```js
    // src/store/modules/auth/actions.js
    export default {
        login() {},
        async signup(context, payload) {
            const response = await fetch('https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=AIzaSyASn8qrowxxFAy9tZ1glSMpZNr2Lx5JXvg', {
                method: 'post',
                body: JSON.stringify({
                    email: payload.email,
                    password: payload.password,
                    returnSecureToken: true,
                }),
            });

            const responseData = await response.json();
            if (!response.ok) {
                console.log(responseData);
                const error = new Error(responseData.message || 'Failed to authenticate');
                throw error;
            }

            console.log(responseData);
            context.commit('setUser', {
                token: responseData.idToken,
                userId: responseData.localId,
                tokenExpiration: responseData.expiresIn
            })
        }
    }
    ```
1. We then update `src/store/modules/auth/index.js`
    ```js
    // src/store/modules/auth/index.js
    import mutations from './mutations.js';
    import actions from './actions.js';
    import getters from './getters.js';

    export default {
        state() {
            return {
            userId: null,
            token: null,
            tokenExpiration: null,
            };
        },
        mutations,
        actions,
        getters,
    }
    ```
1. We then use `this.$store.dispatch('signup')` to call the action and register a new account.
    ```js
    // src/pages/auth/UserAuth.vue
    export default {
        data() {
            return {
                email: '',
                password: '',
                formIsValid: true,
                mode: 'login',
            }
        },
        computed: {
            submitButtonCaption() {
                if (this.mode === 'login') {
                    return 'Login';
                }
                return 'Signup';
            }, 
            switchModeButtonCaption() {
                if (this.mode === 'login') {
                    return 'Signup instead';
                }
                return 'Login instead';
            },
        },
        methods: {
            submitForm() {
                this.formIsValid = true;
                if (!this.email || !this.email.includes('@') || this.password.length < 6) {
                    this.formIsValid = false;
                    return;
                }
                
                if (this.mode === 'login') {
                    // ...
                } else {
                    this.$store.dispatch('signup', {
                        email: this.email,
                        password: this.password,
                    })
                }
            },
            switchAuthMode() {
                if (this.mode === 'login') {
                    this.mode = 'signup';
                } else {
                    this.mode = 'login';
                }
            }
        }
    }
    ```
1. If the request and sign up process works correctly, we will get response from Firebase with the desirable `userId`, `token` and `tokenExpiration`.
1. Besides, in `Users` in `Authentication` in the Firebase project, we can refresh and check the latest user which just registered.
1. If we try to register anthoer account with the same email, Firebase will return an error and notice that the email has been used. 

## Better UX: Loading Spinner & Error Handling
1. We add 2 more states in `UserAuth.vue` for `isLoading: false` and `error: null`.
1. We then turn `submitForm` into async function. As it should wait for authentication to be done before changing any state.
1. Create a loading spinner with `base-dialog` and get it controlled by `isLoading`.
    ```html
    <!-- src/pages/auth/UserAuth.vue -->
    <template>
        <base-dialog :show="!!error" title="An error occurred" @close="handleError">
            <p>{{ error }}</p>
        </base-dialog>
        <base-dialog :show="isLoading" title="authenticating..." fixed>
            <base-spinner></base-spinner>
        </base-dialog>
        <base-card>
            <form @submit.prevent="submitForm">
                <div class="form-control">
                    <label for="email">Email</label>
                    <input type="email" name="email" id="email" v-model.trim="email" required>
                </div>
                <div class="form-control">
                    <label for="password">Password</label>
                    <input type="password" name="password" id="password" v-model.trim="password" required>
                </div>
                <p v-if="!formIsValid">Please enter a valid email and password (must be at least 6 characters long).</p>
                <base-button>{{ submitButtonCaption }}</base-button>
                <base-button type="button" mode="flat" @click="switchAuthMode">{{ switchModeButtonCaption }}</base-button>
            </form>
        </base-card>
    </template>

    <script>
    export default {
        data() {
            return {
                email: '',
                password: '',
                formIsValid: true,
                mode: 'login',
                isLoading: false,
                error: null,
            }
        },
        computed: {
            submitButtonCaption() {
                if (this.mode === 'login') {
                    return 'Login';
                }
                return 'Signup';
            }, 
            switchModeButtonCaption() {
                if (this.mode === 'login') {
                    return 'Signup instead';
                }
                return 'Login instead';
            },
        },
        methods: {
            async submitForm() {
                this.formIsValid = true;
                if (!this.email || !this.email.includes('@') || this.password.length < 6) {
                    this.formIsValid = false;
                    return;
                }

                this.isLoading = true;

                try {
                    if (this.mode === 'login') {
                    // ...
                    } else {
                        await this.$store.dispatch('signup', {
                            email: this.email,
                            password: this.password,
                        });
                    }
                } catch (err) {
                    this.error = err.message || 'Failed to authenticate, Try later.';
                }

                this.isLoading = false;
            },
            switchAuthMode() {
                if (this.mode === 'login') {
                    this.mode = 'signup';
                } else {
                    this.mode = 'login';
                }
            },
            handleError() {
                this.error = null;
            }
        }
    }
    </script>
    ```

## Adding a "Login" Action & Flow
1. To allow users to login, we can configure the method and endpoint in `src/store/modules/auth/actions.js`. This is similar to the sign up flow for a user.
    ```js
    // actions.js
    export default {
        async login(context, payload) {
            const response = await fetch('https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=AIzaSyASn8qrowxxFAy9tZ1glSMpZNr2Lx5JXvg', {
                method: 'post',
                body: JSON.stringify({
                    email: payload.email,
                    password: payload.password,
                    returnSecureToken: true,
                }),
            });

            const responseData = await response.json();
            if (!response.ok) {
                console.log(responseData);
                const error = new Error(responseData.message || 'Failed to authenticate. Check your login data');
                throw error;
            }

            console.log(responseData);
            context.commit('setUser', {
                token: responseData.idToken,
                userId: responseData.localId,
                tokenExpiration: responseData.expiresIn
            });
        },
        async signup(context, payload) {
            const response = await fetch('https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=AIzaSyASn8qrowxxFAy9tZ1glSMpZNr2Lx5JXvg', {
                method: 'post',
                body: JSON.stringify({
                    email: payload.email,
                    password: payload.password,
                    returnSecureToken: true,
                }),
            });

            const responseData = await response.json();
            if (!response.ok) {
                console.log(responseData);
                const error = new Error(responseData.message || 'Failed to authenticate. Check your login data');
                throw error;
            }

            console.log(responseData);
            context.commit('setUser', {
                token: responseData.idToken,
                userId: responseData.localId,
                tokenExpiration: responseData.expiresIn
            });
        }
    }
    ```
1. We then update the method `submitForm` in `UserAuth.vue` for the login condition. 
    ```js
    // UserAuth.vue
    export default {
        data() {
            return {
                email: '',
                password: '',
                formIsValid: true,
                mode: 'login',
                isLoading: false,
                error: null,
            }
        },
        computed: {
            submitButtonCaption() {
                if (this.mode === 'login') {
                    return 'Login';
                }
                return 'Signup';
            }, 
            switchModeButtonCaption() {
                if (this.mode === 'login') {
                    return 'Signup instead';
                }
                return 'Login instead';
            },
        },
        methods: {
            async submitForm() {
                this.formIsValid = true;
                if (!this.email || !this.email.includes('@') || this.password.length < 6) {
                    this.formIsValid = false;
                    return;
                }

                this.isLoading = true;

                const actionPayload = {
                    email: this.email,
                    password: this.password,
                };

                try {
                    if (this.mode === 'login') { // login path
                        await this.$store.dispatch('login', actionPayload)
                    } else {
                        await this.$store.dispatch('signup', actionPayload);
                    }
                } catch (err) {
                    this.error = err.message || 'Failed to authenticate, Try later.';
                }

                this.isLoading = false;
            },
            switchAuthMode() {
                if (this.mode === 'login') {
                    this.mode = 'signup';
                } else {
                    this.mode = 'login';
                }
            },
            handleError() {
                this.error = null;
            }
        }
    }
    ```

## Attaching the Token to Outgoing Requests
## Updating the UI Based on Auth State
## Adding a "Logout" Action & Flow
## Authentication & Routing (incl. Navigation Guards)
## Adding "Auto Login"
## Adding "Auto Logout"



# Optimizing & Deploying Vue Apps
## What To Deploy?
## Optimization: Using Asynchronous Components
## Building the Project For Production
## Deploying a Vue App



# The Composition API - Replacing the Options API
## Which Problem Does the Composition API Solve?
## Replacing "data" with "refs"
## Building "reactive" Objects
## Reactivity: A Deep Dive
## Replacing "methods" with regular Functions
## Replacing "Computed Properties" with the "computed" Function
## Two-Way-Binding and the Composition API
## Working with Watchers
## A First Summary
## How to Use Templates Refs
## Components, Props, & The Composition API
## Emitting Custom Events
## Working with Provide / Inject
## Lifecycle Hooks in the Composition API
## Migrating from Options API to Composition API - an Example Project
## Migrating a First Component
## Migrating a Big Component
## Migrating the Remaining Components
## Routing, Params & The Composition API
## The Route & Router Objects and the Composition API
## Using Vuex with the Composition API



# Reusing Funcitonality: Mixins & Custom Composition Functions
## Reusability Concepts
## Using Mixins
## Understanding Mixin Merging
## Global Mixins
## Disadvantages of Mixins
## Custom Hooks / Composables & The Composition API
## More Custom Composition Functions
## Why Hookks / Composables Beat Mixins
## Example: Creating a "Search" Hook
## Custom Hooks Gotchas
## More Thoughts on Custom Hooks / Composables
## Example: A Custom "Sort" Hook