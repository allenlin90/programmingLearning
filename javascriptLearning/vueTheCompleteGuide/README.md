Start learning on 2021/04/19
Finished on 

Course Link [https://www.udemy.com/course/vuejs-2-the-complete-guide/](https://www.udemy.com/course/vuejs-2-the-complete-guide/)
---
1. [Basics and Core Concepts - DOM Interaction with Vue](#Basics-and-Core-Concepts---DOM-Interaction-with-Vue)
    1. [Creating and Connecting Vue App Instance](#Creating-and-Connecting-Vue-App-Instance)
    1. [Interpolation and Data Binding](#Interpolation-and-Data-Binding)
    1. [Binding Attributes with the "v-bind" Directive](#Binding-Attributes-with-the-"v-bind"-Directive)
    1. [Understanding "methods" in Vue Apps](Understanding-"methods"-in-Vue-Apps)
    1. [Working with Data inside of a Vue App](#Working-with-Data-inside-of-a-Vue-App)
    1. [Outputting Raw HTML Content with v-html](#Outputting-Raw-HTML-Content-with-v-html)
    1. [A First Summary](#A-First-Summary)
    1. [Understanding the Event Binding](#Understanding-the-Event-Binding)
    1. [Events and Methods](#Events-and-Methods)
    1. [Working with Event Arguments](#Working-with-Event-Arguments)
    1. [Using the Native Event Object](#Using-the-Native-Event-Object)
    1. [Exploring Event Modifiers](#Exploring-Event-Modifiers)
    1. [Locking Content with v-once](#Locking-Content-with-v-once)
    1. [Data Binding + Event Binding = Two-way Binding](#Data-Binding-+-Event-Binding-=-Two-way-Binding)
    1. [Methods used for Data Bindings: How it works](#Methods-used-for-Data-Bindings:-How-it-works)
    1. [Introducing Computed Properties](#Introducing-Computed-Properties)
    1. [Working with Watchers](#Working-with-Watchers)
    1. [Methods vs Computed Properties vs Watchers](#Methods-vs-Computed-Properties-vs-Watchers)
    1. [v-bind and v-on Shorthands](#v-bind-and-v-on-Shorthands)
    1. [Dynamic Styling with Inline Styles](#Dynamic-Styling-with-Inline-Styles)
    1. [Adding CSS Classes Dynamically](#Adding-CSS-Classes-Dynamically)
    1. [Classes & Computed Properties](#Classes-&-Computed-Properties)
    1. [Dynamic Classes: Array Syntax](#Dynamic-Classes:-Array-Syntax)
1. [Redenering Conditional Content & Lists](#Redenering-Conditional-Content-&-Lists)
    1. [Understanding the Problem](#Understanding-the-Problem)
    1. [Rendering Content Conditionally](#Rendering-Content-Conditionally)
    1. [v-if, v-else and v-else-if](#v-if,-v-else-and-v-else-if)
    1. [Using v-show Instead of v-if](#Using-v-show-Instead-of-v-if)
    1. [Rendering Lists of Data](#Rendering-Lists-of-Data)
    1. [Diving Deeper Into v-for](#Diving-Deeper-Into-v-for)
    1. [Removing List Items](#Removing-List-Items)
    1. [Lists & Keys](#Lists-&-Keys)
1. [Coure Project: The Monster Slayer Game](#Coure-Project:-The-Monster-Slayer-Game)
    1. [Project Setup & First Methods](#Project-Setup-&-First-Methods)
    1. [Updating the Health Bars](#Updating-the-Health-Bars)
    1. [Adding a "Special Attack"](#Adding-a-"Special-Attack")
    1. [Adding a "Heal" Functionality](#Adding-a-"Heal"-Functionality)
    1. [Adding a "Game Over" Screen](#Adding-a-"Game-Over"-Screen)
    1. [Finshing the Core Functionality](#Finshing-the-Core-Functionality)
    1. [Adding a Battle Log](#Adding-a-Battle-Log)
1. [Vue: Behind the Scenes](#Vue:-Behind-the-Scenes)
    1. [An Introduction to Vue's Reactivity](#An-Introduction-to-Vue's-Reactivity)
    1. [Vue Reactivity: A Deep Dive](#Vue-Reactivity:-A-Deep-Dive)
    1. [One App vs Multiple Apps](#One-App-vs-Multiple-Apps)
    1. [Understanding Templates](#Understanding-Templates)
    1. [Working with Refs](#Working-with-Refs)
    1. [How Vue Updates the DOM](#How-Vue-Updates-the-DOM)
    1. [Vue App Lifecycle - Theory](#Vue-App-Lifecycle---Theory)
    1. [Vue App Lifecycle - Practice](#Vue-App-Lifecycle---Practice)
1. [Introducing Components](#Introducing-Components)
    1. [Understanding the Problem](#Understanding-the-Problem)
    1. [Introducing Components](#Introducing-Components)
    1. [The Why: Building Complex User Interfaces With Components](#The-Why:-Building-Complex-User-Interfaces-With-Components)
1. [Moving to a Better Development SEtup & Workflow with the Vue CLI](#Moving-to-a-Better-Development-SEtup-&-Workflow-with-the-Vue-CLI)
    1. [Why We Need A Development Server](#Why-We-Need-A-Development-Server)
    1. [WHy We Want A Better Developer Experience](#WHy-We-Want-A-Better-Developer-Experience)
    1. [Installing & Using the Vue CLI](#Installing-&-Using-the-Vue-CLI)
    1. [Inspecting the Created Project](#Inspecting-the-Created-Project)
    1. [Inspecting the Vue Code & ".vue" Files](#Inspecting-the-Vue-Code-&-".vue"-Files)
    1. [Adding the "Vutur" Extension to VS Code](#Adding-the-"Vutur"-Extension-to-VS-Code)
    1. [More on ".vue" Files](#More-on-".vue"-Files)
    1. [A New Vue Project](#A-New-Vue-Project)
    1. [Creating a Basic Vue App](#Creating-a-Basic-Vue-App)
    1. [Adding a Component](#Adding-a-Component)
    1. [Adding Styling](#Adding-Styling)
1. [Component Communication](#Component-Communication)
    1. [Introducing "Props" (Parent => Child Communication)](#Introducing-"Props"-(Parent-=>-Child-Communication))
    1. [Prop Behavior & Changing Props](#Prop-Behavior-&-Changing-Props)
    1. [Validating Props](#Validating-Props)
    1. [Working with Dynamic Props Values](#Working-with-Dynamic-Props-Values)
    1. [Emitting Custom Events (Child => Parent Communication)](#Emitting-Custom-Events-(Child-=>-Parent-Communication))
    1. [Defining & Validating Custom Events](#Defining-&-Validating-Custom-Events)
    1. [Prop / Event Fallthrough & Binding All Props](#Prop-/-Event-Fallthrough-&-Binding-All-Props)
    1. [Demo: Adding Components & Connecting Them](#Demo:-Adding-Components-&-Connecting-Them)
    1. [Demo: Adding More Component Communication](#Demo:-Adding-More-Component-Communication)
    1. [A Potential Problem](#A-Potential-Problem)
    1. [Provide + Inject To The Rescue](#Provide-+-Inject-To-The-Rescue)
    1. [Provide + Inject for Functions / Methods](#Provide-+-Inject-for-Functions-/-Methods)
    1. [Provide + Inject vs Props & Custom Events](#Provide-+-Inject-vs-Props-&-Custom-Events)
1. [Diving Deeper Into Components](#Diving-Deeper-Into-Components)
    1. [Project Setup](#Project-Setup)
    1. [Global vs Local Components](#Global-vs-Local-Components)
    1. [Scoped Styles](#Scoped-Styles)
    1. [Introducing Slots](#Introducing-Slots)
    1. [Named Slots](#Named-Slots)
    1. [Slot Styles & Compilation](#Slot-Styles-&-Compilation)
    1. [More on Slots](#More-on-Slots)
    1. [Scoped Slots](#Scoped-Slots)
    1. [Dynamic Components](#Dynamic-Components)
    1. [Keeping Dynamic Components Alive](#Keeping-Dynamic-Components-Alive)
    1. [Applying What We Know & A Problem](#Applying-What-We-Know-&-A-Problem)
    1. [Teleporting Elements](#Teleporting-Elements)
    1. [Working with Fragments](#Working-with-Fragments)
    1. [The Vue Style Guide](#The-Vue-Style-Guide)
    1. [Moving to a Different Folder Structure](#Moving-to-a-Different-Folder-Structure)
1. [Course Projct: The Learning Resources App](#Course-Projct:-The-Learning-Resources-App)
    1. [Setup & First Steps](#Setup-&-First-Steps)
    1. [First Components & Props](#First-Components-&-Props)
    1. [Styling and More Components](#Styling-and-More-Components)
    1. [Header & BaseCard Components](#Header-&-BaseCard-Components)
    1. [Adding a Base Button](#Adding-a-Base-Button)
    1. [Dynamic Components & Attribute Fallthrough](#Dynamic-Components-&-Attribute-Fallthrough)
    1. [Adding & Styling Tabs](#Adding-&-Styling-Tabs)
    1. [Adding a Form](#Adding-a-Form)
    1. [Fetching User Input](#Fetching-User-Input)
    1. [Adding a Modal Dialog](#Adding-a-Modal-Dialog)
    1. [Deleting Items](#Deleting-Items)
    1. [Adding "Teleport"](#Adding-"Teleport")
1. [Form](#Form)
    1. [v-model & Inputs](#v-model-&-Inputs)
    1. [Working with v-model Modifiers and Numbers](#Working-with-v-model-Modifiers-and-Numbers)
    1. [v-model and Dropdowns](#v-model-and-Dropdowns)
    1. [Using v-model with Checkboxes & Radiobuttons](#Using-v-model-with-Checkboxes-&-Radiobuttons)
    1. [Adding Basic Form Validation](#Adding-Basic-Form-Validation)
    1. [Building a Custom Control Component](#Building-a-Custom-Control-Component)
    1. [Using v-model on Custom Components](#Using-v-model-on-Custom-Components)
1. [Sending Http Requests](#Sending-Http-Requests)
    1. [Starting App & Why we need a Backend](#Starting-App-&-Why-we-need-a-Backend)
    1. [Adding a Backend](#Adding-a-Backend)
    1. [How to (Not) Send Http Requests](#How-to-(Not)-Send-Http-Requests)
    1. [Sending a POST Request to Store Data](#Sending-a-POST-Request-to-Store-Data)
    1. [Getting Data (GET Request) & Transforming Response Data](#Getting-Data-(GET-Request)-&-Transforming-Response-Data)
    1. [Loading Data When a Component Mounts](#Loading-Data-When-a-Component-Mounts)
    1. [Showing a "Loading..." Message](#Showing-a-"Loading..."-Message)
    1. [Handling the "No Data" State](#Handling-the-"No-Data"-State)
    1. [Handling Technical / Browser-side Errors](#Handling-Technical-/-Browser-side-Errors)
    1. [Handling Error Responses](#Handling-Error-Responses)
1. [Routing: Building "Multi-Page" Single Page Application](#Routing:-Building-"Multi-Page"-Single-Page-Application)
    1. [What & Why?](#What-&-Why?)
    1. [Routing Setup](#Routing-Setup)
    1. [Registering & Rendering Routes](#Registering-&-Rendering-Routes)
    1. [Navigating with router-link](#Navigating-with-router-link)
    1. [Styling Active Links](#Styling-Active-Links)
    1. [Programmatic Navigation](#Programmatic-Navigation)
    1. [Passing Data with Route Params (Dynamic Segments)](#Passing-Data-with-Route-Params-(Dynamic-Segments))
    1. [Navigation & Dynamic Paths](#Navigation-&-Dynamic-Paths)
    1. [A Vue Bug](#A-Vue-Bug)
    1. [Updating Params Data with Watchers](#Updating-Params-Data-with-Watchers)
    1. [Passing Params as Props](#Passing-Params-as-Props)
    1. [Redirecting & "Catch All" Routes](#Redirecting-&-"Catch-All"-Routes)
    1. [Using Nested Routes](#Using-Nested-Routes)
    1. [More Fun with Named Routes & Location Objects](#More-Fun-with-Named-Routes-&-Location-Objects)
    1. [Using Query Params](#Using-Query-Params)
    1. [Rendering Multiple Routers with Named Router Views](#Rendering-Multiple-Routers-with-Named-Router-Views)
    1. [Controlling Scroll Behavior](#Controlling-Scroll-Behavior)
    1. [Introducing Navigation Guards](#Introducing-Navigation-Guards)
    1. [Diving Deeper Into Navigation Guards](#Diving-Deeper-Into-Navigation-Guards)
    1. [The Global "afterEach" Guard](#The-Global-"afterEach"-Guard)
    1. [Beyond Entering: Route Leave Guards](#Beyond-Entering:-Route-Leave-Guards)
    1. [Utilizing Route Metadata](#Utilizing-Route-Metadata)
    1. [Organizing Route Files](#Organizing-Route-Files)
1. [Animations & Transitions](#Animations-&-Transitions)
    1. [Animation Basics & CSS Transitions](#Animation-Basics-&-CSS-Transitions)
    1. [Understanding CSS Animations](#Understanding-CSS-Animations)
    1. [Why is "Just CSS" Not Enough?](#Why-is-"Just-CSS"-Not-Enough?)
    1. [Playing CSS Animations with Vue's Help](#Playing-CSS-Animations-with-Vue's-Help)
    1. [Using the Transition Component](#Using-the-Transition-Component)
    1. [CSS Animations with the Transition Component](#CSS-Animations-with-the-Transition-Component)
    1. [Using Custom CSS Class Names](#Using-Custom-CSS-Class-Names)
    1. [Example: Animating a Modal](#Example:-Animating-a-Modal)
    1. [Transitioning Between Multiple Elements](#Transitioning-Between-Multiple-Elements)
    1. [Using Transition Events](#Using-Transition-Events)
    1. [Building JavaScript Transitions (instead of CSS)](#Building-JavaScript-Transitions-(instead-of-CSS))
    1. [Disabling CSS Transitions](#Disabling-CSS-Transitions)
    1. [Getting Started with Animated Lists](#Getting-Started-with-Animated-Lists)
    1. [Animating Lists with "transition-group"](#Animating-Lists-with-"transition-group")
    1. [Animate List Item Movement](#Animate-List-Item-Movement)
    1. [Animate Route Changes](#Animate-Route-Changes)
1. [Vuex](#Vuex)
    1. [What & Why?](#What-&-Why?)
    1. [Creating & Using a Store](#Creating-&-Using-a-Store)
    1. [Connecting Components to State](#Connecting-Components-to-State)
    1. [Introducing Mutations - A Better Way of Changing Data](#Introducing-Mutations---A-Better-Way-of-Changing-Data)
    1. [Passing Data to Mutations with Payloads](#Passing-Data-to-Mutations-with-Payloads)
    1. [Introducing Getters - A Better Way Of Getting Data](#Introducing-Getters---A-Better-Way-Of-Getting-Data)
    1. [Running Async Code with Actions](#Running-Async-Code-with-Actions)
    1. [Understanding the Action "Context"](#Understanding-the-Action-"Context")
    1. [Using Mapper Helpers](#Using-Mapper-Helpers)
    1. [Organizing your Store with Modules](#Organizing-your-Store-with-Modules)
    1. [Understanding Local Module State](#Understanding-Local-Module-State)
    1. [Namespacing Modules](#Namespacing-Modules)
    1. [Structuring Vuex Code & Files](#Structuring-Vuex-Code-&-Files)
1. [Main Project: "Find a Coach" Web App](#Main-Project:-"Find-a-Coach"-Web-App)
    1. [Planning the Project / Web App](#Planning-the-Project-/-Web-App)
    1. [Planning the Data Requirements](#Planning-the-Data-Requirements)
    1. [Planning the Layout / Components](#Planning-the-Layout-/-Components)
    1. [Registering Routes](#Registering-Routes)
    1. [Adding Route Page Components](#Adding-Route-Page-Components)
    1. [Working on the Main Layout & Styling](#Working-on-the-Main-Layout-&-Styling)
    1. [Wiring Up Pages](#Wiring-Up-Pages)
    1. [Adding Vuex and Coach Data](#Adding-Vuex-and-Coach-Data)
    1. [Working on the Coaches List and List Items](#Working-on-the-Coaches-List-and-List-Items)
    1. [Adding a Couple of Base Components (Base Card, Base Button, Base Badge)](#Adding-a-Couple-of-Base-Components-(Base-Card,-Base-Button,-Base-Badge))
    1. [Building the Coach Detail Component](#Building-the-Coach-Detail-Component)
    1. [Filtering Coaches](#Filtering-Coaches)
    1. [Registering as a Coach: The Form](#Registering-as-a-Coach:-The-Form)
    1. [Adding Coaches to Vuex](#Adding-Coaches-to-Vuex)
    1. [Adding Form Validation](#Adding-Form-Validation)
    1. [Working on the Contact Form](#Working-on-the-Contact-Form)
    1. [Storing Requests (Messages) with Vuex](#Storing-Requests-(Messages)-with-Vuex)
    1. [Outputting Incoming Requests (Messages)](#Outputting-Incoming-Requests-(Messages))
    1. [Filtering Requests for teh Active Coach](#Filtering-Requests-for-teh-Active-Coach)
    1. [Sending a PUT Http Request to Store Coach Data](#Sending-a-PUT-Http-Request-to-Store-Coach-Data)
    1. [Fetching Coach Data (GET Http Request)](#Fetching-Coach-Data-(GET-Http-Request))
    1. [Rendering a Loading Spinner](#Rendering-a-Loading-Spinner)
    1. [Adding Http Error Handling](#Adding-Http-Error-Handling)
    1. [Sending Coaching Requests Http Requests](#Sending-Coaching-Requests-Http-Requests)
    1. [Caching Http Response Data](#Caching-Http-Response-Data)
    1. [Adding Route Transitions](#Adding-Route-Transitions)
    1. [The "Not Found" Page & Summary](#The-"Not-Found"-Page-&-Summary)
1. [Vue & Authentication](#Vue-&-Authentication)
    1. [How Authentication Works in Vue Apps (or any SPA)](#How-Authentication-Works-in-Vue-Apps-(or-any-SPA))
    1. [Locking / Protecting Backend Resources](#Locking-/-Protecting-Backend-Resources)
    1. [Adding an Authentication Page (Login & Signup)](#Adding-an-Authentication-Page-(Login-&-Signup))
    1. [Preparing Vuex](#Preparing-Vuex)
    1. [Adding a "Signup" Action & Flow](#Adding-a-"Signup"-Action-&-Flow)
    1. [Better UX: Loading Spinner & Error Handling](#Better-UX:-Loading-Spinner-&-Error-Handling)
    1. [Adding a "Login" Action & Flow](#Adding-a-"Login"-Action-&-Flow)
    1. [Attaching the Token to Outgoing Requests](#Attaching-the-Token-to-Outgoing-Requests)
    1. [Updating the UI Based on Auth State](#Updating-the-UI-Based-on-Auth-State)
    1. [Adding a "Logout" Action & Flow](#Adding-a-"Logout"-Action-&-Flow)
    1. [Authentication & Routing (incl. Navigation Guards)](#Authentication-&-Routing-(incl.-Navigation-Guards))
    1. [Adding "Auto Login"](#Adding-"Auto-Login")
    1. [Adding "Auto Logout"](#Adding-"Auto-Logout")
1. [Optimizing & Deploying Vue Apps](#Optimizing-&-Deploying-Vue-Apps)
    1. [What To Deploy?](#What-To-Deploy?)
    1. [Optimization: Using Asynchronous Components](#Optimization:-Using-Asynchronous-Components)
    1. [Building the Project For Production](#Building-the-Project-For-Production)
    1. [Deploying a Vue App](#Deploying-a-Vue-App)
1. [The Composition API - Replacing the Options API](#The-Composition-API---Replacing-the-Options-API)
    1. [Which Problem Does the Composition API Solve?](#Which-Problem-Does-the-Composition-API-Solve?)
    1. [Replacing "data" with "refs"](#Replacing-"data"-with-"refs")
    1. [Building "reactive" Objects](#Building-"reactive"-Objects)
    1. [Reactivity: A Deep Dive](#Reactivity:-A-Deep-Dive)
    1. [Replacing "methods" with regular Functions](#Replacing-"methods"-with-regular-Functions)
    1. [Replacing "Computed Properties" with the "computed" Function](#Replacing-"Computed-Properties"-with-the-"computed"-Function)
    1. [Two-Way-Binding and the Composition API](#Two-Way-Binding-and-the-Composition-API)
    1. [Working with Watchers](#Working-with-Watchers)
    1. [A First Summary](#A-First-Summary)
    1. [How to Use Templates Refs](#How-to-Use-Templates-Refs)
    1. [Components, Props, & The Composition API](#Components,-Props,-&-The-Composition-API)
    1. [Emitting Custom Events](#Emitting-Custom-Events)
    1. [Working with Provide / Inject](#Working-with-Provide-/-Inject)
    1. [Lifecycle Hooks in the Composition API](#Lifecycle-Hooks-in-the-Composition-API)
    1. [Migrating from Options API to Composition API - an Example Project](#Migrating-from-Options-API-to-Composition-API---an-Example-Project)
    1. [Migrating a First Component](#Migrating-a-First-Component)
    1. [Migrating a Big Component](#Migrating-a-Big-Component)
    1. [Migrating the Remaining Components](#Migrating-the-Remaining-Components)
    1. [Routing, Params & The Composition API](#Routing,-Params-&-The-Composition-API)
    1. [The Route & Router Objects and the Composition API](#The-Route-&-Router-Objects-and-the-Composition-API)
    1. [Using Vuex with the Composition API](#Using-Vuex-with-the-Composition-API)
1. [Reusing Funcitonality: Mixins & Custom Composition Functions](#Reusing-Funcitonality:-Mixins-&-Custom-Composition-Functions)
    1. [Reusability Concepts](#Reusability-Concepts)
    1. [Using Mixins](#Using-Mixins)
    1. [Understanding Mixin Merging](#Understanding-Mixin-Merging)
    1. [Global Mixins](#Global-Mixins)
    1. [Disadvantages of Mixins](#Disadvantages-of-Mixins)
    1. [Custom Hooks / Composables & The Composition API](#Custom-Hooks-/-Composables-&-The-Composition-API)
    1. [More Custom Composition Functions](#More-Custom-Composition-Functions)
    1. [Why Hookks / Composables Beat Mixins](#Why-Hookks-/-Composables-Beat-Mixins)
    1. [Example: Creating a "Search" Hook](#Example:-Creating-a-"Search"-Hook)
    1. [Custom Hooks Gotchas](#Custom-Hooks-Gotchas)
    1. [More Thoughts on Custom Hooks / Composables](#More-Thoughts-on-Custom-Hooks-/-Composables)
    1. [Example: A Custom "Sort" Hook](#Example:-A-Custom-"Sort"-Hook)
---

# Basics and Core Concepts - DOM Interaction with Vue
## Creating and Connecting Vue App Instance
1. Starter HTML
    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Vue Basics</title>
        <link
        href="https://fonts.googleapis.com/css2?family=Jost:wght@400;700&display=swap"
        rel="stylesheet"
        />
        <link rel="stylesheet" href="styles.css" />
        <script src="https://unpkg.com/vue@next" defer></script>
        <script src="app.js" defer></script>
    </head>
    <body>
        <header>
        <h1>Vue Course Goals</h1>
        </header>
        <section id="user-goal">
        <h2>My Course Goal</h2>
        <p></p>
        </section>
    </body>
    </html>
    ```
1. To use Vue, we need to specify in HTML that which element will be handled by Vue. 
1. To initiate Vue, we should create a `Vue App` in the JS code, and it requires an JavaScript object which as `data` method as a must property.
1. The `data` method should always return another JavaScript object which may have arbitrarily named keys. 
1. We then can use `app.mount()` selector to manipulate the HTML element on the page.
    ```js
    // Vue framework should be imported
    const app = Vue.createApp({
        data() { // must return an object
            return { // key/value pair can be named arbitrarily
                courseGoal: 'Finish the course and learn Vue!'
            };
        }
    });

    app.mount('#user-goal');
    ```

## Interpolation and Data Binding
1. We can put the placeholder in HTML which should match to the property that we want to return its value in `data` method.
1. Note that we can have multiple placeholder in the component, and all of them will show the same value. 
    1. HTML 
        ```html
        <section id="user-goal">
            <h2>My Course Goal</h2>
            <p>{{ courseGoal }}</p> <!-- placeholder for Vue selector to identify-->
            <p>{{ goalList }}</p>
        </section>
        ```
    1. JavaScript
        ```js
        const app = Vue.createApp({
            data() { // must return an object
                return { // key/value pair can be named arbitrarily
                    courseGoal: 'Finish the course and learn Vue!',
                    goalList: ['task 1', 'task 2']
                };
            }
        });

        app.mount('#user-goal');
        ```
1. If we use the placeholder somewhere else that isn't selected by Vue selector, it will be regular string in HTML.
1. The Vue component can not only show text but also other primitive values or JavaScript array or object, which will be stringified as JSON to be shown as string.
    <img src="images/14-placeholder_vue_component.png">

## Binding Attributes with the "v-bind" Directive
1. Though we can use double curly braces as placeholder for Vue component to import values, it doesn't work with attributes on HTML tags such as `href` of an anchor tag.
1. We then can use `v-bind` on the attribute to indicate that the HTML attribute should work with Vue. Note that the placeholder for the attribute doesn't require double curly braces.
    ```html
    <section id="user-goal">
        <h2>My Course Goal</h2>
        <p>{{ courseGoal }}</p>
        <p>Learn more <a v-bind:href="vueLink">about Vue</a>.</p>
    </section>
    ```

## Understanding "methods" in Vue Apps
1. To execute function as the event handler on a HTML element, we need to firstly set up the `methods` in the Vue app. 
1. Besides `data`, we can pass another property `methods` which holds the callback functions to handle events on HTML elements.
1. Note that the methods we want to call by Vue app should be declared in `methods` property only. Both `data` and `methods` are reserved properties for a Vue app.
    ```js
    const app = Vue.createApp({
        data() { 
            return { 
                courseGoal: 'Finish the course and learn Vue!',
                vueLink: 'https://vuejs.org/'
            };
        },
        methods: {
            outputGoal() {
                const randomNumber = Math.random();
                if (randomNumber < 0.5) {
                    return 'Learn Vue!';
                } else {
                    return 'Master Vue!';
                }
            }
        }
    });
    ```
1. The placeholder with double curly braces in HTML can take not only variables from Vue but also JavaScript expressions. Note that it doesn't take complicated structure such as an IF/ELSE statement, but it works with ternary operator.
    ```html
    <section id="user-goal">
        <h2>My Course Goal</h2>
        <p>{{ outputGoal() }}</p>
        <p>{{ 1 + 1 }}</p>
        <p>{{ (1 + 1) > 1 ? true : false }}</p>
        <p>Learn more <a v-bind:href="vueLink">about Vue</a>.</p>
    </section>
    ```

## Working with Data inside of a Vue App
1. Vue provides a shorthand that we can access the properties and methods on the Vue app object directly by `this` (which is not intuitive for regular Javascript objects!). 
1. The feature just turn all the properties which `data` method can return and methods in `methods` globally accessible with `this`.
    ```js
    const app = Vue.createApp({
        data() { // must return an object
            return { // key/value pair can be named arbitrarily
                courseGoalA: 'Finish the course and learn Vue!',
                courseGoalB: 'Master Vue and build amazing apps!',
                vueLink: 'https://vuejs.org/'
            };
        },
        methods: {
            outputGoal() {
                const randomNumber = Math.random();
                if (randomNumber < 0.5) {
                    return this.courseGoalA;
                } else {
                    return this.courseGoalB;
                }
            }
        }
    });

    app.mount('#user-goal');
    ```

## Outputting Raw HTML Content with v-html
1. Regular interpolation (double curly braces) can only handle the value as text (similar to `innerText` property on a HTML DOM).
    ```js
    const app = Vue.createApp({
        data() {
            return {
                courseGoalA: 'Finish the course and learn Vue!',
                courseGoalB: '<h2>Master Vue and build amazing apps!</h2>',
                vueLink: 'https://vuejs.org/'
            };
        },
        methods: {
            outputGoal() {
                const randomNumber = Math.random();
                if (randomNumber < 0.5) {
                    return this.courseGoalA;
                } else {
                    return this.courseGoalB;
                }
            }
        }
    });
    ```
1. For the case, we can use `v-html` as an attribute on the HTML element that we want to inject raw HTML tags as using `innerHTML`. The syntax is similar to `v-bind` which works with regular HTML attributes.
    ```html
    <section id="user-goal">
        <h2>My Course Goal</h2>
        <p v-html="outputGoal"></p>
        <p>Learn more <a v-bind:href="vueLink">about Vue</a>.</p>
    </section>
    ```
1. However, it's not recommended to have this method as default because it may be vulnerable to XXS attacks.

## A First Summary
1. If we use `app = Vue.createApp()` and select a specific HTML element by `app.mount()`, Vue can work on the selected HTML element and its child, while won't affect other HTML elements on the page. 
1. To manipulate the elements, we can use "**interpolation**" (double curly braces) and `v-html` and `v-bind` on HTML attributes. 

## Understanding the Event Binding
1. To add event listener on Vue component, we can use `v-on` and follow with a column and the event, such as `v-on:click`, on the HTML element.
1. We then can add Javascript expression or give the event handler function for the element.
1. However, `v-on` takes either expression or function and can't execution as a code block. For example, if we try to put `console.log('Hello World')` to execute direclty, browser will return an error.
    ```html
    <!-- HTML -->
    <section id="events">
        <h2>Events in Action</h2>
        <button v-on:click="increase">Add</button>
        <button v-on:click="counter--">Reduce</button>
        <p>Result: {{ counter }}</p>
    </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                counter: 0,
            };
        },
        methods: {
            increase() {
                this.counter++;
            }
        }
    });

    app.mount('#events');
    ```

## Events and Methods
1. Though we can give expressions and logic at `v-on` in HTML element, it's not a good practice, as we should separate the purpose of each type of file.
1. Therefore, we can create a function in the JavaScript. This function should be a method in the Vue component. 
1. Besides, we can either pass the method or call the method in `v-on` directly. Either approach will work, as Vue can handle the conditions.
    ```html
    <!-- HTML -->
    <section id="events">
        <h2>Events in Action</h2>
        <!-- either assign method execute it will work as long as it's a method in the Vue component -->
        <button v-on:click="add()">Add</button>
        <button v-on:click="reduce">Reduce</button>button>
        <p>Result: {{ counter }}</p>
    </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                counter: 0,
            };
        },
        methods: {
            add() {
                this.counter += 1;
            },
            reduce() {
                this.counter -= 1;
            }
        }
    });

    app.mount('#events');
    ```

## Working with Event Arguments
1. Since `v-on` can either take an expression or assign a method, we can pass an argument(s) to the method. 
1. Therefore, we can make our method dynamic and change the ouptut or feature on the Vue component very fast.
    ```html
    <!-- HTML -->
    <section id="events">
        <h2>Events in Action</h2>
        <!-- Pass arguments to methods -->
        <button v-on:click="add(5)">Add</button>
        <button v-on:click="reduce(5)">Reduce</button>
        <p>Result: {{ counter }}</p>
    </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
            counter: 0,
            };
        },
        methods: { // both methods take arguments
            add(num) {
            this.counter += num;
            },
            reduce(num) {
            this.counter -= num;
            }
        }
    });

    app.mount('#events');
    ```

## Using the Native Event Object
1. In regular cases, browser will provide an `event` argument to the callback function of the event handler. 
1. If we don't pass any argument to the event handler callback function it takes `event` argument by default. Therefore, we can use it as regular JavaScript to check the properties in the event object. 
1. In this case, we can track on the value that the user gives to an `input` tag by checking the `input` event. 
    ```html
    <!-- HTML -->
    <section id="events">
        <h2>Events in Action</h2>
        <input type="text" v-on:input="setName">
        <p>Your Name : {{ name }}</p>
    </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                name: '',
            };
        },
        methods: {
            setName(event) {
                this.name = event.target.value;
            },
        }
    });

    app.mount('#events');
    ```
1. Besides, only the part that is handled by Vue is changed in the HTML document. This feature is similar to vanilla JavaScript to manipulate DOM. 
1. In addition, we can still pass an argument(s) to the event handler but keep the event object. Vue provides a reserved variable `$event` that we can pass to the function for `v-on` as well. 
    ```html
    <!-- HTML -->
    <input type="text" v-on:input="setName($event, 'Another Name')">
    ```
    ```js
    // JavaScript
    const app = Vue.creatApp({
        data() {
            return {
                name: '',
            },
        },
        methods: {
            setName(event, secondName) {
                return event.target.value + ' ' + secondName;
            } 
        }
    })
    ```

## Exploring Event Modifiers
1. In regular `form` element, the browser will return when the user submits the form as it send a HTTP request to server.
1. However, we'd like to prevent the default feature and stop browser from reloading the page.
1. We can use regular way in JavaScript to use `event.preventDefault()` in the callback funciton to prevent the browser reloads the page. 
    ```html
    <!-- HTML -->
    <section id="events">
        <h2>Events in Action</h2>
        <form v-on:submit="submitForm" action="">
        <input type="text" name="" id="">
        <button type="submit">Sign Up</button>
        </form>
    </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        methods: {
            submitForm(event) {
                event.preventDefault();
            }
        }
    })
    ```
1. On the other hand, we can use Vue feature to modify the event on HTML directly. In this case, we can simply modify Vue event handler with `v-on:submit.prevent`.
    ```html
    <!-- HTML -->
    <section id="events">
        <h2>Events in Action</h2>
        <form v-on:submit.prevent="submitForm" action="">
        <input type="text" name="" id="">
        <button type="submit">Sign Up</button>
        </form>
    </section>
    ```
1. Besides `.prevent`, we can do `click.right` for click event to change default from left click on a mouse to right click, so the function will only be trigerred when the user right clicks on the element.
    ```html
    <!-- HTML -->
    <section id="events">
        <h2>Events in Action</h2>
        <button v-on:click="add(5)">Add</button>
        <button v-on:click.right="reduce(5)">Reduce</button>
        <p>Result: {{ counter }}</p>
    </section>
    ```
1. In this case, we'd like to manipulate the input to the `p` tag below only when the user hits <kbd>enter</kbd>. Note that we can use `v-on` to apply multiple event handler on the same element. 
    ```html
    <!-- HTML -->
    <section id="events">
        <input 
            type="text" name="" id=""
            v-on:input="setName($event, 'Last Name')" 
            v-on:keyup.enter="confirmInput">
        <p>Your Name : {{ confirmedName }}</p>
    </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                name: '',
                confirmedName: '',
            }
        },
        methods: {
            setName(event, secondName) {
                this.name = event.target.value + ' ' + secondName
            }, 
            confirmInput() {
                this.confirmedName = this.name;
            }
        }
    })
    ```
1. We may refer to [event modifier](https://vuejs.org/v2/guide/events.html#Event-Modifiers) from Vue officail document.

## Locking Content with v-once
1. In some scenarios, we'd like the Vue controled element to render interpolation at once when the app initiates. 
1. We can give `v-once` to indicate that the interpolation in the element will only happen when the element is firstly rendered. This is similar to the lifecycle method in React to prevent the element being re-rendered when the value or state changes.
    ```html
    <!-- HTML -->
    <section id="events">
        <h2>Events in Action</h2>
        <button v-on:click="add($event, 5)">Add</button>
        <button v-on:click="reduce($event, 5)">Reduce</button>
        <p v-once>Starting Counter: {{ counter }}</p>
        <p>Result: {{ counter }}</p>
    </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                counter: 10,
            }
        },
        methods: {
            add(event, num = 1) {
                return counter += num;
            }

            reduce(event, num = 1) {
                return counter -= num;
            }
        }
    })
    ```

## Data Binding + Event Binding = Two-way Binding
1. If we'd like to reset the data when the user clicks a button on the page, we can use regular JavaScript with DOM selector to handle the event.
1. We can use `v-bind` to bind the attribute with Vue interpolation. In this case, we bind the `value` attribute of the `input` tag with `name` interpolation of Vue. Therefore, when the user clicks on the "reset" button, not only the content in the `p` tag below will be removed but also the data in the `input` tag.
    ```html
    <!-- HTML -->
    <section id="events">
        <h2>Events in Action</h2>
        <button v-on:click="add(10)">Add 10</button>
        <button v-on:click="reduce(5)">Subtract 5</button>
        <p>Result: {{ counter }}</p>
        <button v-on:click="resetInput">Reset Input</button>
        <!-- bind value -->
        <input type="text" v-bind:value="name" v-on:input="setName($event, 'lastName')">
        <!-- use v-model for two-way binding -->
        <input type="text" v-model="name">
        <p>Your Name: {{ name }}</p>
    </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                name: '',
            }
        }, 
        methods: {
            setName(event, lastName){
                this.name = event.target.value;
            },
            resetInput(){
                this.name = '';
            }
        }
    });

    app.mount('#events');
    ```
1. On the other hand, we can use [`v-model`](https://vuejs.org/v2/guide/forms.html#Basic-Usage) which is a syntax sugar to use on `input`, `textarea`, and `select`. In this case, we don't event need to setup methods on the element to realize render the data. 
    ```html
    <!-- HTML -->
    <section id="events">
        <input type="text" v-model="input">
        <p>Your Name: {{ input }}</p>
    </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                input: '',
            }
        }
    });
    
    app.mount('#events');
    ```

## Methods used for Data Bindings: How it works
1. When we execute any method of a Vue component, all the elements that has `v-model` or use `v-bind` will be rerendered, and the methods will be executed again to get the lastest value. This is similar to React framework that the whole component will be re-rendered and updated. 
1. However, this feature wouldn't be useful in some scenario and we don't want this always happens. In the following setup, we can notice that every time we click "add" or "reduce" button, `outputFullName` will be executed.
1. Note that Vue will update the whole component rather than only the specific item in the component. 
    ```html
    <!-- HTML -->
    <section id="events">
        <h2>Events in Action</h2>
        <button v-on:click="add(10)">Add 10</button>
        <button v-on:click="reduce(5)">Subtract 5</button>
        <p>Result: {{ counter }}</p>
        <button v-on:click="resetInput">Reset Input</button>        
        <input type="text" v-model="name">
        <p>Your Name: {{ outputFullname("Last Name") }}</p>
    </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                counter = 0,
                name: '',
            }
        },
        methods: {
            outputFullName(lastName) {
                console.log('Run outputFullName');
                if (this.name === '') {
                    return '';
                } else {
                    return this.name + ' ' + lastName;
                }
            },
            add(num) {
                return this.counter += num;
            },
            reduce(num) {
                return this.counter -= num;
            }
        }
    });

    app.mount('#events');
    ```

## Introducing Computed Properties
1. In the other case, we can use `computed` (another reserved property) which works similar to `methods`. The main difference between them is that `methods` will be re-rendered when there's any thing changes on the page. On the other hand, `computed` only changes when any of its dependency is modified.
1. To use methods in `computed`, we just put the method name in the interpolation in HTML **WITHOUT** parenthesis. Vue will call the method instead.
1. With this approach, the `fullname` method in the following case won't be trigereed every time when other dependency is modified. 
    ```html
    <!-- HTML -->
    <section id="events">
        <h2>Events in Action</h2>
        <button v-on:click="add(10)">Add 10</button>
        <button v-on:click="reduce(5)">Subtract 5</button>
        <p>Result: {{ counter }}</p>
        <button v-on:click="resetInput">Reset Input</button>
        <input type="text" v-model="name">
        <p>Your Name: {{ fullname }}</p>
    </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                name: '',
            }
        },
        computed: {
            fullname() {
                if (this.name === '') {
                    return '';
                }
                return this.name + ' ' + 'last name';
            }
        },
        method: {
            outputFullname() {
                if (this.name === '') {
                    return '';
                }
                return this.name + ' ' + 'last name';
            }
        }
    })
    ```

## Working with Watchers
1. Though "**watchers**" is similar to `computed` or `methods` in Vue, it's binding with the properties in data and don't return the value to use directly. `watch` is the reserved keyword as `computed`, `data`, and `methods` in Vue.
1. `watch` is bound to the properties in `data` returned and will listen to the change of it. 
    1. The methods created in `watch` should be exactly the same as the property name in `data`. 
    1. We don't return any value as it directly manipulate the value of the property in `data`. 
    1. Methods in `watch` can take 2 arguments (new value after change and old value before change). If only one argument is given, it represents the new value. 
1. `computed` as mentioned in the [last section](#Introducing-Computed-Properties) that it listens to the properties given to the methods when it's called. 
1. Though `watch` and `computed` work in similar behavior, `watch` is more suitable to track on single property in `data` and giving constraints. On the other hand, `computed` is good at tracking on multiple dependencies (multiple properties from `data`) and computed for the result. 
    ```html
    <!-- HTML -->
    <section id="events">
        <h2>Events in Action</h2>
        <button v-on:click="resetInput">Reset Input</button>
        <input type="text" v-model="name">
        <input type="text" v-model="lastName">
        <p>Your Name: {{ fullname }}</p>
    </section>
    ```
    ```js
    // JavaScript 
    const app = Vue.createApp({
        data() {
            return {
                name: '',
                lastName: '',
                fullname: '' // this should be taken off if fullname in computed is declared
            }
        },
        watch: { // following methods works exactly the same as fullname method in computed
            name(value){
                if (value === '') {
                    this.fullName = '';
                } else {
                    this.fullName = value + ' ' + this.lastName;
                }
            },
            lastName(value) {
                if (value === '') {
                    this.fullName = '';
                } else {
                    this.fullName = this.name + ' ' + value;
                }
            }
        },
        computed: {
            fullname() {
                if (this.name === '') {
                    return '';
                }
                return this.name + ' ' + this.lastName;
            }
        },
    })
    ```
1. In short summary, methods in `watch` and properties in `data` should have exactly the same name to bound the data, while both of them will get conflict if it's declared in `computed` or `methods`. For example, we can set `setTimeout` to reset the counter when the number is over 50 after 2 seconds. 
    ```html
    <!-- HTML -->
    <section id="events">
        <h2>Events in Action</h2>
        <button v-on:click="add()">Add</button>
        <button v-on:click="reduce()">Subtract</button>
        <p>Result: {{ counter }}</p>
    </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                counter: 0
            };
        },
        watch: {
            counter(value) {
            if (value > 50) {
                setTimeout(() => {
                        this.counter = 0;
                    }, 2000);
                }
            }
        }, 
        methods: {
            add(event, num = 1) {
                this.counter += num;
            },
            reduce(event, num = 1) {
                this.counter -= num;
            }
        }
    });

    app.mount('#events');    
    ```

## Methods vs Computed Properties vs Watchers
1. `methods`
    1. Use with **event** binding OR **data** binding.
    1. Data binding: Method is executed for every "re-render" cycle of the component.
    1. Use for events or data that really needs to be re-evaluated all the time.
1. `computed`
    1. Use with **data** binding.
    1. Computed properties are only re-evaluated if one of their "**used values**" changed.
    1. Use for data that depends on other data.
1. `watch`
    1. Not used directly in template.
    1. Allows you to run any code in reaction to some changed data (e.g. send Http request etc.)
    1. Use for any non-data update you want to make.

## v-bind and v-on Shorthands
1. In Vue, we can use a shorthand to indicate `v-on` attribute in HTML as an `@` sign. Note that we can still put modifiers on the event handler, such as `.right` to listen to right click for "click" event. 
    ```html
    <!-- HTML -->
    <button v-on:click="add(5)">Add</button>
    <button @click.right="reduce(5)">Subtract</button>
    ```
1. For `v-bind`, we can simply use a column `:` to replace the attribute.
    ```html
    <!-- HTML -->
    <a v-bind:href="variable">A Link</a>
    <a :href="variable">A Link</a>
    ```

## Assignmetns 3: Time to practice: Reactivity
1. HTML source code
    ```html
    <body>
    <header>
        <h1>Reactivity in Action</h1>
    </header>
    <section id="assignment">
        <button>Add 5</button>
        <button>Add 1</button>
        <!-- 1) Connect the buttons and calculate a value (a number) -->
        <!-- Show "Not there yet" until you reach a result of exactly 37 -->
        <!-- Show "Too much!" if the result is greater than 37 -->
        <p>Result: RESULT</p>
        <!-- 2) Watch for changes in "result" and reset the value to 0 after 5 seconds -->
    </section>
    </body>
    ```
1. First approach by using only methods. Note that we must call the method in interpolation.
    ```html
    <!-- HTML -->
    <section id="assignment">
        <button @click="add(5)">Add 5</button>
        <button @click="add(1)">Add 1</button>
        <p>Result: {{ result() }}</p>
        <!-- the method must be called -->
    </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                number: 0,
                text: '',
            }
        },
        methods: {
            add(num = 1) {
                this.number += num;
            },
            result() {
                if (this.number > 37) {
                    this.text = 'Too much';
                    setTimeout(() => {
                        this.number = 0;
                    }, 1500);
                } else {
                    this.text = 'Not there yet';
                }
                return this.text;
            }
        }
    });

    app.mount('#assignment');
    ```
1. Second approach that uses all `methods`, `computed`, and `watch`. Note that as `result` is a computed method, it is consumed as a variable by Vue, so we can't call it in the interpolation.
    ```html
    <!-- HTML -->
    <section id="assignment">
        <button @click="add(5)">Add 5</button>
        <button @click="add(1)">Add 1</button>
        <p>Result: {{ result }}</p>
        <!-- the method can't be called -->
    </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                number: 0,
                text: 'Not there yet',
            }
        },
        watch: {
            number(value) {
                if (value > 37) {
                    this.text = 'Too much';
                } else {
                    this.text = 'Not there yet';
                }
            }
        },
        computed: {
            result() {
                if (this.number > 37) {
                    setTimeout(() => {
                        this.number = 0;
                    }, 1500);
                }
                return this.text
            }
        },
        methods: {
            add(num = 1) {
                this.number += num;
            }
        }
    });

    app.mount('#assignment');
    ```
1. Third approach uses only `methods` and `computed`.
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                number: 0,
                text: 'Not there yet',
            }
        },
        computed: {
            result() {
                if (this.number > 37) {
                    this.text = 'Too much';
                    setTimeout(() => {
                        this.number = 0;
                    }, 1500);
                } else {
                    this.text = 'Not there yet';
                }
                return this.text
            }
        },
        methods: {
            add(num = 1) {
                this.number += num;
            }
        }
    });

    app.mount('#assignment');
    ```
1. Solution from the lecture. A watcher can also "watch" on the methods in `computed`. 
    ```html
    <!-- HTML -->
    <section id="assignment">
        <button @click="add(5)">Add 5</button>
        <button @click="add(1)">Add 1</button>
        <p>Result: {{ result }}</p>
        <!-- the method can't be called -->
    </section>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                number: 0,
            }
        },
        watch: {
            result() {
                setTimeout(() => {
                    this.number = 0;
                }, 1500);
            }
        },
        computed: {
            result() {
                if (this.number > 37) {
                    return 'Too much';
                } else if (this.number === 37) {
                    return this.number;
                } else {
                    return 'Not there yet';
                }
            }
        },
        methods: {
            add(num = 1) {
                this.number += num;
            }
        }
    });

    app.mount('#assignment');
    ```

## Dynamic Styling with Inline Styles
1. We can use `v-bind` or its shorthand column `:` to select `style` attribute of a HTML tag. Besides, passing a regular CSS property such as `border-color` we can use curly braces to wrap it and use "**camelCase**" on the property.
1. We then can refer to the `data` for the Vue component and use tenary statement to check what value to return for the style. Note that we can pass the data variable directly in the curly braces.
1. Though we can use `methods` to manulate the style with JavaScript DOM, as we can get the `event` object and change the property with DOM selector `event.target.style.borderColor`. 
    1. However, the first click will only turn the color to red by inline style as the "**state**" just changes, and the component is re-rendered.
    1. Since the "state" has changed and won't change by the 2nd click, the `method` can work on the DOM manipulate and turn the `border-color` into the other given color. 
    ```html
    <!-- HTML -->
    <body>
        <header>
            <h1>Vue Dynamic Styling</h1>
        </header>
        <section id="styling">
            <div class="demo" 
                :style="{borderColor: boxASelected ? 'red' : '#ccc'}" 
                @click="boxSelected($event, 'A')">
            </div>
            <div class="demo" @click="boxSelected('B')"></div>
            <div class="demo" @click="boxSelected('C')"></div>
        </section>
    </body>
    ```
    ```js
    // JavaScript
    const app = Vue.createApp({
        data() {
            return {
                boxASelected: false,
                boxBSelected: false,
                boxCSelected: false,
            };
        },
        methods: {
            boxSelected(event, box) {
                if (box === 'A') {
                    this.boxASelected = true;
                    event.target.style.borderColor = 'blue';
                } else if (box === 'B') {
                    this.boxBSelected = true;
                } else if (box === 'B') {
                    this.boxCSelected = true;
                }
            }
        }
    });

    app.mount('#styling');
    ```

## Adding CSS Classes Dynamically
## Classes & Computed Properties
## Dynamic Classes: Array Syntax



# Redenering Conditional Content & Lists
## Understanding the Problem
## Rendering Content Conditionally
## v-if, v-else and v-else-if
## Using v-show Instead of v-if
## Rendering Lists of Data
## Diving Deeper Into v-for
## Removing List Items
## Lists & Keys



# Coure Project: The Monster Slayer Game
## Project Setup & First Methods
## Updating the Health Bars
## Adding a "Special Attack"
## Adding a "Heal" Functionality
## Adding a "Game Over" Screen
## Finshing the Core Functionality
## Adding a Battle Log



# Vue: Behind the Scenes
## An Introduction to Vue's Reactivity
## Vue Reactivity: A Deep Dive
## One App vs Multiple Apps
## Understanding Templates
## Working with Refs
## How Vue Updates the DOM
## Vue App Lifecycle - Theory
## Vue App Lifecycle - Practice



# Introducing Components
## Understanding the Problem
## Introducing Components
## The Why: Building Complex User Interfaces With Components



# Moving to a Better Development SEtup & Workflow with the Vue CLI
## Why We Need A Development Server
## WHy We Want A Better Developer Experience
## Installing & Using the Vue CLI
## Inspecting the Created Project
## Inspecting the Vue Code & ".vue" Files
## Adding the "Vutur" Extension to VS Code
## More on ".vue" Files
## A New Vue Project
## Creating a Basic Vue App
## Adding a Component
## Adding Styling



# Component Communication
## Introducing "Props" (Parent => Child Communication)
## Prop Behavior & Changing Props
## Validating Props
## Working with Dynamic Props Values
## Emitting Custom Events (Child => Parent Communication)
## Defining & Validating Custom Events
## Prop / Event Fallthrough & Binding All Props
## Demo: Adding Components & Connecting Them
## Demo: Adding More Component Communication
## A Potential Problem
## Provide + Inject To The Rescue
## Provide + Inject for Functions / Methods
## Provide + Inject vs Props & Custom Events



# Diving Deeper Into Components
## Project Setup
## Global vs Local Components
## Scoped Styles
## Introducing Slots
## Named Slots
## Slot Styles & Compilation
## More on Slots
## Scoped Slots
## Dynamic Components
## Keeping Dynamic Components Alive
## Applying What We Know & A Problem
## Teleporting Elements
## Working with Fragments
## The Vue Style Guide
## Moving to a Different Folder Structure



# Course Projct: The Learning Resources App
## Setup & First Steps
## First Components & Props
## Styling and More Components
## Header & BaseCard Components
## Adding a Base Button
## Dynamic Components & Attribute Fallthrough
## Adding & Styling Tabs
## Adding a Form
## Fetching User Input
## Adding a Modal Dialog
## Deleting Items
## Adding "Teleport"



# Form
## v-model & Inputs
## Working with v-model Modifiers and Numbers
## v-model and Dropdowns
## Using v-model with Checkboxes & Radiobuttons
## Adding Basic Form Validation
## Building a Custom Control Component
## Using v-model on Custom Components



# Sending Http Requests
## Starting App & Why we need a Backend
## Adding a Backend
## How to (Not) Send Http Requests
## Sending a POST Request to Store Data
## Getting Data (GET Request) & Transforming Response Data
## Loading Data When a Component Mounts
## Showing a "Loading..." Message
## Handling the "No Data" State
## Handling Technical / Browser-side Errors
## Handling Error Responses



# Routing: Building "Multi-Page" Single Page Application
## What & Why?
## Routing Setup
## Registering & Rendering Routes
## Navigating with router-link
## Styling Active Links
## Programmatic Navigation
## Passing Data with Route Params (Dynamic Segments)
## Navigation & Dynamic Paths
## A Vue Bug
## Updating Params Data with Watchers
## Passing Params as Props
## Redirecting & "Catch All" Routes
## Using Nested Routes
## More Fun with Named Routes & Location Objects
## Using Query Params
## Rendering Multiple Routers with Named Router Views
## Controlling Scroll Behavior
## Introducing Navigation Guards
## Diving Deeper Into Navigation Guards
## The Global "afterEach" Guard
## Beyond Entering: Route Leave Guards
## Utilizing Route Metadata
## Organizing Route Files



# Animations & Transitions
## Animation Basics & CSS Transitions
## Understanding CSS Animations
## Why is "Just CSS" Not Enough?
## Playing CSS Animations with Vue's Help
## Using the Transition Component
## CSS Animations with the Transition Component
## Using Custom CSS Class Names
## Example: Animating a Modal
## Transitioning Between Multiple Elements
## Using Transition Events
## Building JavaScript Transitions (instead of CSS)
## Disabling CSS Transitions
## Getting Started with Animated Lists
## Animating Lists with "transition-group"
## Animate List Item Movement
## Animate Route Changes



# Vuex
## What & Why?
## Creating & Using a Store
## Connecting Components to State
## Introducing Mutations - A Better Way of Changing Data
## Passing Data to Mutations with Payloads
## Introducing Getters - A Better Way Of Getting Data
## Running Async Code with Actions
## Understanding the Action "Context"
## Using Mapper Helpers
## Organizing your Store with Modules
## Understanding Local Module State
## Namespacing Modules
## Structuring Vuex Code & Files



# Main Project: "Find a Coach" Web App
## Planning the Project / Web App
## Planning the Data Requirements
## Planning the Layout / Components
## Registering Routes
## Adding Route Page Components
## Working on the Main Layout & Styling
## Wiring Up Pages
## Adding Vuex and Coach Data
## Working on the Coaches List and List Items
## Adding a Couple of Base Components (Base Card, Base Button, Base Badge)
## Building the Coach Detail Component
## Filtering Coaches
## Registering as a Coach: The Form
## Adding Coaches to Vuex
## Adding Form Validation
## Working on the Contact Form
## Storing Requests (Messages) with Vuex
## Outputting Incoming Requests (Messages)
## Filtering Requests for teh Active Coach
## Sending a PUT Http Request to Store Coach Data
## Fetching Coach Data (GET Http Request)
## Rendering a Loading Spinner
## Adding Http Error Handling
## Sending Coaching Requests Http Requests
## Caching Http Response Data
## Adding Route Transitions
## The "Not Found" Page & Summary



# Vue & Authentication
## How Authentication Works in Vue Apps (or any SPA)
## Locking / Protecting Backend Resources
## Adding an Authentication Page (Login & Signup)
## Preparing Vuex
## Adding a "Signup" Action & Flow
## Better UX: Loading Spinner & Error Handling
## Adding a "Login" Action & Flow
## Attaching the Token to Outgoing Requests
## Updating the UI Based on Auth State
## Adding a "Logout" Action & Flow
## Authentication & Routing (incl. Navigation Guards)
## Adding "Auto Login"
## Adding "Auto Logout"



# Optimizing & Deploying Vue Apps
## What To Deploy?
## Optimization: Using Asynchronous Components
## Building the Project For Production
## Deploying a Vue App



# The Composition API - Replacing the Options API
## Which Problem Does the Composition API Solve?
## Replacing "data" with "refs"
## Building "reactive" Objects
## Reactivity: A Deep Dive
## Replacing "methods" with regular Functions
## Replacing "Computed Properties" with the "computed" Function
## Two-Way-Binding and the Composition API
## Working with Watchers
## A First Summary
## How to Use Templates Refs
## Components, Props, & The Composition API
## Emitting Custom Events
## Working with Provide / Inject
## Lifecycle Hooks in the Composition API
## Migrating from Options API to Composition API - an Example Project
## Migrating a First Component
## Migrating a Big Component
## Migrating the Remaining Components
## Routing, Params & The Composition API
## The Route & Router Objects and the Composition API
## Using Vuex with the Composition API



# Reusing Funcitonality: Mixins & Custom Composition Functions
## Reusability Concepts
## Using Mixins
## Understanding Mixin Merging
## Global Mixins
## Disadvantages of Mixins
## Custom Hooks / Composables & The Composition API
## More Custom Composition Functions
## Why Hookks / Composables Beat Mixins
## Example: Creating a "Search" Hook
## Custom Hooks Gotchas
## More Thoughts on Custom Hooks / Composables
## Example: A Custom "Sort" Hook